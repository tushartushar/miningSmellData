Implementation smell,Namespace,Class,File,Method,Description
Long Method,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The method has 120 lines of code.
Long Method,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,getConfigFor,The method has 116 lines of code.
Long Method,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The method has 165 lines of code.
Long Method,WiiTUIO,KeymapDatabase,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapDatabase.cs,KeymapDatabase,The method has 222 lines of code.
Long Method,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The method has 118 lines of code.
Long Method,WiiTUIO.Output.Handlers,VmultiKeycodeAdapter,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\VmultiKeyboardHandler.cs,ConvertVirtualKeyCode,The method has 199 lines of code.
Long Method,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,setPosition,The method has 102 lines of code.
Long Method,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The method has 187 lines of code.
Long Method,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The method has 129 lines of code.
Long Method,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The method has 214 lines of code.
Long Method,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The method has 180 lines of code.
Long Method,WiiTUIO.Provider,WiiKeyMapper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMapper.cs,processWiimoteState,The method has 132 lines of code.
Long Method,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The method has 157 lines of code.
Long Method,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The method has 120 lines of code.
Long Method,WiiTUIO.Provider,SpatioTemporalClassifier,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,processFrame,The method has 126 lines of code.
Complex Method,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,setConfigFor,Cyclomatic complexity of the method is 11
Complex Method,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,getConfigFor,Cyclomatic complexity of the method is 10
Complex Method,WiiTUIO.DeviceUtils,VmultiUtil,C:\repos\simphax_Touchmote\WiiTUIO\DeviceUtils\VmultiUtil.cs,setCurrentMonitor,Cyclomatic complexity of the method is 8
Complex Method,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,setPosition,Cyclomatic complexity of the method is 15
Complex Method,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,Cyclomatic complexity of the method is 19
Complex Method,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,Cyclomatic complexity of the method is 19
Complex Method,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,Cyclomatic complexity of the method is 31
Complex Method,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,Cyclomatic complexity of the method is 27
Complex Method,WiiTUIO.Provider,WiiKeyMapper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMapper.cs,processWiimoteState,Cyclomatic complexity of the method is 15
Complex Method,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,Cyclomatic complexity of the method is 13
Complex Method,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,WiimoteHandlerWorker,Cyclomatic complexity of the method is 9
Complex Method,WiiTUIO.Provider,SpatioTemporalClassifier,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,processFrame,Cyclomatic complexity of the method is 23
Complex Method,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,Cyclomatic complexity of the method is 18
Complex Method,WiiTUIO.WinTouch,MTVProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\MTVProviderHandler.cs,sendContacts,Cyclomatic complexity of the method is 8
Long Parameter List,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,appendConnectionList,The method has 5 parameters. Parameters: list' keymap' wiimote' defaultKeymap' container
Long Parameter List,WiiTUIO,KeymapInput,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapDatabase.cs,KeymapInput,The method has 6 parameters. Parameters: source' name' key' button' continous' cursor
Long Parameter List,WiiTUIO,KeymapOutput,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapDatabase.cs,KeymapOutput,The method has 7 parameters. Parameters: type' name' key' button' continous' cursor' stackable
Long Parameter List,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,StartD3DCursorWindow,The method has 8 parameters. Parameters: hInstance' parent' windowX' windowY' windowWidth' windowHeight' topmost' cursorScale
Long Parameter List,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,SetD3DCursorWindowPosition,The method has 5 parameters. Parameters: x' y' width' height' topmost
Long Parameter List,WiiTUIO.Provider,CursorPos,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\CursorPos.cs,CursorPos,The method has 5 parameters. Parameters: x' y' relativeX' relativeY' rotation
Long Parameter List,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setSource,The method has 8 parameters. Parameters: x0' y0' x1' y1' x2' y2' x3' y3
Long Parameter List,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setDestination,The method has 8 parameters. Parameters: x0' y0' x1' y1' x2' y2' x3' y3
Long Parameter List,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The method has 9 parameters. Parameters: x0' y0' x1' y1' x2' y2' x3' y3' mat
Long Parameter List,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The method has 9 parameters. Parameters: x0' y0' x1' y1' x2' y2' x3' y3' mat
Long Parameter List,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The method has 5 parameters. Parameters: mat' srcX' srcY' dstX' dstY
Long Parameter List,WiiTUIO.Provider,WiiContact,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiContact.cs,WiiContact,The method has 5 parameters. Parameters: iID' eContactType' tPosition' priority' tScreenSize
Long Parameter List,WiiTUIO.Provider,CalibrationRectangle,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiProvider.cs,CalibrationRectangle,The method has 8 parameters. Parameters: x0' y0' x1' y1' x2' y2' x3' y3
Long Identifier,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,,The length of the parameter connection_input_config_openbutton is 34.
Long Identifier,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,,The length of the parameter connection_input_config_closebutton is 35.
Long Identifier,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,,The length of the parameter connection_input_config_border is 30.
Long Identifier,WiiTUIO.Provider,WiimoteControl,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\WiimoteControl.cs,,The length of the parameter LastSignificantWiimoteEventTime is 31.
Long Identifier,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,,The length of the parameter WIIMOTE_POWER_SAVE_DISCONNECT_TIMEOUT is 37.
Long Identifier,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,,The length of the parameter WIIMOTE_SIGNIFICANT_DISCONNECT_TIMEOUT is 38.
Long Identifier,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,,The length of the parameter wiimoteExtensionChangedEventHandler is 35.
Long Identifier,WiiTUIO.Properties,Settings,C:\repos\simphax_Touchmote\WiiTUIO\Properties\Settings.cs,,The length of the parameter _defaultContinousPressThreshold is 31.
Long Identifier,WiiTUIO.Properties,Settings,C:\repos\simphax_Touchmote\WiiTUIO\Properties\Settings.cs,,The length of the parameter _alternativeStickToCursorMapping is 32.
Long Identifier,WiiTUIO.Properties,Settings,C:\repos\simphax_Touchmote\WiiTUIO\Properties\Settings.cs,,The length of the parameter _pointer_sensorBarPosCompensation is 33.
Long Identifier,WiiTUIO.Properties,Settings,C:\repos\simphax_Touchmote\WiiTUIO\Properties\Settings.cs,,The length of the parameter _pointer_cursorStillHideTimeout is 31.
Long Identifier,WiiTUIO.Properties,Settings,C:\repos\simphax_Touchmote\WiiTUIO\Properties\Settings.cs,,The length of the parameter _touch_edgeGestureHelperMargins is 31.
Long Identifier,WiiTUIO.Properties,Settings,C:\repos\simphax_Touchmote\WiiTUIO\Properties\Settings.cs,,The length of the parameter _touch_edgeGestureHelperRelease is 31.
Long Statement,WiiTUIO,AboutUC,C:\repos\simphax_Touchmote\WiiTUIO\AboutUC.xaml.cs,Connect,The length of the statement  "            ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate); " is 156.
Long Statement,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The length of the statement  "            this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1); " is 129.
Long Statement,WiiTUIO,Autostart,C:\repos\simphax_Touchmote\WiiTUIO\Autostart.cs,SetAutostart,The length of the statement  "                td.Actions.Add(new ExecAction(System.AppDomain.CurrentDomain.BaseDirectory + "Touchmote.exe"' null' System.AppDomain.CurrentDomain.BaseDirectory)); " is 147.
Long Statement,WiiTUIO,KeymapOutputRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputRow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/keymapconfig/keymapoutputrow.xaml"' System.UriKind.Relative); " is 127.
Long Statement,WiiTUIO,KeymapOutputItem,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputItem.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/keymapconfig/keymapoutputitem.xaml"' System.UriKind.Relative); " is 128.
Long Statement,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/keymapconfig/keymapconnectionrow.xaml"' System.UriKind.Relative); " is 131.
Long Statement,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The length of the statement  "            this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp); " is 149.
Long Statement,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The length of the statement  "            this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp); " is 151.
Long Statement,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,setConfigFor,The length of the statement  "                    if (config.Scale != Settings.Default.defaultContinousScale || config.Threshold != Settings.Default.defaultContinousPressThreshold || config.Deadzone != Settings.Default.defaultContinousDeadzone) " is 194.
Long Statement,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,getConfigFor,The length of the statement  "                                if (((JObject)level2).GetValue("threshold") != null && ((JObject)level2).GetValue("threshold").Type == JTokenType.Float) " is 120.
Long Statement,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,getConfigFor,The length of the statement  "                //This means we have no setting for the input on this keymap nor any keymap to inherit from. Let's save a "Disable" setting on this. " is 132.
Long Statement,WiiTUIO,Keymap,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\Keymap.cs,getConfigFor,The length of the statement  "                this.setConfigFor(controllerId' KeymapDatabase.Current.getInput(input)' new KeymapOutConfig(KeymapDatabase.Current.getDisableOutput()'false)); " is 142.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,selectKeymap,The length of the statement  "            this.cbApplicationSearch.IsChecked = KeymapDatabase.Current.getKeymapSettings().isInApplicationSearch(this.currentKeymap); " is 122.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,selectKeymap,The length of the statement  "            this.tbDelete.Visibility = this.currentKeymap.Filename == KeymapDatabase.Current.getKeymapSettings().getDefaultKeymap() ? Visibility.Hidden : Visibility.Visible; " is 161.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,fillConnectionLists,The length of the statement  "            this.appendConnectionList(KeymapDatabase.Current.getAvailableInputs(KeymapInputSource.IR)' keymap' wiimote' defaultKeymap' this.spWiimoteConnections); " is 150.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,fillConnectionLists,The length of the statement  "            this.appendConnectionList(KeymapDatabase.Current.getAvailableInputs(KeymapInputSource.WIIMOTE)' keymap' wiimote' defaultKeymap' this.spWiimoteConnections); " is 155.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,fillConnectionLists,The length of the statement  "            this.appendConnectionList(KeymapDatabase.Current.getAvailableInputs(KeymapInputSource.NUNCHUK)' keymap' wiimote' defaultKeymap' this.spNunchukConnections); " is 155.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,fillConnectionLists,The length of the statement  "            this.appendConnectionList(KeymapDatabase.Current.getAvailableInputs(KeymapInputSource.CLASSIC)' keymap' wiimote' defaultKeymap' this.spClassicConnections); " is 155.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,tbDelete_MouseUp,The length of the statement  "            if (MessageBoxResult.Yes == MessageBox.Show("This will pernamently delete the file " + this.currentKeymap.Filename + "' are you sure?"' "Delete keymap confirmation"' MessageBoxButton.YesNo' MessageBoxImage.Warning)) " is 215.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/keymapconfig/keymapconfigwindow.xaml"' System.UriKind.Relative); " is 130.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The length of the statement  "            this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged); " is 123.
Long Statement,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The length of the statement  "            this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged); " is 120.
Long Statement,WiiTUIO,KeymapInput,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapDatabase.cs,canHandle,The length of the statement  "            return ((this.Button == output.Button || this.Continous == output.Continous) && this.Cursor == output.Cursor) || output.Type == KeymapOutputType.DISABLE; " is 153.
Long Statement,WiiTUIO,KeymapRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapRow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/keymapconfig/keymaprow.xaml"' System.UriKind.Relative); " is 121.
Long Statement,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,checkNewVersionResponse,The length of the statement  "                    this.ShowMessage("A new version (" + jObject.GetValue("latest_version").ToString() + ") is available at touchmote.net"' MessageType.Info); " is 138.
Long Statement,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,onPairingProgress,The length of the statement  "            Console.WriteLine("Pairing progress: number=" + report.numberPaired + " removeMode=" + report.removeMode + " devicelist=" + report.deviceNames); " is 144.
Long Statement,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,onPairingProgress,The length of the statement  "                        this.ShowMessage("At least one of your Wiimotes is not compatible with the Microsoft Bluetooth Stack' use only Wiimotes manufactured before November 2011 or try the instructions on touchmote.net/wiimotetr "'MessageType.Info); " is 225.
Long Statement,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The length of the statement  "            ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click); " is 126.
Long Statement,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The length of the statement  "            ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate); " is 156.
Long Statement,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,updateWindowToScreen,The length of the statement  "            UIHelpers.SetWindowPos((new WindowInteropHelper(this)).Handle' IntPtr.Zero' screen.Bounds.X' screen.Bounds.Y' screen.Bounds.Width' screen.Bounds.Height' UIHelpers.SetWindowPosFlags.SWP_NOACTIVATE | UIHelpers.SetWindowPosFlags.SWP_NOZORDER); " is 240.
Long Statement,WiiTUIO.Output,VmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\VmultiProviderHandler.cs,processEventFrame,The length of the statement  "                if (Settings.Default.pointer_customCursor && (contact.Type == ContactType.Hover || contact.Type == ContactType.EndFromHover)) " is 125.
Long Statement,WiiTUIO.Output,VmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\VmultiProviderHandler.cs,processEventFrame,The length of the statement  "                    //If we are using the custom cursor and it's more than 1 touchpoints' we skip the hovering because otherwise it's not working with edge guestures for example. " is 158.
Long Statement,WiiTUIO.Output,TUIOSettings,C:\repos\simphax_Touchmote\WiiTUIO\Output\Settings\TUIOSettings.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/output/settings/tuiosettings.xaml"' System.UriKind.Relative); " is 127.
Long Statement,WiiTUIO.Output,TouchInjectProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TouchInjectProviderHandler.cs,processEventFrame,The length of the statement  "                    if (Settings.Default.pointer_customCursor && (contact.Type == ContactType.Hover || contact.Type == ContactType.EndFromHover)) " is 125.
Long Statement,WiiTUIO.Output,TouchInjectProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TouchInjectProviderHandler.cs,processEventFrame,The length of the statement  "                        //If we are using the custom cursor and it's more than 1 touchpoints' we skip the hovering because otherwise it's not working with edge guestures for example. " is 158.
Long Statement,WiiTUIO.Output,TUIOProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOProviderHandler.cs,connect,The length of the statement  "            pUDPWriter = new OSCTransmitter(WiiTUIO.Properties.Settings.Default.tuio_IP' WiiTUIO.Properties.Settings.Default.tuio_port); " is 124.
Long Statement,WiiTUIO.Output.Handlers,HandlerFactory,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\HandlerFactory.cs,createOutputHandlers,The length of the statement  "            IOutputHandler keyboardHandler = VmultiDevice.Current.isAvailable() ? (IOutputHandler)(VmultiKeyboardHandler.Default) : (IOutputHandler)(new KeyboardHandler()); " is 160.
Long Statement,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The length of the statement  "                this.inputSimulator.Mouse.MoveMouseBy((int)(Settings.Default.fpsmouse_speed * shiftX)' (int)(Settings.Default.fpsmouse_speed * shiftY)); " is 136.
Long Statement,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,updateWindowToScreen,The length of the statement  "            SetD3DCursorWindowPosition(screen.Bounds.X' screen.Bounds.Y' screen.Bounds.Width' screen.Bounds.Height' !Settings.Default.noTopmost); " is 133.
Long Statement,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,Start,The length of the statement  "            StartD3DCursorWindow(Process.GetCurrentProcess().Handle' parent' primaryScreen.Bounds.X' primaryScreen.Bounds.Y' primaryScreen.Bounds.Width' primaryScreen.Bounds.Height' !Settings.Default.noTopmost' (float)Settings.Default.pointer_cursorSize); " is 243.
Long Statement,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,setPosition,The length of the statement  "            if (!this.touchDownMaster && !this.touchDownSlave && Math.Abs(this.timeoutCursorPos.X - cursorPos.X) < Settings.Default.pointer_cursorStillThreshold && Math.Abs(this.timeoutCursorPos.Y - cursorPos.Y) < Settings.Default.pointer_cursorStillThreshold) " is 248.
Long Statement,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,normalStickCursor,The length of the statement  "                int x = fromPos.X + step > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : fromPos.X + step; " is 122.
Long Statement,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,normalStickCursor,The length of the statement  "                int y = fromPos.Y + step > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : fromPos.Y + step; " is 124.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                            if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold) " is 169.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                                /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/ " is 170.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                        if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right " is 159.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                        if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom " is 162.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                    if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again " is 190.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                        this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height)); " is 176.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                        this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height)); " is 173.
Long Statement,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The length of the statement  "                    this.lastSlaveContact = new WiiContact(this.slaveID' contactType' this.slavePosition'this.slavePriority' new Vector(this.screenBounds.Width' this.screenBounds.Height)); " is 168.
Long Statement,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,SetKeymap,The length of the statement  "                    this.OnConfigChanged(new WiiKeyMapConfigChangedEvent(keymap.getName()'keymap.getFilename()'pointerConfig.Stack.First().Key)); " is 125.
Long Statement,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,SendConfigChangedEvt,The length of the statement  "                this.OnConfigChanged(new WiiKeyMapConfigChangedEvent(keymap.getName()' keymap.getFilename()' pointerConfig.Stack.First().Key)); " is 127.
Long Statement,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,executeButtonUp,The length of the statement  "                    if (!(output.Continous && KeymapDatabase.Current.getInput(button).Continous)) //Exclude the case when a stick is connected to a stick. It should not trigger the press action. " is 174.
Long Statement,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,executeButtonDown,The length of the statement  "                    if (!(output.Continous && KeymapDatabase.Current.getInput(button).Continous)) //Exclude the case when a continous output is connected to a continous output. It should not trigger the button action. " is 197.
Long Statement,WiiTUIO.Provider,WiimoteControl,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\WiimoteControl.cs,WiiKeyMap_ConfigChanged,The length of the statement  "                OverlayWindow.Current.ShowNotice("Layout for Wiimote " + this.Status.ID + " changed to \"" + evt.Name + "\""' this.Status.ID); " is 126.
Long Statement,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/input/wiiprovider/settings/calibrate.xaml"' System.UriKind.Relative); " is 135.
Long Statement,WiiTUIO.Provider,CalibrationWindow,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\CalibrationWindow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/input/wiiprovider/settings/calibrationwindow.xaml"' System.UriKind.Relative); " is 143.
Long Statement,WiiTUIO.Provider,WiiKeyMapper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMapper.cs,processChanged,The length of the statement  "                string appStringToMatch = evt.Process.MainModule.FileVersionInfo.FileDescription + evt.Process.MainModule.FileVersionInfo.OriginalFilename + evt.Process.MainModule.FileVersionInfo.FileName; " is 189.
Long Statement,WiiTUIO.Provider,WiiKeyMapper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMapper.cs,processChanged,The length of the statement  "                List<ApplicationSearchSetting> applicationConfigurations = KeymapDatabase.Current.getKeymapSettings().getApplicationSearchSettings(); " is 133.
Long Statement,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The length of the statement  "                                //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z)); " is 137.
Long Statement,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The length of the statement  "                //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.Values.X' args.WiimoteState.AccelState.Values.Z)); " is 131.
Long Statement,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The length of the statement  "                            Console.WriteLine("Teardown 1 " + pDevice.HIDDevicePath + " because of timeout with delta " + DateTime.Now.Subtract(pWiimoteMap[pDevice.HIDDevicePath].LastWiimoteEventTime).TotalMilliseconds); " is 192.
Long Statement,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The length of the statement  "                            && DateTime.Now.Subtract(control.LastSignificantWiimoteEventTime).TotalMilliseconds > WIIMOTE_SIGNIFICANT_DISCONNECT_TIMEOUT) " is 125.
Long Statement,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The length of the statement  "                            Console.WriteLine("Put " + pDevice.HIDDevicePath + " to power saver mode because of timeout with delta " + DateTime.Now.Subtract(control.LastSignificantWiimoteEventTime).TotalMilliseconds); " is 189.
Long Statement,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The length of the statement  "                            Console.WriteLine("Teardown 2 " + pDevice.HIDDevicePath + " because of timeout with delta " + DateTime.Now.Subtract(control.LastWiimoteEventTime).TotalMilliseconds); " is 165.
Long Statement,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/input/wiiprovider/settings/wiipointerprovidersettings.xaml"' System.UriKind.Relative); " is 152.
Long Statement,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The length of the statement  "            this.MonitorComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.MonitorComboBox_SelectionChanged); " is 137.
Long Statement,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The length of the statement  "            this.SBPositionComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.SBPositionComboBox_SelectionChanged); " is 143.
Long Statement,WiiTUIO.Provider,SpatioTemporalTracker,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,distanceToSegment,The length of the statement  "            double u = ((vPoint.X - vLineA.X) * vDelta.X + (vPoint.Y - vLineA.Y) * vDelta.Y) / (vDelta.X * vDelta.X + vDelta.Y * vDelta.Y); " is 127.
Long Statement,WiiTUIO.Provider,SmoothingBuffer,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,getSmoothedValue,The length of the statement  "                double deltaX = Math.Abs(curVector.X*4 - tSmoothBuffer[iMax-2].X - tSmoothBuffer[iMax-3].X - tSmoothBuffer[iMax-4].X - tSmoothBuffer[iMax-5].X); " is 144.
Long Statement,WiiTUIO.Provider,WiiProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiProvider.cs,handleInputClassifier_OnEnd,The length of the statement  "            lFrame.Enqueue(new WiiContact(pTracker.ID' ContactType.End' new System.Windows.Point(pTracker.Position.X' pTracker.Position.Y)' 1' ScreenSize)); " is 144.
Long Statement,WiiTUIO.Provider,WiiProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiProvider.cs,handleInputClassifier_OnUpdate,The length of the statement  "            lFrame.Enqueue(new WiiContact(pTracker.ID' ContactType.Move' new System.Windows.Point(pTracker.Position.X' pTracker.Position.Y)' 1' ScreenSize)); " is 145.
Long Statement,WiiTUIO.Provider,WiiProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiProvider.cs,handleInputClassifier_OnStart,The length of the statement  "            lFrame.Enqueue(new WiiContact(pTracker.ID' ContactType.Start' new System.Windows.Point(pTracker.Position.X' pTracker.Position.Y)' 1' ScreenSize)); " is 146.
Long Statement,WiiTUIO.Provider,WiiProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiProvider.cs,initialiseWiimoteConnection,The length of the statement  "            this.pDevice.WiimoteExtensionChanged += new EventHandler<WiimoteExtensionChangedEventArgs>(handleWiimoteExtensionChanged); " is 122.
Long Statement,WiiTUIO.Provider,WiiProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiProviderSettings.xaml.cs,btnCalibrate_Click,The length of the statement  "                this.pCalibrationWindow.CalibrationCanvas.OnCalibrationFinished += new Action<WiiProvider.CalibrationRectangle' WiiProvider.CalibrationRectangle' Vector>(CalibrationCanvas_OnCalibrationFinished); " is 195.
Long Statement,WiiTUIO.Provider,WiiProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiProviderSettings.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Touchmote;component/input/wiiprovider/settings/wiiprovidersettings.xaml"' System.UriKind.Relative); " is 145.
Long Statement,WiiTUIO.WinTouch,HidContactInfo,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\HumanInterfaceDevice.cs,ToString,The length of the statement  "            return string.Format("Id: {0}' State: {1}' TipSwitch: {2}' InRange: {3}' X'Y: {4}'{5}' W'H: {6}'{7}' Pressure: {8}' TimeStamp: {9}"' " is 132.
Long Statement,WiiTUIO.WinTouch,MTVProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\MTVProviderHandler.cs,connect,The length of the statement  "                throw new InvalidOperationException("Universal Software HID driver was not found. Please ensure that it is installed."); " is 120.
Long Statement,WiiTUIO.WinTouch,MTVProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\MTVProviderHandler.cs,sendContacts,The length of the statement  "            lContacts.AddRange(this.dLastContacts.Values.Except(lContacts' this.pComparer).Where(c => c.State == HidContactState.Updated).ToList()); " is 136.
Long Statement,WiiTUIO.WinTouch,MTVProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\MTVProviderHandler.cs,sendContacts,The length of the statement  "            foreach (ushort id in this.dLastContacts.Values.Where(c => c.State == HidContactState.Removed).Select(c => c.Id).ToList()) " is 122.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\simphax_Touchmote\WiiTUIO\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,setPosition,The conditional expression  "!this.touchDownMaster && !this.touchDownSlave && Math.Abs(this.timeoutCursorPos.X - cursorPos.X) < Settings.Default.pointer_cursorStillThreshold && Math.Abs(this.timeoutCursorPos.Y - cursorPos.Y) < Settings.Default.pointer_cursorStillThreshold"  is complex.
Empty Catch Block,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,checkNewVersion,The method has an empty catch block.
Empty Catch Block,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,checkNewVersionResponse,The method has an empty catch block.
Empty Catch Block,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,startProvider,The method has an empty catch block.
Empty Catch Block,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,createProvider,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,start_service,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,start_service,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,start_service,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,stop_service,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,stop_service,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,stop_service,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,putToPowerSave,The method has an empty catch block.
Empty Catch Block,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,wakeFromPowerSave,The method has an empty catch block.
Magic Number,WiiTUIO,AboutUC,C:\repos\simphax_Touchmote\WiiTUIO\AboutUC.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAboutBack = ((System.Windows.Controls.Button)(target));                            #line 19 "..\..\AboutUC.xaml"              this.btnAboutBack.Click += new System.Windows.RoutedEventHandler(this.btnAboutBack_Click);                            #line default              #line hidden              return;              case 2:              this.versionLabel = ((System.Windows.Controls.Label)(target));              return;              case 3:                            #line 29 "..\..\AboutUC.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,AboutUC,C:\repos\simphax_Touchmote\WiiTUIO\AboutUC.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAboutBack = ((System.Windows.Controls.Button)(target));                            #line 19 "..\..\AboutUC.xaml"              this.btnAboutBack.Click += new System.Windows.RoutedEventHandler(this.btnAboutBack_Click);                            #line default              #line hidden              return;              case 2:              this.versionLabel = ((System.Windows.Controls.Label)(target));              return;              case 3:                            #line 29 "..\..\AboutUC.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapOutputItem,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputItem.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));                            #line 15 "..\..\..\KeymapConfig\KeymapOutputItem.xaml"              this.border.MouseMove += new System.Windows.Input.MouseEventHandler(this.border_MouseMove);                            #line default              #line hidden                            #line 15 "..\..\..\KeymapConfig\KeymapOutputItem.xaml"              this.border.TouchDown += new System.EventHandler<System.Windows.Input.TouchEventArgs>(this.border_TouchDown);                            #line default              #line hidden                            #line 15 "..\..\..\KeymapConfig\KeymapOutputItem.xaml"              this.border.TouchMove += new System.EventHandler<System.Windows.Input.TouchEventArgs>(this.border_TouchMove);                            #line default              #line hidden              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,WiiTUIO,TestAdorner,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputItem.xaml.cs,TestAdorner,The following statement contains a magic number: adornedElementRect = new Rect(0'0'142'29);
Magic Number,WiiTUIO,TestAdorner,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputItem.xaml.cs,TestAdorner,The following statement contains a magic number: adornedElementRect = new Rect(0'0'142'29);
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,SetConfig,The following statement contains a magic number: if (config.Inherited)              {                  this.connection_output_stack.Opacity = 0.6;                  this.rAdd.Visibility = Visibility.Hidden;                  this.rClear.Visibility = Visibility.Hidden;              }              else              {                  this.connection_output_stack.Opacity = 1.0;                  this.rAdd.Visibility = Visibility.Visible;                  this.rClear.Visibility = Visibility.Visible;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,btn2_Click,The following statement contains a magic number: this.selectWiimoteNumber(2);
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,btn3_Click,The following statement contains a magic number: this.selectWiimoteNumber(3);
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,btn4_Click,The following statement contains a magic number: this.selectWiimoteNumber(4);
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,KeymapRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.tbDefault = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,WiiTUIO,KeymapRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.tbDefault = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,WiiTUIO,LayoutSelectionRow,C:\repos\simphax_Touchmote\WiiTUIO\LayoutSelectionRow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));                            #line 8 "..\..\LayoutSelectionRow.xaml"              this.border.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbName_MouseUp);                            #line default              #line hidden              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,wiiPairThreadWorker,The following statement contains a magic number: wiiPair.start(true'10);
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,onPairingProgress,The following statement contains a magic number: if (report.status == WiiCPP.WiiPairReport.Status.RUNNING)              {                  if (report.numberPaired > 0)                  {                      Settings.Default.pairedOnce = true;                        if (report.deviceNames.Contains(@"Nintendo RVL-CNT-01-TR"))                      {                          this.ShowMessage("At least one of your Wiimotes is not compatible with the Microsoft Bluetooth Stack' use only Wiimotes manufactured before November 2011 or try the instructions on touchmote.net/wiimotetr "'MessageType.Info);                      }                  }              }              else              {                  if (report.removeMode && report.status != WiiCPP.WiiPairReport.Status.CANCELLED)                  {                      this.wiiPairRunning = true;                        Dispatcher.BeginInvoke(new Action(delegate()                      {                          this.connectProvider();                      })' null);                        int stopat = 10;                      if (this.startupPair)                      {                          stopat = 1;                          this.startupPair = false;                      }                      wiiPair.start(false' stopat); //Run the actual pairing after removing all previous connected devices.                  }                  else                  {                      this.wiiPairRunning = false;                      Dispatcher.BeginInvoke(new Action(delegate()                      {                          //this.canvasPairing.Visibility = Visibility.Collapsed;                          this.animateCollapse(this.spPairing'false);                          this.tbPair2.Visibility = Visibility.Visible;                          this.tbPairDone.Visibility = Visibility.Collapsed;                            this.pairProgress.IsActive = false;                      })' null);                  }              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayNotice,C:\repos\simphax_Touchmote\WiiTUIO\OverlayNotice.xaml.cs,OverlayNotice,The following statement contains a magic number: bordercolor.R = (byte)(bordercolor.R * 0.8);
Magic Number,WiiTUIO,OverlayNotice,C:\repos\simphax_Touchmote\WiiTUIO\OverlayNotice.xaml.cs,OverlayNotice,The following statement contains a magic number: bordercolor.G = (byte)(bordercolor.G * 0.8);
Magic Number,WiiTUIO,OverlayNotice,C:\repos\simphax_Touchmote\WiiTUIO\OverlayNotice.xaml.cs,OverlayNotice,The following statement contains a magic number: bordercolor.B = (byte)(bordercolor.B * 0.8);
Magic Number,WiiTUIO,OverlayNotice,C:\repos\simphax_Touchmote\WiiTUIO\OverlayNotice.xaml.cs,fadeOut,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  DoubleAnimation pAnimation = UIHelpers.createDoubleAnimation(0' 1000' false);                  pAnimation.FillBehavior = FillBehavior.HoldEnd;                  pAnimation.Completed += delegate(object sender' EventArgs pEvent)                  {                      UIHelpers.animateCollapse(this' true);                  };                  this.BeginAnimation(FrameworkElement.OpacityProperty' pAnimation' HandoffBehavior.SnapshotAndReplace);                            })' null);
Magic Number,WiiTUIO,OverlayNotice,C:\repos\simphax_Touchmote\WiiTUIO\OverlayNotice.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.noticeBorder = ((System.Windows.Controls.Border)(target));                            #line 8 "..\..\OverlayNotice.xaml"              this.noticeBorder.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.noticeBorder_MouseUp);                            #line default              #line hidden              return;              case 2:              this.noticeMessage = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,updateWindowToScreen,The following statement contains a magic number: this.scrollViewer.MaxHeight = this.Height - 200;
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,ShowNotice,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  OverlayNotice notice = new OverlayNotice(message' wiimoteID' 3000);                  this.noticeStack.Children.Add(notice);              })' null);
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,ShowLayoutOverlay,The following statement contains a magic number: if (this.hidden)              {                  this.keyMapper = keyMapper;                  this.keyMapper.SwitchToDefault();                  this.keyMapper.OnButtonDown += keyMapper_OnButtonDown;                  this.keyMapper.OnButtonUp += keyMapper_OnButtonUp;                  Dispatcher.BeginInvoke(new Action(delegate()                  {                        this.baseGrid.Opacity = 0.0;                      this.baseGrid.Visibility = Visibility.Visible;                      this.layoutChooserOverlay.Visibility = Visibility.Visible;                      this.Activate();                        Color bordercolor = CursorColor.getColor(keyMapper.WiimoteID);                      //bordercolor.ScA = 0.5f;                      bordercolor.R = (byte)(bordercolor.R * 0.8);                      bordercolor.G = (byte)(bordercolor.G * 0.8);                      bordercolor.B = (byte)(bordercolor.B * 0.8);                      this.titleBorder.BorderBrush = new SolidColorBrush(bordercolor);                        this.title.Text = "Choose a layout for Wiimote " + keyMapper.WiimoteID;                      //this.title.Foreground = new SolidColorBrush(bordercolor);                        this.layoutList.Children.Clear();                      foreach (LayoutChooserSetting config in this.keyMapper.GetLayoutList())                      {                          string name = config.Title;                          string filename = config.Keymap;                          LayoutSelectionRow row = new LayoutSelectionRow(name' filename' bordercolor);                          //row.OnClick += row_OnClick;                            if(this.keyMapper.GetFallbackKeymap().Equals(filename))                          {                              row.setSelected(true);                          }                            row.MouseDown += row_MouseDown;                          row.TouchDown += row_TouchDown;                          this.layoutList.Children.Add(row);                      }                        DoubleAnimation animation = UIHelpers.createDoubleAnimation(1.0' 200' false);                      animation.FillBehavior = FillBehavior.HoldEnd;                      animation.Completed += delegate(object sender' EventArgs pEvent)                      {                        };                      this.baseGrid.BeginAnimation(FrameworkElement.OpacityProperty' animation' HandoffBehavior.SnapshotAndReplace);                        this.hidden = false;                  })' null);              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,ShowLayoutOverlay,The following statement contains a magic number: if (this.hidden)              {                  this.keyMapper = keyMapper;                  this.keyMapper.SwitchToDefault();                  this.keyMapper.OnButtonDown += keyMapper_OnButtonDown;                  this.keyMapper.OnButtonUp += keyMapper_OnButtonUp;                  Dispatcher.BeginInvoke(new Action(delegate()                  {                        this.baseGrid.Opacity = 0.0;                      this.baseGrid.Visibility = Visibility.Visible;                      this.layoutChooserOverlay.Visibility = Visibility.Visible;                      this.Activate();                        Color bordercolor = CursorColor.getColor(keyMapper.WiimoteID);                      //bordercolor.ScA = 0.5f;                      bordercolor.R = (byte)(bordercolor.R * 0.8);                      bordercolor.G = (byte)(bordercolor.G * 0.8);                      bordercolor.B = (byte)(bordercolor.B * 0.8);                      this.titleBorder.BorderBrush = new SolidColorBrush(bordercolor);                        this.title.Text = "Choose a layout for Wiimote " + keyMapper.WiimoteID;                      //this.title.Foreground = new SolidColorBrush(bordercolor);                        this.layoutList.Children.Clear();                      foreach (LayoutChooserSetting config in this.keyMapper.GetLayoutList())                      {                          string name = config.Title;                          string filename = config.Keymap;                          LayoutSelectionRow row = new LayoutSelectionRow(name' filename' bordercolor);                          //row.OnClick += row_OnClick;                            if(this.keyMapper.GetFallbackKeymap().Equals(filename))                          {                              row.setSelected(true);                          }                            row.MouseDown += row_MouseDown;                          row.TouchDown += row_TouchDown;                          this.layoutList.Children.Add(row);                      }                        DoubleAnimation animation = UIHelpers.createDoubleAnimation(1.0' 200' false);                      animation.FillBehavior = FillBehavior.HoldEnd;                      animation.Completed += delegate(object sender' EventArgs pEvent)                      {                        };                      this.baseGrid.BeginAnimation(FrameworkElement.OpacityProperty' animation' HandoffBehavior.SnapshotAndReplace);                        this.hidden = false;                  })' null);              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,ShowLayoutOverlay,The following statement contains a magic number: if (this.hidden)              {                  this.keyMapper = keyMapper;                  this.keyMapper.SwitchToDefault();                  this.keyMapper.OnButtonDown += keyMapper_OnButtonDown;                  this.keyMapper.OnButtonUp += keyMapper_OnButtonUp;                  Dispatcher.BeginInvoke(new Action(delegate()                  {                        this.baseGrid.Opacity = 0.0;                      this.baseGrid.Visibility = Visibility.Visible;                      this.layoutChooserOverlay.Visibility = Visibility.Visible;                      this.Activate();                        Color bordercolor = CursorColor.getColor(keyMapper.WiimoteID);                      //bordercolor.ScA = 0.5f;                      bordercolor.R = (byte)(bordercolor.R * 0.8);                      bordercolor.G = (byte)(bordercolor.G * 0.8);                      bordercolor.B = (byte)(bordercolor.B * 0.8);                      this.titleBorder.BorderBrush = new SolidColorBrush(bordercolor);                        this.title.Text = "Choose a layout for Wiimote " + keyMapper.WiimoteID;                      //this.title.Foreground = new SolidColorBrush(bordercolor);                        this.layoutList.Children.Clear();                      foreach (LayoutChooserSetting config in this.keyMapper.GetLayoutList())                      {                          string name = config.Title;                          string filename = config.Keymap;                          LayoutSelectionRow row = new LayoutSelectionRow(name' filename' bordercolor);                          //row.OnClick += row_OnClick;                            if(this.keyMapper.GetFallbackKeymap().Equals(filename))                          {                              row.setSelected(true);                          }                            row.MouseDown += row_MouseDown;                          row.TouchDown += row_TouchDown;                          this.layoutList.Children.Add(row);                      }                        DoubleAnimation animation = UIHelpers.createDoubleAnimation(1.0' 200' false);                      animation.FillBehavior = FillBehavior.HoldEnd;                      animation.Completed += delegate(object sender' EventArgs pEvent)                      {                        };                      this.baseGrid.BeginAnimation(FrameworkElement.OpacityProperty' animation' HandoffBehavior.SnapshotAndReplace);                        this.hidden = false;                  })' null);              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,ShowLayoutOverlay,The following statement contains a magic number: if (this.hidden)              {                  this.keyMapper = keyMapper;                  this.keyMapper.SwitchToDefault();                  this.keyMapper.OnButtonDown += keyMapper_OnButtonDown;                  this.keyMapper.OnButtonUp += keyMapper_OnButtonUp;                  Dispatcher.BeginInvoke(new Action(delegate()                  {                        this.baseGrid.Opacity = 0.0;                      this.baseGrid.Visibility = Visibility.Visible;                      this.layoutChooserOverlay.Visibility = Visibility.Visible;                      this.Activate();                        Color bordercolor = CursorColor.getColor(keyMapper.WiimoteID);                      //bordercolor.ScA = 0.5f;                      bordercolor.R = (byte)(bordercolor.R * 0.8);                      bordercolor.G = (byte)(bordercolor.G * 0.8);                      bordercolor.B = (byte)(bordercolor.B * 0.8);                      this.titleBorder.BorderBrush = new SolidColorBrush(bordercolor);                        this.title.Text = "Choose a layout for Wiimote " + keyMapper.WiimoteID;                      //this.title.Foreground = new SolidColorBrush(bordercolor);                        this.layoutList.Children.Clear();                      foreach (LayoutChooserSetting config in this.keyMapper.GetLayoutList())                      {                          string name = config.Title;                          string filename = config.Keymap;                          LayoutSelectionRow row = new LayoutSelectionRow(name' filename' bordercolor);                          //row.OnClick += row_OnClick;                            if(this.keyMapper.GetFallbackKeymap().Equals(filename))                          {                              row.setSelected(true);                          }                            row.MouseDown += row_MouseDown;                          row.TouchDown += row_TouchDown;                          this.layoutList.Children.Add(row);                      }                        DoubleAnimation animation = UIHelpers.createDoubleAnimation(1.0' 200' false);                      animation.FillBehavior = FillBehavior.HoldEnd;                      animation.Completed += delegate(object sender' EventArgs pEvent)                      {                        };                      this.baseGrid.BeginAnimation(FrameworkElement.OpacityProperty' animation' HandoffBehavior.SnapshotAndReplace);                        this.hidden = false;                  })' null);              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,highlightNext,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  int selectedIndex = -2;                  for (int i = 0; i < this.layoutList.Children.Count; i++)                  {                      LayoutSelectionRow row = this.layoutList.Children[i] as LayoutSelectionRow;                      if (row.isSelected())                      {                          selectedIndex = i;                          row.setSelected(false);                      }                      if (i == selectedIndex + 1)                      {                          row.setSelected(true);                      }                  }                  if (selectedIndex == this.layoutList.Children.Count-1)                  {                      LayoutSelectionRow row = this.layoutList.Children[0] as LayoutSelectionRow;                      row.setSelected(true);                  }                  else if (selectedIndex == -2)//If no row was found selected                  {                      LayoutSelectionRow row = this.layoutList.Children[0] as LayoutSelectionRow;                      row.setSelected(true);                  }              }));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,highlightNext,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  int selectedIndex = -2;                  for (int i = 0; i < this.layoutList.Children.Count; i++)                  {                      LayoutSelectionRow row = this.layoutList.Children[i] as LayoutSelectionRow;                      if (row.isSelected())                      {                          selectedIndex = i;                          row.setSelected(false);                      }                      if (i == selectedIndex + 1)                      {                          row.setSelected(true);                      }                  }                  if (selectedIndex == this.layoutList.Children.Count-1)                  {                      LayoutSelectionRow row = this.layoutList.Children[0] as LayoutSelectionRow;                      row.setSelected(true);                  }                  else if (selectedIndex == -2)//If no row was found selected                  {                      LayoutSelectionRow row = this.layoutList.Children[0] as LayoutSelectionRow;                      row.setSelected(true);                  }              }));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,highlightPrev,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  int selectedIndex = -2;                  for (int i = this.layoutList.Children.Count - 1; i >= 0; i--)                  {                      LayoutSelectionRow row = this.layoutList.Children[i] as LayoutSelectionRow;                      if (row.isSelected())                      {                          selectedIndex = i;                          row.setSelected(false);                      }                      if (i == selectedIndex - 1)                      {                          row.setSelected(true);                      }                  }                  if (selectedIndex == 0)                  {                      LayoutSelectionRow row = this.layoutList.Children[this.layoutList.Children.Count - 1] as LayoutSelectionRow;                      row.setSelected(true);                  }                  else if (selectedIndex == -2)//If no row was found selected                  {                      LayoutSelectionRow row = this.layoutList.Children[this.layoutList.Children.Count - 1] as LayoutSelectionRow;                      row.setSelected(true);                  }              }));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,highlightPrev,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  int selectedIndex = -2;                  for (int i = this.layoutList.Children.Count - 1; i >= 0; i--)                  {                      LayoutSelectionRow row = this.layoutList.Children[i] as LayoutSelectionRow;                      if (row.isSelected())                      {                          selectedIndex = i;                          row.setSelected(false);                      }                      if (i == selectedIndex - 1)                      {                          row.setSelected(true);                      }                  }                  if (selectedIndex == 0)                  {                      LayoutSelectionRow row = this.layoutList.Children[this.layoutList.Children.Count - 1] as LayoutSelectionRow;                      row.setSelected(true);                  }                  else if (selectedIndex == -2)//If no row was found selected                  {                      LayoutSelectionRow row = this.layoutList.Children[this.layoutList.Children.Count - 1] as LayoutSelectionRow;                      row.setSelected(true);                  }              }));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,HideOverlay,The following statement contains a magic number: if (!this.hidden)              {                  this.hidden = true;                  this.keyMapper.OnButtonDown -= keyMapper_OnButtonDown;                  this.keyMapper.OnButtonUp -= keyMapper_OnButtonUp;                  this.keyMapper.SwitchToFallback();                  Dispatcher.BeginInvoke(new Action(delegate()                  {                      DoubleAnimation animation = UIHelpers.createDoubleAnimation(0.0' 200' false);                      animation.FillBehavior = FillBehavior.HoldEnd;                      animation.Completed += delegate(object sender' EventArgs pEvent)                      {                          this.baseGrid.Visibility = Visibility.Hidden;                      };                      this.baseGrid.BeginAnimation(FrameworkElement.OpacityProperty' animation' HandoffBehavior.SnapshotAndReplace);                  })' null);              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Border_MouseLeave,The following statement contains a magic number: border.BorderBrush = new SolidColorBrush(Color.FromRgb(35'35'35));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Border_MouseLeave,The following statement contains a magic number: border.BorderBrush = new SolidColorBrush(Color.FromRgb(35'35'35));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Border_MouseLeave,The following statement contains a magic number: border.BorderBrush = new SolidColorBrush(Color.FromRgb(35'35'35));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Border_TouchLeave,The following statement contains a magic number: border.BorderBrush = new SolidColorBrush(Color.FromRgb(35' 35' 35));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Border_TouchLeave,The following statement contains a magic number: border.BorderBrush = new SolidColorBrush(Color.FromRgb(35' 35' 35));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Border_TouchLeave,The following statement contains a magic number: border.BorderBrush = new SolidColorBrush(Color.FromRgb(35' 35' 35));
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Magic Number,WiiTUIO,SystemProcessMonitor,C:\repos\simphax_Touchmote\WiiTUIO\SystemProcessMonitor.cs,SystemProcessMonitor,The following statement contains a magic number: pollingTimer.Interval = 500;
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,animateExpand,The following statement contains a magic number: if (elem.ActualHeight < 20)              {                  elem.Height = double.NaN; //auto height                  elem.Visibility = Visibility.Visible;                  elem.Measure(new Size(2000'2000));                  double height = (elem.DesiredSize.Height > 0) ? elem.DesiredSize.Height : elem.ActualHeight;                  DoubleAnimation pAnimation = createDoubleAnimation(height' 1000' false);                  elem.Height = 0;                  elem.Visibility = Visibility.Visible;                  pAnimation.FillBehavior = FillBehavior.Stop;                  pAnimation.Completed += delegate(object sender' EventArgs pEvent)                  {                      elem.Height = Double.NaN;                      //elem.BeginAnimation(FrameworkElement.' null);                  };                  //pAnimation.Freeze();                  elem.BeginAnimation(FrameworkElement.HeightProperty' pAnimation' HandoffBehavior.SnapshotAndReplace);              }
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,animateExpand,The following statement contains a magic number: if (elem.ActualHeight < 20)              {                  elem.Height = double.NaN; //auto height                  elem.Visibility = Visibility.Visible;                  elem.Measure(new Size(2000'2000));                  double height = (elem.DesiredSize.Height > 0) ? elem.DesiredSize.Height : elem.ActualHeight;                  DoubleAnimation pAnimation = createDoubleAnimation(height' 1000' false);                  elem.Height = 0;                  elem.Visibility = Visibility.Visible;                  pAnimation.FillBehavior = FillBehavior.Stop;                  pAnimation.Completed += delegate(object sender' EventArgs pEvent)                  {                      elem.Height = Double.NaN;                      //elem.BeginAnimation(FrameworkElement.' null);                  };                  //pAnimation.Freeze();                  elem.BeginAnimation(FrameworkElement.HeightProperty' pAnimation' HandoffBehavior.SnapshotAndReplace);              }
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,animateExpand,The following statement contains a magic number: if (elem.ActualHeight < 20)              {                  elem.Height = double.NaN; //auto height                  elem.Visibility = Visibility.Visible;                  elem.Measure(new Size(2000'2000));                  double height = (elem.DesiredSize.Height > 0) ? elem.DesiredSize.Height : elem.ActualHeight;                  DoubleAnimation pAnimation = createDoubleAnimation(height' 1000' false);                  elem.Height = 0;                  elem.Visibility = Visibility.Visible;                  pAnimation.FillBehavior = FillBehavior.Stop;                  pAnimation.Completed += delegate(object sender' EventArgs pEvent)                  {                      elem.Height = Double.NaN;                      //elem.BeginAnimation(FrameworkElement.' null);                  };                  //pAnimation.Freeze();                  elem.BeginAnimation(FrameworkElement.HeightProperty' pAnimation' HandoffBehavior.SnapshotAndReplace);              }
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,animateExpand,The following statement contains a magic number: if (elem.ActualHeight < 20)              {                  elem.Height = double.NaN; //auto height                  elem.Visibility = Visibility.Visible;                  elem.Measure(new Size(2000'2000));                  double height = (elem.DesiredSize.Height > 0) ? elem.DesiredSize.Height : elem.ActualHeight;                  DoubleAnimation pAnimation = createDoubleAnimation(height' 1000' false);                  elem.Height = 0;                  elem.Visibility = Visibility.Visible;                  pAnimation.FillBehavior = FillBehavior.Stop;                  pAnimation.Completed += delegate(object sender' EventArgs pEvent)                  {                      elem.Height = Double.NaN;                      //elem.BeginAnimation(FrameworkElement.' null);                  };                  //pAnimation.Freeze();                  elem.BeginAnimation(FrameworkElement.HeightProperty' pAnimation' HandoffBehavior.SnapshotAndReplace);              }
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,animateCollapse,The following statement contains a magic number: if (elem.DesiredSize.Height > 0)              {                  elem.Height = elem.DesiredSize.Height;                  DoubleAnimation pAnimation = createDoubleAnimation(0' 1000' false);                  pAnimation.FillBehavior = FillBehavior.Stop;                  pAnimation.Completed += delegate(object sender' EventArgs pEvent)                  {                      //elem.BeginAnimation(FrameworkElement.HeightProperty' null);                      if (remove && elem.Parent is Panel)                      {                          ((Panel)elem.Parent).Children.Remove(elem);                      }                      else                      {                          elem.Visibility = Visibility.Collapsed;                          elem.Height = Double.NaN;                      }                  };                  //pAnimation.Freeze();                  elem.BeginAnimation(FrameworkElement.HeightProperty' pAnimation' HandoffBehavior.SnapshotAndReplace);              }
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,createDoubleAnimation,The following statement contains a magic number: DoubleAnimation pAction = new DoubleAnimation(fNew' new Duration(TimeSpan.FromMilliseconds(fTime)))              {                  // Specify settings.                  AccelerationRatio = 0.1'                  DecelerationRatio = 0.9'                  FillBehavior = FillBehavior.HoldEnd              };
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,createDoubleAnimation,The following statement contains a magic number: DoubleAnimation pAction = new DoubleAnimation(fNew' new Duration(TimeSpan.FromMilliseconds(fTime)))              {                  // Specify settings.                  AccelerationRatio = 0.1'                  DecelerationRatio = 0.9'                  FillBehavior = FillBehavior.HoldEnd              };
Magic Number,WiiTUIO,UIHelpers,C:\repos\simphax_Touchmote\WiiTUIO\UIHelpers.cs,TopmostFix,The following statement contains a magic number: IntPtr HWND_NOTOPMOST = new IntPtr(-2);
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,updateStatus,The following statement contains a magic number: if (this.powersave != status.InPowerSave)              {                  this.powersave = status.InPowerSave;                  if (status.InPowerSave)                  {                      this.lbStatus.Foreground = Brushes.White;                      this.lbStatus.Content = "sleepmode";                  }                  else                  {                      this.lbStatus.Foreground = new SolidColorBrush(Color.FromRgb(91'255'0));                      this.lbStatus.Content = "connected";                  }              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,updateStatus,The following statement contains a magic number: if (this.powersave != status.InPowerSave)              {                  this.powersave = status.InPowerSave;                  if (status.InPowerSave)                  {                      this.lbStatus.Foreground = Brushes.White;                      this.lbStatus.Content = "sleepmode";                  }                  else                  {                      this.lbStatus.Foreground = new SolidColorBrush(Color.FromRgb(91'255'0));                      this.lbStatus.Content = "connected";                  }              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: Brush light = percentage < 20 ? Brushes.Red : Brushes.White;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: Brush dark = new SolidColorBrush(Color.FromRgb(64' 64' 64));
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: Brush dark = new SolidColorBrush(Color.FromRgb(64' 64' 64));
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: Brush dark = new SolidColorBrush(Color.FromRgb(64' 64' 64));
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: this.battery1.Fill = percentage > 10 ? light : dark;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: this.battery2.Fill = percentage > 20 ? light : dark;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: this.battery3.Fill = percentage > 30 ? light : dark;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: this.battery4.Fill = percentage > 40 ? light : dark;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: this.battery5.Fill = percentage > 50 ? light : dark;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,setBattery,The following statement contains a magic number: this.battery6.Fill = percentage > 70 ? light : dark;
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Magic Number,WiiTUIO,App,C:\repos\simphax_Touchmote\WiiTUIO\App.xaml.cs,OnStartup,The following statement contains a magic number: if (Process.GetProcessesByName(thisProc.ProcessName).Length > 1)              {                  MessageBox.Show("Touchmote is already running. Look for it in the taskbar.");                  Application.Current.Shutdown(220);                  return;              }
Magic Number,WiiTUIO,App,C:\repos\simphax_Touchmote\WiiTUIO\App.xaml.cs,appWillExit,The following statement contains a magic number: if (e.ApplicationExitCode != 220)              {                  WiiTUIO.Properties.Settings.Default.Save();                  //TB.Dispose();                  SystemProcessMonitor.Default.Dispose();              }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following statement contains a magic number: foreach (WiiContact contact in e.Contacts)              {                  Color color = Color.Blue;                  switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }                    Brush brush = new SolidBrush(color);                  graphic.DrawEllipse(Pens.Black' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                  graphic.FillEllipse(brush' (float)contact.Position.X - 10' (float)contact.Position.Y - 10' 20' 20);                }
Magic Number,WiiTUIO.Output,TUIOSettings,C:\repos\simphax_Touchmote\WiiTUIO\Output\Settings\TUIOSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing_1);                            #line default              #line hidden                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).GotFocus += new System.Windows.RoutedEventHandler(this.Window_GotFocus_1);                            #line default              #line hidden              return;              case 2:              this.tbIP = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this.tbPort = ((System.Windows.Controls.TextBox)(target));              return;              case 4:                            #line 11 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.Button_Click_1);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO.Output,TUIOSettings,C:\repos\simphax_Touchmote\WiiTUIO\Output\Settings\TUIOSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing_1);                            #line default              #line hidden                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).GotFocus += new System.Windows.RoutedEventHandler(this.Window_GotFocus_1);                            #line default              #line hidden              return;              case 2:              this.tbIP = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this.tbPort = ((System.Windows.Controls.TextBox)(target));              return;              case 4:                            #line 11 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.Button_Click_1);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO.Output,TUIOSettings,C:\repos\simphax_Touchmote\WiiTUIO\Output\Settings\TUIOSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing_1);                            #line default              #line hidden                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).GotFocus += new System.Windows.RoutedEventHandler(this.Window_GotFocus_1);                            #line default              #line hidden              return;              case 2:              this.tbIP = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this.tbPort = ((System.Windows.Controls.TextBox)(target));              return;              case 4:                            #line 11 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.Button_Click_1);                            #line default              #line hidden              return;              }
Magic Number,WiiTUIO.Output,TouchInjectProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TouchInjectProviderHandler.cs,TouchInjectProviderHandler,The following statement contains a magic number: Version win8version = new Version(6' 2' 9200' 0);
Magic Number,WiiTUIO.Output,TouchInjectProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TouchInjectProviderHandler.cs,TouchInjectProviderHandler,The following statement contains a magic number: Version win8version = new Version(6' 2' 9200' 0);
Magic Number,WiiTUIO.Output,TouchInjectProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TouchInjectProviderHandler.cs,TouchInjectProviderHandler,The following statement contains a magic number: Version win8version = new Version(6' 2' 9200' 0);
Magic Number,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,HasDriver,The following statement contains a magic number: foreach (HidDevice device in devices)              {                  if (device.DevicePath.Substring(0'15) == "\\\\?\\hid#vmultia")                  {                      hasDriver = true;                  }              }
Magic Number,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,start_service,The following statement contains a magic number: if (sc.Status == ServiceControllerStatus.Stopped)              {                  // Start the service if the current status is stopped.                  try                  {                      Console.WriteLine("Starting the " + service_name + " service...");                  }                  catch { }                  try                  {                      // Start the service' and wait until its status is "Running".                      sc.Start();                      sc.WaitForStatus(ServiceControllerStatus.Running);                      Thread.Sleep(500);                      // Display the current service status.                      try                      {                          Console.WriteLine("The " + service_name + " service status is now set to {0}."'                                             sc.Status.ToString());                      }                      catch { }                      return "The " + service_name + " service status is now set to " + sc.Status.ToString();                  }                  catch (InvalidOperationException)                  {                      try                      {                          Console.WriteLine("Could not start the " + service_name + " service.");                      }                      catch { }                      return "Could not start the " + service_name + " service.";                  }                  Thread.Sleep(500);              }
Magic Number,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,start_service,The following statement contains a magic number: if (sc.Status == ServiceControllerStatus.Stopped)              {                  // Start the service if the current status is stopped.                  try                  {                      Console.WriteLine("Starting the " + service_name + " service...");                  }                  catch { }                  try                  {                      // Start the service' and wait until its status is "Running".                      sc.Start();                      sc.WaitForStatus(ServiceControllerStatus.Running);                      Thread.Sleep(500);                      // Display the current service status.                      try                      {                          Console.WriteLine("The " + service_name + " service status is now set to {0}."'                                             sc.Status.ToString());                      }                      catch { }                      return "The " + service_name + " service status is now set to " + sc.Status.ToString();                  }                  catch (InvalidOperationException)                  {                      try                      {                          Console.WriteLine("Could not start the " + service_name + " service.");                      }                      catch { }                      return "Could not start the " + service_name + " service.";                  }                  Thread.Sleep(500);              }
Magic Number,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,stop_service,The following statement contains a magic number: if (sc.Status == ServiceControllerStatus.Running)              {                  // Start the service if the current status is stopped.                  try                  {                      Console.WriteLine("Stopping the " + service_name + " service...");                  }                  catch { }                  try                  {                      // Start the service' and wait until its status is "Running".                      sc.Stop();                      sc.WaitForStatus(ServiceControllerStatus.Stopped);                      Thread.Sleep(500);                      // Display the current service status.                      try                      {                          Console.WriteLine("The " + service_name + " service status is now set to {0}."'                                             sc.Status.ToString());                      }                      catch { }                      return "The " + service_name + " service status is now set to " + sc.Status.ToString();                  }                  catch (InvalidOperationException)                  {                      try                      {                          Console.WriteLine("Could not Stop the " + service_name + " service.");                      }                      catch { }                      return "Could not Stop the " + service_name + " service.";                  }              }
Magic Number,WiiTUIO.Output,TUIOVmultiProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\TUIOVmultiProviderHandler.cs,stop_service,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The following statement contains a magic number: if (key.Equals("mouse"))              {                  if (!cursorPos.OutOfReach)                  {                      Point smoothedPos = cursorPositionHelper.getRelativePosition(new Point(cursorPos.X' cursorPos.Y));                      this.inputSimulator.Mouse.MoveMouseToPositionOnVirtualDesktop((65535 * smoothedPos.X)' (65535 * smoothedPos.Y));                      return true;                  }              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The following statement contains a magic number: if (key.Equals("mouse"))              {                  if (!cursorPos.OutOfReach)                  {                      Point smoothedPos = cursorPositionHelper.getRelativePosition(new Point(cursorPos.X' cursorPos.Y));                      this.inputSimulator.Mouse.MoveMouseToPositionOnVirtualDesktop((65535 * smoothedPos.X)' (65535 * smoothedPos.Y));                      return true;                  }              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The following statement contains a magic number: if (key.Equals("fpsmouse"))              {                  Point smoothedPos = cursorPositionHelper.getSmoothedPosition(new Point(cursorPos.RelativeX' cursorPos.RelativeY));                    /*                      * TODO: Consider sensor bar position?                  if (Settings.Default.pointer_sensorBarPos == "top")                  {                      smoothedPos.Y = smoothedPos.Y - Settings.Default.pointer_sensorBarPosCompensation;                  }                  else if (Settings.Default.pointer_sensorBarPos == "bottom")                  {                      smoothedPos.Y = smoothedPos.Y + Settings.Default.pointer_sensorBarPosCompensation;                  }                  */                  double deadzone = Settings.Default.fpsmouse_deadzone; // TODO: Move to settings                  double shiftX = Math.Abs(smoothedPos.X - 0.5) > deadzone ? smoothedPos.X - 0.5 : 0;                  double shiftY = Math.Abs(smoothedPos.Y - 0.5) > deadzone ? smoothedPos.Y - 0.5 : 0;                    this.inputSimulator.Mouse.MoveMouseBy((int)(Settings.Default.fpsmouse_speed * shiftX)' (int)(Settings.Default.fpsmouse_speed * shiftY));                    return true;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The following statement contains a magic number: if (key.Equals("fpsmouse"))              {                  Point smoothedPos = cursorPositionHelper.getSmoothedPosition(new Point(cursorPos.RelativeX' cursorPos.RelativeY));                    /*                      * TODO: Consider sensor bar position?                  if (Settings.Default.pointer_sensorBarPos == "top")                  {                      smoothedPos.Y = smoothedPos.Y - Settings.Default.pointer_sensorBarPosCompensation;                  }                  else if (Settings.Default.pointer_sensorBarPos == "bottom")                  {                      smoothedPos.Y = smoothedPos.Y + Settings.Default.pointer_sensorBarPosCompensation;                  }                  */                  double deadzone = Settings.Default.fpsmouse_deadzone; // TODO: Move to settings                  double shiftX = Math.Abs(smoothedPos.X - 0.5) > deadzone ? smoothedPos.X - 0.5 : 0;                  double shiftY = Math.Abs(smoothedPos.Y - 0.5) > deadzone ? smoothedPos.Y - 0.5 : 0;                    this.inputSimulator.Mouse.MoveMouseBy((int)(Settings.Default.fpsmouse_speed * shiftX)' (int)(Settings.Default.fpsmouse_speed * shiftY));                    return true;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The following statement contains a magic number: if (key.Equals("fpsmouse"))              {                  Point smoothedPos = cursorPositionHelper.getSmoothedPosition(new Point(cursorPos.RelativeX' cursorPos.RelativeY));                    /*                      * TODO: Consider sensor bar position?                  if (Settings.Default.pointer_sensorBarPos == "top")                  {                      smoothedPos.Y = smoothedPos.Y - Settings.Default.pointer_sensorBarPosCompensation;                  }                  else if (Settings.Default.pointer_sensorBarPos == "bottom")                  {                      smoothedPos.Y = smoothedPos.Y + Settings.Default.pointer_sensorBarPosCompensation;                  }                  */                  double deadzone = Settings.Default.fpsmouse_deadzone; // TODO: Move to settings                  double shiftX = Math.Abs(smoothedPos.X - 0.5) > deadzone ? smoothedPos.X - 0.5 : 0;                  double shiftY = Math.Abs(smoothedPos.Y - 0.5) > deadzone ? smoothedPos.Y - 0.5 : 0;                    this.inputSimulator.Mouse.MoveMouseBy((int)(Settings.Default.fpsmouse_speed * shiftX)' (int)(Settings.Default.fpsmouse_speed * shiftY));                    return true;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setPosition,The following statement contains a magic number: if (key.Equals("fpsmouse"))              {                  Point smoothedPos = cursorPositionHelper.getSmoothedPosition(new Point(cursorPos.RelativeX' cursorPos.RelativeY));                    /*                      * TODO: Consider sensor bar position?                  if (Settings.Default.pointer_sensorBarPos == "top")                  {                      smoothedPos.Y = smoothedPos.Y - Settings.Default.pointer_sensorBarPosCompensation;                  }                  else if (Settings.Default.pointer_sensorBarPos == "bottom")                  {                      smoothedPos.Y = smoothedPos.Y + Settings.Default.pointer_sensorBarPosCompensation;                  }                  */                  double deadzone = Settings.Default.fpsmouse_deadzone; // TODO: Move to settings                  double shiftX = Math.Abs(smoothedPos.X - 0.5) > deadzone ? smoothedPos.X - 0.5 : 0;                  double shiftY = Math.Abs(smoothedPos.Y - 0.5) > deadzone ? smoothedPos.Y - 0.5 : 0;                    this.inputSimulator.Mouse.MoveMouseBy((int)(Settings.Default.fpsmouse_speed * shiftX)' (int)(Settings.Default.fpsmouse_speed * shiftY));                    return true;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers,MouseHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\MouseHandler.cs,setValue,The following statement contains a magic number: switch (key)              {                  case "mousey+":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(-30 * value + 0.5));                      break;                  case "mousey-":                      this.inputSimulator.Mouse.MoveMouseBy(0' (int)(30 * value + 0.5));                      break;                  case "mousex+":                      this.inputSimulator.Mouse.MoveMouseBy((int)(30 * value + 0.5)' 0);                      break;                  case "mousex-":                      this.inputSimulator.Mouse.MoveMouseBy((int)(-30 * value + 0.5)' 0);                      break;                  default:                      return false;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,getColor,The following statement contains a magic number: switch (id)              {                  case 1:                      return Color.FromRgb(128'255'0);                  case 2:                      return Color.FromRgb(197' 0' 255);                  case 3:                      return Color.FromRgb(0' 220' 255);                  case 4:                      return Color.FromRgb(255' 255' 0);                  default:                      return randomColor();              }
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,randomColor,The following statement contains a magic number: byte red = (byte)rand.Next(255);
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,randomColor,The following statement contains a magic number: byte green = (byte)rand.Next(255);
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,randomColor,The following statement contains a magic number: byte blue = (byte)rand.Next(255);
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,randomColor,The following statement contains a magic number: int kill = rand.Next(2);
Magic Number,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,randomColor,The following statement contains a magic number: switch (kill)              {                  case 0:                      red = 0;                      break;                  case 1:                      green = 0;                      break;                  case 2:                      blue = 0;                      break;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,D3DCursorWindow,The following statement contains a magic number: cursors = new List<D3DCursor>(2);
Magic Number,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,AddCursor,The following statement contains a magic number: AddD3DCursor(cursor.ID' (uint)((((uint)cursor.Color.R) << 16) | (((uint)cursor.Color.G) << 8) | (uint)cursor.Color.B));
Magic Number,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,AddCursor,The following statement contains a magic number: AddD3DCursor(cursor.ID' (uint)((((uint)cursor.Color.R) << 16) | (((uint)cursor.Color.G) << 8) | (uint)cursor.Color.B));
Magic Number,WiiTUIO.Output.Handlers.Touch,D3DCursorWindow,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\D3DCursorWindow.cs,RefreshCursors,The following statement contains a magic number: if (cursors.Count > 0 && anyCursorIsVisible)              {                  stopRendering = false;              }              else              {                  if (!stopRendering)                  {                      stopRendering = true;                      someLastFrames = 20;                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,TouchHandler,The following statement contains a magic number: ulong touchStartID = (ulong)(id - 1) * 4 + 1;
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,connect,The following statement contains a magic number: if (this.useCustomCursor)              {                  Color myColor = CursorColor.getColor((int)this.id);                  this.masterCursor = new D3DCursor(((int)this.id - 1) * 2' myColor);                  this.slaveCursor = new D3DCursor(((int)this.id - 1) * 2 + 1' myColor);                    masterCursor.Hide();                  slaveCursor.Hide();                    D3DCursorWindow.Current.AddCursor(masterCursor);                  D3DCursorWindow.Current.AddCursor(slaveCursor);              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,connect,The following statement contains a magic number: if (this.useCustomCursor)              {                  Color myColor = CursorColor.getColor((int)this.id);                  this.masterCursor = new D3DCursor(((int)this.id - 1) * 2' myColor);                  this.slaveCursor = new D3DCursor(((int)this.id - 1) * 2 + 1' myColor);                    masterCursor.Hide();                  slaveCursor.Hide();                    D3DCursorWindow.Current.AddCursor(masterCursor);                  D3DCursorWindow.Current.AddCursor(slaveCursor);              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,normalStickCursor,The following statement contains a magic number: int step = (int)Math.Round(30 * value);
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: value = value * 1.4;
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,TouchHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\TouchHandler.cs,alternativeStickCursor,The following statement contains a magic number: if (key.ToLower().Equals("touchx-"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) - value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x < 0 ? 0 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchx+"))              {                  int x = (int)((this.duoTouch.screenBounds.Width / 2) + value * (this.duoTouch.screenBounds.Width / 2) + 0.5);                  x = x > this.duoTouch.screenBounds.Width - 1 ? this.duoTouch.screenBounds.Width - 1 : x;                  positionToPush = new CursorPos(x' fromPos.Y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy-"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) + value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y > this.duoTouch.screenBounds.Height - 1 ? this.duoTouch.screenBounds.Height - 1 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }              else if (key.ToLower().Equals("touchy+"))              {                  int y = (int)((this.duoTouch.screenBounds.Height / 2) - value * (this.duoTouch.screenBounds.Height / 2) + 0.5);                  y = y < 0 ? 0 : y;                  positionToPush = new CursorPos(fromPos.X' y'0'0' 0);                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if(masterPosition != null)              {                  ContactType contactType;                    if (!this.masterReleased)                  {                      if (this.masterHovering)                      {                          contactType = ContactType.Start;                          this.masterHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                                                                    if (this.isFirstMasterContact)                      {                          this.firstMasterContact = this.masterPosition;                      }                      else                       {                          if (this.masterHoldPosition)                          {                              if (Math.Abs(this.firstMasterContact.X - this.masterPosition.X) < TouchHoldThreshold && Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y) < TouchHoldThreshold)                              {                                  /*Console.WriteLine("DiffX: " + Math.Abs(this.firstMasterContact.X - this.masterPosition.X) + " DiffY: " + Math.Abs(this.firstMasterContact.Y - this.masterPosition.Y));*/                                  this.masterPosition = this.firstMasterContact;                                  this.masterHoldPosition = true;                              }                              else                              {                                  this.masterHoldPosition = false;                              }                          }                            //Helps to perform "edge swipe" guestures                          if (this.firstMasterContact.X < EdgeHelperMargins && this.masterPosition.X < EdgeHelperRelease) //Left                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.X > (this.screenBounds.Width - EdgeHelperMargins) && this.masterPosition.X > (this.screenBounds.Width - EdgeHelperRelease)) //Right                          {                              this.masterPosition.Y = (this.firstMasterContact.Y + this.firstMasterContact.Y + this.masterPosition.Y) / 3;                          }                          if (this.firstMasterContact.Y < EdgeHelperMargins && this.masterPosition.Y < EdgeHelperRelease) //Top                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                          if (this.firstMasterContact.Y > (this.screenBounds.Height - EdgeHelperMargins) && this.masterPosition.Y > (this.screenBounds.Height - EdgeHelperRelease)) //Bottom                          {                              this.masterPosition.X = (this.firstMasterContact.X + this.firstMasterContact.X + this.masterPosition.X) / 3;                          }                      }                        smoothingBuffer.addValue(new System.Windows.Vector(masterPosition.X' masterPosition.Y));                      System.Windows.Vector smoothedVec = smoothingBuffer.getSmoothedValue();                      this.masterPosition.X = smoothedVec.X;                      this.masterPosition.Y = smoothedVec.Y;                        this.isFirstMasterContact = false;                                        }                  else //Released = hovering                  {                      if (!this.masterHovering) //End the touch first                      {                          if (this.hoverDisabled)                          {                              contactType = ContactType.End;                          }                          else                          {                              contactType = ContactType.EndToHover;                          }                          this.masterPosition = lastMasterContact.Position;                          this.masterHovering = true;                      }                      else                      {                          contactType = ContactType.Hover;                          smoothingBuffer.addValue(new Vector(masterPosition.X' masterPosition.Y));                          Vector smoothedVec = smoothingBuffer.getSmoothedValue();                          this.masterPosition.X = smoothedVec.X;                          this.masterPosition.Y = smoothedVec.Y;                      }                        this.isFirstMasterContact = true;                      this.masterHoldPosition = true;                  }                    if (!(contactType == ContactType.Hover && this.hoverDisabled))                  {                      if (this.stepIDs && contactType == ContactType.EndToHover) //If we release slave touch before we release master touch we want to make sure Windows treats master as the main touch point again                      {                          this.lastMasterContact = new WiiContact(this.masterID' ContactType.End' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width'this.screenBounds.Height));                          this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                          this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                          this.stepIDs = false;                      }                      else                      {                          this.lastMasterContact = new WiiContact(this.masterID' contactType' this.masterPosition' this.masterPriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      }                      newFrame.Enqueue(this.lastMasterContact);                  }              }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if (slavePosition != null)              {                  ContactType contactType;                    if (!this.slaveReleased)                  {                      if (this.slaveHovering)                      {                          contactType = ContactType.Start;                          this.slaveHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                        if (!this.masterReleased)                      {                          if (!this.usingMidpoint)                          {                              this.midpoint = calculateMidpoint(this.masterPosition' this.slavePosition);                              this.usingMidpoint = true;                          }                            this.slavePosition = reflectThroughMidpoint(this.masterPosition' this.midpoint);                            if (this.slavePosition.X < 0)                          {                              this.slavePosition.X = 0;                          }                          if (this.slavePosition.Y < 0)                          {                              this.slavePosition.Y = 0;                          }                            if (this.slavePosition.X > this.screenBounds.Width)                          {                              this.slavePosition.X = this.screenBounds.Width - 1;                          }                          if (this.slavePosition.Y > this.screenBounds.Height)                          {                              this.slavePosition.Y = this.screenBounds.Height - 1;                          }                      }                      else                      {                          this.usingMidpoint = false;                      }                        this.slaveEnded = false;                      this.stepIDs = false;                  }                  else                  {                      if (!this.slaveHovering)                      {                          contactType = ContactType.EndToHover;                          this.slavePosition = lastSlaveContact.Position;                          this.slaveHovering = true;                      }                      else                      {                          contactType = ContactType.EndFromHover;                      }                  }                    if (!this.slaveEnded)                  {                      this.lastSlaveContact = new WiiContact(this.slaveID' contactType' this.slavePosition'this.slavePriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      newFrame.Enqueue(this.lastSlaveContact);                        if (contactType == ContactType.EndFromHover)                      {                          this.slaveEnded = true;                          if (!this.masterReleased) //If we release slave before master                          {                              this.stepIDs = true;                          }                          else                          {                              this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                              this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                              this.stepIDs = false;                          }                      }                  }                }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if (slavePosition != null)              {                  ContactType contactType;                    if (!this.slaveReleased)                  {                      if (this.slaveHovering)                      {                          contactType = ContactType.Start;                          this.slaveHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                        if (!this.masterReleased)                      {                          if (!this.usingMidpoint)                          {                              this.midpoint = calculateMidpoint(this.masterPosition' this.slavePosition);                              this.usingMidpoint = true;                          }                            this.slavePosition = reflectThroughMidpoint(this.masterPosition' this.midpoint);                            if (this.slavePosition.X < 0)                          {                              this.slavePosition.X = 0;                          }                          if (this.slavePosition.Y < 0)                          {                              this.slavePosition.Y = 0;                          }                            if (this.slavePosition.X > this.screenBounds.Width)                          {                              this.slavePosition.X = this.screenBounds.Width - 1;                          }                          if (this.slavePosition.Y > this.screenBounds.Height)                          {                              this.slavePosition.Y = this.screenBounds.Height - 1;                          }                      }                      else                      {                          this.usingMidpoint = false;                      }                        this.slaveEnded = false;                      this.stepIDs = false;                  }                  else                  {                      if (!this.slaveHovering)                      {                          contactType = ContactType.EndToHover;                          this.slavePosition = lastSlaveContact.Position;                          this.slaveHovering = true;                      }                      else                      {                          contactType = ContactType.EndFromHover;                      }                  }                    if (!this.slaveEnded)                  {                      this.lastSlaveContact = new WiiContact(this.slaveID' contactType' this.slavePosition'this.slavePriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      newFrame.Enqueue(this.lastSlaveContact);                        if (contactType == ContactType.EndFromHover)                      {                          this.slaveEnded = true;                          if (!this.masterReleased) //If we release slave before master                          {                              this.stepIDs = true;                          }                          else                          {                              this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                              this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                              this.stepIDs = false;                          }                      }                  }                }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if (slavePosition != null)              {                  ContactType contactType;                    if (!this.slaveReleased)                  {                      if (this.slaveHovering)                      {                          contactType = ContactType.Start;                          this.slaveHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                        if (!this.masterReleased)                      {                          if (!this.usingMidpoint)                          {                              this.midpoint = calculateMidpoint(this.masterPosition' this.slavePosition);                              this.usingMidpoint = true;                          }                            this.slavePosition = reflectThroughMidpoint(this.masterPosition' this.midpoint);                            if (this.slavePosition.X < 0)                          {                              this.slavePosition.X = 0;                          }                          if (this.slavePosition.Y < 0)                          {                              this.slavePosition.Y = 0;                          }                            if (this.slavePosition.X > this.screenBounds.Width)                          {                              this.slavePosition.X = this.screenBounds.Width - 1;                          }                          if (this.slavePosition.Y > this.screenBounds.Height)                          {                              this.slavePosition.Y = this.screenBounds.Height - 1;                          }                      }                      else                      {                          this.usingMidpoint = false;                      }                        this.slaveEnded = false;                      this.stepIDs = false;                  }                  else                  {                      if (!this.slaveHovering)                      {                          contactType = ContactType.EndToHover;                          this.slavePosition = lastSlaveContact.Position;                          this.slaveHovering = true;                      }                      else                      {                          contactType = ContactType.EndFromHover;                      }                  }                    if (!this.slaveEnded)                  {                      this.lastSlaveContact = new WiiContact(this.slaveID' contactType' this.slavePosition'this.slavePriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      newFrame.Enqueue(this.lastSlaveContact);                        if (contactType == ContactType.EndFromHover)                      {                          this.slaveEnded = true;                          if (!this.masterReleased) //If we release slave before master                          {                              this.stepIDs = true;                          }                          else                          {                              this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                              this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                              this.stepIDs = false;                          }                      }                  }                }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,getFrame,The following statement contains a magic number: if (slavePosition != null)              {                  ContactType contactType;                    if (!this.slaveReleased)                  {                      if (this.slaveHovering)                      {                          contactType = ContactType.Start;                          this.slaveHovering = false;                      }                      else                      {                          contactType = ContactType.Move;                      }                        if (!this.masterReleased)                      {                          if (!this.usingMidpoint)                          {                              this.midpoint = calculateMidpoint(this.masterPosition' this.slavePosition);                              this.usingMidpoint = true;                          }                            this.slavePosition = reflectThroughMidpoint(this.masterPosition' this.midpoint);                            if (this.slavePosition.X < 0)                          {                              this.slavePosition.X = 0;                          }                          if (this.slavePosition.Y < 0)                          {                              this.slavePosition.Y = 0;                          }                            if (this.slavePosition.X > this.screenBounds.Width)                          {                              this.slavePosition.X = this.screenBounds.Width - 1;                          }                          if (this.slavePosition.Y > this.screenBounds.Height)                          {                              this.slavePosition.Y = this.screenBounds.Height - 1;                          }                      }                      else                      {                          this.usingMidpoint = false;                      }                        this.slaveEnded = false;                      this.stepIDs = false;                  }                  else                  {                      if (!this.slaveHovering)                      {                          contactType = ContactType.EndToHover;                          this.slavePosition = lastSlaveContact.Position;                          this.slaveHovering = true;                      }                      else                      {                          contactType = ContactType.EndFromHover;                      }                  }                    if (!this.slaveEnded)                  {                      this.lastSlaveContact = new WiiContact(this.slaveID' contactType' this.slavePosition'this.slavePriority' new Vector(this.screenBounds.Width' this.screenBounds.Height));                      newFrame.Enqueue(this.lastSlaveContact);                        if (contactType == ContactType.EndFromHover)                      {                          this.slaveEnded = true;                          if (!this.masterReleased) //If we release slave before master                          {                              this.stepIDs = true;                          }                          else                          {                              this.masterID = (this.masterID - this.startID + 2) % 4 + this.startID;                              this.slaveID = (this.slaveID - this.startID + 2) % 4 + this.startID;                              this.stepIDs = false;                          }                      }                  }                }
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,calculateMidpoint,The following statement contains a magic number: return new Point((p1.X + p2.X) / 2' (p1.Y + p2.Y) / 2);
Magic Number,WiiTUIO.Output.Handlers.Touch,DuoTouch,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\DuoTouch.cs,calculateMidpoint,The following statement contains a magic number: return new Point((p1.X + p2.X) / 2' (p1.Y + p2.Y) / 2);
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelX+"' out outConfig))              {                  if (accelState.Values.X > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X);                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * 2 > outConfig.Threshold && !PressedButtons["AccelX+"])                  {                      PressedButtons["AccelX+"] = true;                      this.executeButtonDown("AccelX+");                  }                  else if (accelState.Values.X * 2 < outConfig.Threshold && PressedButtons["AccelX+"])                  {                      PressedButtons["AccelX+"] = false;                      this.executeButtonUp("AccelX+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelX+"' out outConfig))              {                  if (accelState.Values.X > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X);                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * 2 > outConfig.Threshold && !PressedButtons["AccelX+"])                  {                      PressedButtons["AccelX+"] = true;                      this.executeButtonDown("AccelX+");                  }                  else if (accelState.Values.X * 2 < outConfig.Threshold && PressedButtons["AccelX+"])                  {                      PressedButtons["AccelX+"] = false;                      this.executeButtonUp("AccelX+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelX-"' out outConfig))              {                  if (accelState.Values.X < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X * -1);                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * -2 > outConfig.Threshold && !PressedButtons["AccelX-"])                  {                      PressedButtons["AccelX-"] = true;                      this.executeButtonDown("AccelX-");                  }                  else if (accelState.Values.X * -2 < outConfig.Threshold && PressedButtons["AccelX-"])                  {                      PressedButtons["AccelX-"] = false;                      this.executeButtonUp("AccelX-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelX-"' out outConfig))              {                  if (accelState.Values.X < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X * -1);                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * -2 > outConfig.Threshold && !PressedButtons["AccelX-"])                  {                      PressedButtons["AccelX-"] = true;                      this.executeButtonDown("AccelX-");                  }                  else if (accelState.Values.X * -2 < outConfig.Threshold && PressedButtons["AccelX-"])                  {                      PressedButtons["AccelX-"] = false;                      this.executeButtonUp("AccelX-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelY+"' out outConfig))              {                  if (accelState.Values.Y > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * 2 > outConfig.Threshold && !PressedButtons["AccelY+"])                  {                      PressedButtons["AccelY+"] = true;                      this.executeButtonDown("AccelY+");                  }                  else if (accelState.Values.Y * 2 < outConfig.Threshold && PressedButtons["AccelY+"])                  {                      PressedButtons["AccelY+"] = false;                      this.executeButtonUp("AccelY+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelY+"' out outConfig))              {                  if (accelState.Values.Y > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * 2 > outConfig.Threshold && !PressedButtons["AccelY+"])                  {                      PressedButtons["AccelY+"] = true;                      this.executeButtonDown("AccelY+");                  }                  else if (accelState.Values.Y * 2 < outConfig.Threshold && PressedButtons["AccelY+"])                  {                      PressedButtons["AccelY+"] = false;                      this.executeButtonUp("AccelY+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelY-"' out outConfig))              {                  if (accelState.Values.Y < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y * -1);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * -2 > outConfig.Threshold && !PressedButtons["AccelY-"])                  {                      PressedButtons["AccelY-"] = true;                      this.executeButtonDown("AccelY-");                  }                  else if (accelState.Values.Y * -2 < outConfig.Threshold && PressedButtons["AccelY-"])                  {                      PressedButtons["AccelY-"] = false;                      this.executeButtonUp("AccelY-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelY-"' out outConfig))              {                  if (accelState.Values.Y < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y * -1);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * -2 > outConfig.Threshold && !PressedButtons["AccelY-"])                  {                      PressedButtons["AccelY-"] = true;                      this.executeButtonDown("AccelY-");                  }                  else if (accelState.Values.Y * -2 < outConfig.Threshold && PressedButtons["AccelY-"])                  {                      PressedButtons["AccelY-"] = false;                      this.executeButtonUp("AccelY-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelZ+"' out outConfig))              {                  if (accelState.Values.Z > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * 2 > outConfig.Threshold && !PressedButtons["AccelZ+"])                  {                      PressedButtons["AccelZ+"] = true;                      this.executeButtonDown("AccelZ+");                  }                  else if (accelState.Values.Z * 2 < outConfig.Threshold && PressedButtons["AccelZ+"])                  {                      PressedButtons["AccelZ+"] = false;                      this.executeButtonUp("AccelZ+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelZ+"' out outConfig))              {                  if (accelState.Values.Z > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * 2 > outConfig.Threshold && !PressedButtons["AccelZ+"])                  {                      PressedButtons["AccelZ+"] = true;                      this.executeButtonDown("AccelZ+");                  }                  else if (accelState.Values.Z * 2 < outConfig.Threshold && PressedButtons["AccelZ+"])                  {                      PressedButtons["AccelZ+"] = false;                      this.executeButtonUp("AccelZ+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelZ-"' out outConfig))              {                  if (accelState.Values.Z < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z * -1);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * -2 > outConfig.Threshold && !PressedButtons["AccelZ-"])                  {                      PressedButtons["AccelZ-"] = true;                      this.executeButtonDown("AccelZ-");                  }                  else if (accelState.Values.Z * -2 < outConfig.Threshold && PressedButtons["AccelZ-"])                  {                      PressedButtons["AccelZ-"] = false;                      this.executeButtonUp("AccelZ-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateAccelerometer,The following statement contains a magic number: if (this.config.TryGetValue("AccelZ-"' out outConfig))              {                  if (accelState.Values.Z < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z * -1);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * -2 > outConfig.Threshold && !PressedButtons["AccelZ-"])                  {                      PressedButtons["AccelZ-"] = true;                      this.executeButtonDown("AccelZ-");                  }                  else if (accelState.Values.Z * -2 < outConfig.Threshold && PressedButtons["AccelZ-"])                  {                      PressedButtons["AccelZ-"] = false;                      this.executeButtonUp("AccelZ-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickRight"' out outConfig))              {                  if (nunchuk.Joystick.X > 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.X * 2);                  }                  else if (nunchuk.Joystick.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.X * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickRight"])                  {                      PressedButtons["Nunchuk.StickRight"] = true;                      this.executeButtonDown("Nunchuk.StickRight");                  }                  else if (nunchuk.Joystick.X * 2 < outConfig.Threshold && PressedButtons["Nunchuk.StickRight"])                  {                      PressedButtons["Nunchuk.StickRight"] = false;                      this.executeButtonUp("Nunchuk.StickRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickRight"' out outConfig))              {                  if (nunchuk.Joystick.X > 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.X * 2);                  }                  else if (nunchuk.Joystick.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.X * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickRight"])                  {                      PressedButtons["Nunchuk.StickRight"] = true;                      this.executeButtonDown("Nunchuk.StickRight");                  }                  else if (nunchuk.Joystick.X * 2 < outConfig.Threshold && PressedButtons["Nunchuk.StickRight"])                  {                      PressedButtons["Nunchuk.StickRight"] = false;                      this.executeButtonUp("Nunchuk.StickRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickRight"' out outConfig))              {                  if (nunchuk.Joystick.X > 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.X * 2);                  }                  else if (nunchuk.Joystick.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.X * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickRight"])                  {                      PressedButtons["Nunchuk.StickRight"] = true;                      this.executeButtonDown("Nunchuk.StickRight");                  }                  else if (nunchuk.Joystick.X * 2 < outConfig.Threshold && PressedButtons["Nunchuk.StickRight"])                  {                      PressedButtons["Nunchuk.StickRight"] = false;                      this.executeButtonUp("Nunchuk.StickRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickLeft"' out outConfig))              {                  if (nunchuk.Joystick.X < 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.X * -2);                  }                  else if (nunchuk.Joystick.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.X * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickLeft"])                  {                      PressedButtons["Nunchuk.StickLeft"] = true;                      this.executeButtonDown("Nunchuk.StickLeft");                  }                  else if (nunchuk.Joystick.X * -2 < outConfig.Threshold && PressedButtons["Nunchuk.StickLeft"])                  {                      PressedButtons["Nunchuk.StickLeft"] = false;                      this.executeButtonUp("Nunchuk.StickLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickLeft"' out outConfig))              {                  if (nunchuk.Joystick.X < 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.X * -2);                  }                  else if (nunchuk.Joystick.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.X * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickLeft"])                  {                      PressedButtons["Nunchuk.StickLeft"] = true;                      this.executeButtonDown("Nunchuk.StickLeft");                  }                  else if (nunchuk.Joystick.X * -2 < outConfig.Threshold && PressedButtons["Nunchuk.StickLeft"])                  {                      PressedButtons["Nunchuk.StickLeft"] = false;                      this.executeButtonUp("Nunchuk.StickLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickLeft"' out outConfig))              {                  if (nunchuk.Joystick.X < 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.X * -2);                  }                  else if (nunchuk.Joystick.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.X * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickLeft"])                  {                      PressedButtons["Nunchuk.StickLeft"] = true;                      this.executeButtonDown("Nunchuk.StickLeft");                  }                  else if (nunchuk.Joystick.X * -2 < outConfig.Threshold && PressedButtons["Nunchuk.StickLeft"])                  {                      PressedButtons["Nunchuk.StickLeft"] = false;                      this.executeButtonUp("Nunchuk.StickLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickUp"' out outConfig))              {                  if (nunchuk.Joystick.Y > 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.Y * 2);                  }                  else if (nunchuk.Joystick.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.Y * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickUp"])                  {                      PressedButtons["Nunchuk.StickUp"] = true;                      this.executeButtonDown("Nunchuk.StickUp");                  }                  else if (nunchuk.Joystick.Y * 2 < outConfig.Threshold && PressedButtons["Nunchuk.StickUp"])                  {                      PressedButtons["Nunchuk.StickUp"] = false;                      this.executeButtonUp("Nunchuk.StickUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickUp"' out outConfig))              {                  if (nunchuk.Joystick.Y > 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.Y * 2);                  }                  else if (nunchuk.Joystick.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.Y * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickUp"])                  {                      PressedButtons["Nunchuk.StickUp"] = true;                      this.executeButtonDown("Nunchuk.StickUp");                  }                  else if (nunchuk.Joystick.Y * 2 < outConfig.Threshold && PressedButtons["Nunchuk.StickUp"])                  {                      PressedButtons["Nunchuk.StickUp"] = false;                      this.executeButtonUp("Nunchuk.StickUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickUp"' out outConfig))              {                  if (nunchuk.Joystick.Y > 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.Y * 2);                  }                  else if (nunchuk.Joystick.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.Y * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickUp"])                  {                      PressedButtons["Nunchuk.StickUp"] = true;                      this.executeButtonDown("Nunchuk.StickUp");                  }                  else if (nunchuk.Joystick.Y * 2 < outConfig.Threshold && PressedButtons["Nunchuk.StickUp"])                  {                      PressedButtons["Nunchuk.StickUp"] = false;                      this.executeButtonUp("Nunchuk.StickUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickDown"' out outConfig))              {                  if (nunchuk.Joystick.Y < 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.Y * -2);                  }                  else if (nunchuk.Joystick.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.Y * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickDown"])                  {                      PressedButtons["Nunchuk.StickDown"] = true;                      this.executeButtonDown("Nunchuk.StickDown");                  }                  else if (nunchuk.Joystick.Y * -2 < outConfig.Threshold && PressedButtons["Nunchuk.StickDown"])                  {                      PressedButtons["Nunchuk.StickDown"] = false;                      this.executeButtonUp("Nunchuk.StickDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickDown"' out outConfig))              {                  if (nunchuk.Joystick.Y < 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.Y * -2);                  }                  else if (nunchuk.Joystick.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.Y * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickDown"])                  {                      PressedButtons["Nunchuk.StickDown"] = true;                      this.executeButtonDown("Nunchuk.StickDown");                  }                  else if (nunchuk.Joystick.Y * -2 < outConfig.Threshold && PressedButtons["Nunchuk.StickDown"])                  {                      PressedButtons["Nunchuk.StickDown"] = false;                      this.executeButtonUp("Nunchuk.StickDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.StickDown"' out outConfig))              {                  if (nunchuk.Joystick.Y < 0)                  {                      updateStickHandlers(outConfig' nunchuk.Joystick.Y * -2);                  }                  else if (nunchuk.Joystick.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (nunchuk.Joystick.Y * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.StickDown"])                  {                      PressedButtons["Nunchuk.StickDown"] = true;                      this.executeButtonDown("Nunchuk.StickDown");                  }                  else if (nunchuk.Joystick.Y * -2 < outConfig.Threshold && PressedButtons["Nunchuk.StickDown"])                  {                      PressedButtons["Nunchuk.StickDown"] = false;                      this.executeButtonUp("Nunchuk.StickDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelX+"' out outConfig))              {                  if (accelState.Values.X > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X );                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelX+"])                  {                      PressedButtons["Nunchuk.AccelX+"] = true;                      this.executeButtonDown("Nunchuk.AccelX+");                  }                  else if (accelState.Values.X * 2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelX+"])                  {                      PressedButtons["Nunchuk.AccelX+"] = false;                      this.executeButtonUp("Nunchuk.AccelX+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelX+"' out outConfig))              {                  if (accelState.Values.X > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X );                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelX+"])                  {                      PressedButtons["Nunchuk.AccelX+"] = true;                      this.executeButtonDown("Nunchuk.AccelX+");                  }                  else if (accelState.Values.X * 2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelX+"])                  {                      PressedButtons["Nunchuk.AccelX+"] = false;                      this.executeButtonUp("Nunchuk.AccelX+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelX-"' out outConfig))              {                  if (accelState.Values.X < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X * -1);                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelX-"])                  {                      PressedButtons["Nunchuk.AccelX-"] = true;                      this.executeButtonDown("Nunchuk.AccelX-");                  }                  else if (accelState.Values.X * -2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelX-"])                  {                      PressedButtons["Nunchuk.AccelX-"] = false;                      this.executeButtonUp("Nunchuk.AccelX-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelX-"' out outConfig))              {                  if (accelState.Values.X < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.X * -1);                  }                  else if (accelState.Values.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.X * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelX-"])                  {                      PressedButtons["Nunchuk.AccelX-"] = true;                      this.executeButtonDown("Nunchuk.AccelX-");                  }                  else if (accelState.Values.X * -2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelX-"])                  {                      PressedButtons["Nunchuk.AccelX-"] = false;                      this.executeButtonUp("Nunchuk.AccelX-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelY+"' out outConfig))              {                  if (accelState.Values.Y > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelY+"])                  {                      PressedButtons["Nunchuk.AccelY+"] = true;                      this.executeButtonDown("Nunchuk.AccelY+");                  }                  else if (accelState.Values.Y * 2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelY+"])                  {                      PressedButtons["Nunchuk.AccelY+"] = false;                      this.executeButtonUp("Nunchuk.AccelY+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelY+"' out outConfig))              {                  if (accelState.Values.Y > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelY+"])                  {                      PressedButtons["Nunchuk.AccelY+"] = true;                      this.executeButtonDown("Nunchuk.AccelY+");                  }                  else if (accelState.Values.Y * 2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelY+"])                  {                      PressedButtons["Nunchuk.AccelY+"] = false;                      this.executeButtonUp("Nunchuk.AccelY+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelY-"' out outConfig))              {                  if (accelState.Values.Y < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y * -1);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelY-"])                  {                      PressedButtons["Nunchuk.AccelY-"] = true;                      this.executeButtonDown("Nunchuk.AccelY-");                  }                  else if (accelState.Values.Y * -2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelY-"])                  {                      PressedButtons["Nunchuk.AccelY-"] = false;                      this.executeButtonUp("Nunchuk.AccelY-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelY-"' out outConfig))              {                  if (accelState.Values.Y < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Y * -1);                  }                  else if (accelState.Values.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Y * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelY-"])                  {                      PressedButtons["Nunchuk.AccelY-"] = true;                      this.executeButtonDown("Nunchuk.AccelY-");                  }                  else if (accelState.Values.Y * -2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelY-"])                  {                      PressedButtons["Nunchuk.AccelY-"] = false;                      this.executeButtonUp("Nunchuk.AccelY-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelZ+"' out outConfig))              {                  if (accelState.Values.Z > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelZ+"])                  {                      PressedButtons["Nunchuk.AccelZ+"] = true;                      this.executeButtonDown("Nunchuk.AccelZ+");                  }                  else if (accelState.Values.Z * 2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelZ+"])                  {                      PressedButtons["Nunchuk.AccelZ+"] = false;                      this.executeButtonUp("Nunchuk.AccelZ+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelZ+"' out outConfig))              {                  if (accelState.Values.Z > 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * 2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelZ+"])                  {                      PressedButtons["Nunchuk.AccelZ+"] = true;                      this.executeButtonDown("Nunchuk.AccelZ+");                  }                  else if (accelState.Values.Z * 2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelZ+"])                  {                      PressedButtons["Nunchuk.AccelZ+"] = false;                      this.executeButtonUp("Nunchuk.AccelZ+");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelZ-"' out outConfig))              {                  if (accelState.Values.Z < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z * -1);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelZ-"])                  {                      PressedButtons["Nunchuk.AccelZ-"] = true;                      this.executeButtonDown("Nunchuk.AccelZ-");                  }                  else if (accelState.Values.Z * -2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelZ-"])                  {                      PressedButtons["Nunchuk.AccelZ-"] = false;                      this.executeButtonUp("Nunchuk.AccelZ-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateNunchuk,The following statement contains a magic number: if (this.config.TryGetValue("Nunchuk.AccelZ-"' out outConfig))              {                  if (accelState.Values.Z < 0)                  {                      updateStickHandlers(outConfig' accelState.Values.Z * -1);                  }                  else if (accelState.Values.Z == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (accelState.Values.Z * -2 > outConfig.Threshold && !PressedButtons["Nunchuk.AccelZ-"])                  {                      PressedButtons["Nunchuk.AccelZ-"] = true;                      this.executeButtonDown("Nunchuk.AccelZ-");                  }                  else if (accelState.Values.Z * -2 < outConfig.Threshold && PressedButtons["Nunchuk.AccelZ-"])                  {                      PressedButtons["Nunchuk.AccelZ-"] = false;                      this.executeButtonUp("Nunchuk.AccelZ-");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLRight"' out outConfig))              {                  if (classic.JoystickL.X > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.X * 2);                  }                  else if (classic.JoystickL.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.X * 2 > outConfig.Threshold && !PressedButtons["Classic.StickLRight"])                  {                      PressedButtons["Classic.StickLRight"] = true;                      this.executeButtonDown("Classic.StickLRight");                  }                  else if (classic.JoystickL.X * 2 < outConfig.Threshold && PressedButtons["Classic.StickLRight"])                  {                      PressedButtons["Classic.StickLRight"] = false;                      this.executeButtonUp("Classic.StickLRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLRight"' out outConfig))              {                  if (classic.JoystickL.X > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.X * 2);                  }                  else if (classic.JoystickL.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.X * 2 > outConfig.Threshold && !PressedButtons["Classic.StickLRight"])                  {                      PressedButtons["Classic.StickLRight"] = true;                      this.executeButtonDown("Classic.StickLRight");                  }                  else if (classic.JoystickL.X * 2 < outConfig.Threshold && PressedButtons["Classic.StickLRight"])                  {                      PressedButtons["Classic.StickLRight"] = false;                      this.executeButtonUp("Classic.StickLRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLRight"' out outConfig))              {                  if (classic.JoystickL.X > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.X * 2);                  }                  else if (classic.JoystickL.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.X * 2 > outConfig.Threshold && !PressedButtons["Classic.StickLRight"])                  {                      PressedButtons["Classic.StickLRight"] = true;                      this.executeButtonDown("Classic.StickLRight");                  }                  else if (classic.JoystickL.X * 2 < outConfig.Threshold && PressedButtons["Classic.StickLRight"])                  {                      PressedButtons["Classic.StickLRight"] = false;                      this.executeButtonUp("Classic.StickLRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLLeft"' out outConfig))              {                  if (classic.JoystickL.X < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.X * -2);                  }                  else if (classic.JoystickL.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.X * -2 > outConfig.Threshold && !PressedButtons["Classic.StickLLeft"])                  {                      PressedButtons["Classic.StickLLeft"] = true;                      this.executeButtonDown("Classic.StickLLeft");                  }                  else if (classic.JoystickL.X * -2 < outConfig.Threshold && PressedButtons["Classic.StickLLeft"])                  {                      PressedButtons["Classic.StickLLeft"] = false;                      this.executeButtonUp("Classic.StickLLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLLeft"' out outConfig))              {                  if (classic.JoystickL.X < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.X * -2);                  }                  else if (classic.JoystickL.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.X * -2 > outConfig.Threshold && !PressedButtons["Classic.StickLLeft"])                  {                      PressedButtons["Classic.StickLLeft"] = true;                      this.executeButtonDown("Classic.StickLLeft");                  }                  else if (classic.JoystickL.X * -2 < outConfig.Threshold && PressedButtons["Classic.StickLLeft"])                  {                      PressedButtons["Classic.StickLLeft"] = false;                      this.executeButtonUp("Classic.StickLLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLLeft"' out outConfig))              {                  if (classic.JoystickL.X < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.X * -2);                  }                  else if (classic.JoystickL.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.X * -2 > outConfig.Threshold && !PressedButtons["Classic.StickLLeft"])                  {                      PressedButtons["Classic.StickLLeft"] = true;                      this.executeButtonDown("Classic.StickLLeft");                  }                  else if (classic.JoystickL.X * -2 < outConfig.Threshold && PressedButtons["Classic.StickLLeft"])                  {                      PressedButtons["Classic.StickLLeft"] = false;                      this.executeButtonUp("Classic.StickLLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLUp"' out outConfig))              {                  if (classic.JoystickL.Y > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.Y * 2);                  }                  else if (classic.JoystickL.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.Y * 2 > outConfig.Threshold && !PressedButtons["Classic.StickLUp"])                  {                      PressedButtons["Classic.StickLUp"] = true;                      this.executeButtonDown("Classic.StickLUp");                  }                  else if (classic.JoystickL.Y * 2 < outConfig.Threshold && PressedButtons["Classic.StickLUp"])                  {                      PressedButtons["Classic.StickLUp"] = false;                      this.executeButtonUp("Classic.StickLUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLUp"' out outConfig))              {                  if (classic.JoystickL.Y > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.Y * 2);                  }                  else if (classic.JoystickL.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.Y * 2 > outConfig.Threshold && !PressedButtons["Classic.StickLUp"])                  {                      PressedButtons["Classic.StickLUp"] = true;                      this.executeButtonDown("Classic.StickLUp");                  }                  else if (classic.JoystickL.Y * 2 < outConfig.Threshold && PressedButtons["Classic.StickLUp"])                  {                      PressedButtons["Classic.StickLUp"] = false;                      this.executeButtonUp("Classic.StickLUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLUp"' out outConfig))              {                  if (classic.JoystickL.Y > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.Y * 2);                  }                  else if (classic.JoystickL.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.Y * 2 > outConfig.Threshold && !PressedButtons["Classic.StickLUp"])                  {                      PressedButtons["Classic.StickLUp"] = true;                      this.executeButtonDown("Classic.StickLUp");                  }                  else if (classic.JoystickL.Y * 2 < outConfig.Threshold && PressedButtons["Classic.StickLUp"])                  {                      PressedButtons["Classic.StickLUp"] = false;                      this.executeButtonUp("Classic.StickLUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLDown"' out outConfig))              {                  if (classic.JoystickL.Y < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.Y * -2);                  }                  else if (classic.JoystickL.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.Y * -2 > outConfig.Threshold && !PressedButtons["Classic.StickLDown"])                  {                      PressedButtons["Classic.StickLDown"] = true;                      this.executeButtonDown("Classic.StickLDown");                  }                  else if (classic.JoystickL.Y * -2 < outConfig.Threshold && PressedButtons["Classic.StickLDown"])                  {                      PressedButtons["Classic.StickLDown"] = false;                      this.executeButtonUp("Classic.StickLDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLDown"' out outConfig))              {                  if (classic.JoystickL.Y < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.Y * -2);                  }                  else if (classic.JoystickL.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.Y * -2 > outConfig.Threshold && !PressedButtons["Classic.StickLDown"])                  {                      PressedButtons["Classic.StickLDown"] = true;                      this.executeButtonDown("Classic.StickLDown");                  }                  else if (classic.JoystickL.Y * -2 < outConfig.Threshold && PressedButtons["Classic.StickLDown"])                  {                      PressedButtons["Classic.StickLDown"] = false;                      this.executeButtonUp("Classic.StickLDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickLDown"' out outConfig))              {                  if (classic.JoystickL.Y < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickL.Y * -2);                  }                  else if (classic.JoystickL.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickL.Y * -2 > outConfig.Threshold && !PressedButtons["Classic.StickLDown"])                  {                      PressedButtons["Classic.StickLDown"] = true;                      this.executeButtonDown("Classic.StickLDown");                  }                  else if (classic.JoystickL.Y * -2 < outConfig.Threshold && PressedButtons["Classic.StickLDown"])                  {                      PressedButtons["Classic.StickLDown"] = false;                      this.executeButtonUp("Classic.StickLDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRRight"' out outConfig))              {                  if (classic.JoystickR.X > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.X * 2);                  }                  else if (classic.JoystickR.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.X * 2 > outConfig.Threshold && !PressedButtons["Classic.StickRRight"])                  {                      PressedButtons["Classic.StickRRight"] = true;                      this.executeButtonDown("Classic.StickRRight");                  }                  else if (classic.JoystickR.X * 2 < outConfig.Threshold && PressedButtons["Classic.StickRRight"])                  {                      PressedButtons["Classic.StickRRight"] = false;                      this.executeButtonUp("Classic.StickRRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRRight"' out outConfig))              {                  if (classic.JoystickR.X > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.X * 2);                  }                  else if (classic.JoystickR.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.X * 2 > outConfig.Threshold && !PressedButtons["Classic.StickRRight"])                  {                      PressedButtons["Classic.StickRRight"] = true;                      this.executeButtonDown("Classic.StickRRight");                  }                  else if (classic.JoystickR.X * 2 < outConfig.Threshold && PressedButtons["Classic.StickRRight"])                  {                      PressedButtons["Classic.StickRRight"] = false;                      this.executeButtonUp("Classic.StickRRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRRight"' out outConfig))              {                  if (classic.JoystickR.X > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.X * 2);                  }                  else if (classic.JoystickR.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.X * 2 > outConfig.Threshold && !PressedButtons["Classic.StickRRight"])                  {                      PressedButtons["Classic.StickRRight"] = true;                      this.executeButtonDown("Classic.StickRRight");                  }                  else if (classic.JoystickR.X * 2 < outConfig.Threshold && PressedButtons["Classic.StickRRight"])                  {                      PressedButtons["Classic.StickRRight"] = false;                      this.executeButtonUp("Classic.StickRRight");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRLeft"' out outConfig))              {                  if (classic.JoystickR.X < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.X * -2);                  }                  else if (classic.JoystickR.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.X * -2 > outConfig.Threshold && !PressedButtons["Classic.StickRLeft"])                  {                      PressedButtons["Classic.StickRLeft"] = true;                      this.executeButtonDown("Classic.StickRLeft");                  }                  else if (classic.JoystickR.X * -2 < outConfig.Threshold && PressedButtons["Classic.StickRLeft"])                  {                      PressedButtons["Classic.StickRLeft"] = false;                      this.executeButtonUp("Classic.StickRLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRLeft"' out outConfig))              {                  if (classic.JoystickR.X < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.X * -2);                  }                  else if (classic.JoystickR.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.X * -2 > outConfig.Threshold && !PressedButtons["Classic.StickRLeft"])                  {                      PressedButtons["Classic.StickRLeft"] = true;                      this.executeButtonDown("Classic.StickRLeft");                  }                  else if (classic.JoystickR.X * -2 < outConfig.Threshold && PressedButtons["Classic.StickRLeft"])                  {                      PressedButtons["Classic.StickRLeft"] = false;                      this.executeButtonUp("Classic.StickRLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRLeft"' out outConfig))              {                  if (classic.JoystickR.X < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.X * -2);                  }                  else if (classic.JoystickR.X == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.X * -2 > outConfig.Threshold && !PressedButtons["Classic.StickRLeft"])                  {                      PressedButtons["Classic.StickRLeft"] = true;                      this.executeButtonDown("Classic.StickRLeft");                  }                  else if (classic.JoystickR.X * -2 < outConfig.Threshold && PressedButtons["Classic.StickRLeft"])                  {                      PressedButtons["Classic.StickRLeft"] = false;                      this.executeButtonUp("Classic.StickRLeft");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRUp"' out outConfig))              {                  if (classic.JoystickR.Y > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.Y * 2);                  }                  else if (classic.JoystickR.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.Y * 2 > outConfig.Threshold && !PressedButtons["Classic.StickRUp"])                  {                      PressedButtons["Classic.StickRUp"] = true;                      this.executeButtonDown("Classic.StickRUp");                  }                  else if (classic.JoystickR.Y * 2 < outConfig.Threshold && PressedButtons["Classic.StickRUp"])                  {                      PressedButtons["Classic.StickRUp"] = false;                      this.executeButtonUp("Classic.StickRUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRUp"' out outConfig))              {                  if (classic.JoystickR.Y > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.Y * 2);                  }                  else if (classic.JoystickR.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.Y * 2 > outConfig.Threshold && !PressedButtons["Classic.StickRUp"])                  {                      PressedButtons["Classic.StickRUp"] = true;                      this.executeButtonDown("Classic.StickRUp");                  }                  else if (classic.JoystickR.Y * 2 < outConfig.Threshold && PressedButtons["Classic.StickRUp"])                  {                      PressedButtons["Classic.StickRUp"] = false;                      this.executeButtonUp("Classic.StickRUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRUp"' out outConfig))              {                  if (classic.JoystickR.Y > 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.Y * 2);                  }                  else if (classic.JoystickR.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.Y * 2 > outConfig.Threshold && !PressedButtons["Classic.StickRUp"])                  {                      PressedButtons["Classic.StickRUp"] = true;                      this.executeButtonDown("Classic.StickRUp");                  }                  else if (classic.JoystickR.Y * 2 < outConfig.Threshold && PressedButtons["Classic.StickRUp"])                  {                      PressedButtons["Classic.StickRUp"] = false;                      this.executeButtonUp("Classic.StickRUp");                  }                }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRDown"' out outConfig))              {                  if (classic.JoystickR.Y < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.Y * -2);                  }                  else if (classic.JoystickR.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.Y * -2 > outConfig.Threshold && !PressedButtons["Classic.StickRDown"])                  {                      PressedButtons["Classic.StickRDown"] = true;                      this.executeButtonDown("Classic.StickRDown");                  }                  else if (classic.JoystickR.Y * -2 < outConfig.Threshold && PressedButtons["Classic.StickRDown"])                  {                      PressedButtons["Classic.StickRDown"] = false;                      this.executeButtonUp("Classic.StickRDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRDown"' out outConfig))              {                  if (classic.JoystickR.Y < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.Y * -2);                  }                  else if (classic.JoystickR.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.Y * -2 > outConfig.Threshold && !PressedButtons["Classic.StickRDown"])                  {                      PressedButtons["Classic.StickRDown"] = true;                      this.executeButtonDown("Classic.StickRDown");                  }                  else if (classic.JoystickR.Y * -2 < outConfig.Threshold && PressedButtons["Classic.StickRDown"])                  {                      PressedButtons["Classic.StickRDown"] = false;                      this.executeButtonUp("Classic.StickRDown");                  }              }
Magic Number,WiiTUIO.Provider,WiiKeyMap,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMap.cs,updateClassicController,The following statement contains a magic number: if (this.config.TryGetValue("Classic.StickRDown"' out outConfig))              {                  if (classic.JoystickR.Y < 0)                  {                      updateStickHandlers(outConfig' classic.JoystickR.Y * -2);                  }                  else if (classic.JoystickR.Y == 0)                  {                      updateStickHandlers(outConfig' 0);                  }                    if (classic.JoystickR.Y * -2 > outConfig.Threshold && !PressedButtons["Classic.StickRDown"])                  {                      PressedButtons["Classic.StickRDown"] = true;                      this.executeButtonDown("Classic.StickRDown");                  }                  else if (classic.JoystickR.Y * -2 < outConfig.Threshold && PressedButtons["Classic.StickRDown"])                  {                      PressedButtons["Classic.StickRDown"] = false;                      this.executeButtonUp("Classic.StickRDown");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,beginCalibration,The following statement contains a magic number: Canvas.SetZIndex(this' 999);
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,beginCalibration,The following statement contains a magic number: this.movePoint(0.1' 0.1);
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,beginCalibration,The following statement contains a magic number: this.movePoint(0.1' 0.1);
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,pWiiProvider_OnNewFrame,The following statement contains a magic number: if (lContacts.Count > 0)              {                  // Get the contact.                  WiiContact pContact = lContacts[0];                    // If it is a down contact.                  if (pContact.Type != ContactType.Start)                      return;                    // Reference the touch contact from the event.                  Vector vPoint = new Vector(pContact.Position.X' pContact.Position.Y);                    // Select what to do based on the calibration phase.                  switch (iCalibrationPhase)                  {                      case 1:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopLeft = vPoint;                          iCalibrationPhase = 2;                          this.stepCalibration();                          break;                      case 2:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.TopRight = vPoint;                          iCalibrationPhase = 3;                          this.stepCalibration();                          break;                      case 3:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomLeft = vPoint;                          iCalibrationPhase = 4;                          this.stepCalibration();                          break;                      case 4:                          // Get the point and update the rectangle' step the calibration phase over and then break out.                          pSourceRectangle.BottomRight = vPoint;                          iCalibrationPhase = 5;                          this.stepCalibration();                          break;                      default:                          throw new Exception("Unknown calibration phase '" + iCalibrationPhase + "' to handle this touch event!");                  }              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,finishedCalibration,The following statement contains a magic number: Dispatcher.BeginInvoke((Action)delegate()              {                  // Hide the calibration point.                  this.CalibrationPoint.Visibility = Visibility.Hidden;                    // Ensure the form is at the back' the correct size and visible.                  Canvas.SetTop(this' 0.0);                  Canvas.SetLeft(this' 0.0);                  Canvas.SetZIndex(this' -999);                  this.Width = 0;// (double)this.Parent.GetValue(Canvas.ActualWidthProperty);                  this.Height = 0;// (double)this.Parent.GetValue(Canvas.ActualHeightProperty);                    // Raise the event.                  if (OnCalibrationFinished != null)                      OnCalibrationFinished(pSourceRectangle' pDestinationRectangle' vScreenSize);              });
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,stepCalibration,The following statement contains a magic number: switch (iCalibrationPhase)              {                  case 1:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopLeft = this.movePoint(fCalibrationMargin' fCalibrationMargin);                      break;                  case 2:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopRight = this.movePoint(1.0 - fCalibrationMargin' fCalibrationMargin);                      break;                  case 3:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomLeft = this.movePoint(fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 4:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomRight = this.movePoint(1.0 - fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 5:                      // We have finished calibrating.  Set the phase to 0 - disabled.                      iCalibrationPhase = 0;                        // Enable the transformation phase in the input provider.                      this.finishedCalibration();                      break;                  default:                      throw new Exception("Unknown calibration phase!");              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,stepCalibration,The following statement contains a magic number: switch (iCalibrationPhase)              {                  case 1:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopLeft = this.movePoint(fCalibrationMargin' fCalibrationMargin);                      break;                  case 2:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopRight = this.movePoint(1.0 - fCalibrationMargin' fCalibrationMargin);                      break;                  case 3:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomLeft = this.movePoint(fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 4:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomRight = this.movePoint(1.0 - fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 5:                      // We have finished calibrating.  Set the phase to 0 - disabled.                      iCalibrationPhase = 0;                        // Enable the transformation phase in the input provider.                      this.finishedCalibration();                      break;                  default:                      throw new Exception("Unknown calibration phase!");              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,stepCalibration,The following statement contains a magic number: switch (iCalibrationPhase)              {                  case 1:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopLeft = this.movePoint(fCalibrationMargin' fCalibrationMargin);                      break;                  case 2:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopRight = this.movePoint(1.0 - fCalibrationMargin' fCalibrationMargin);                      break;                  case 3:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomLeft = this.movePoint(fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 4:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomRight = this.movePoint(1.0 - fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 5:                      // We have finished calibrating.  Set the phase to 0 - disabled.                      iCalibrationPhase = 0;                        // Enable the transformation phase in the input provider.                      this.finishedCalibration();                      break;                  default:                      throw new Exception("Unknown calibration phase!");              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,stepCalibration,The following statement contains a magic number: switch (iCalibrationPhase)              {                  case 1:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopLeft = this.movePoint(fCalibrationMargin' fCalibrationMargin);                      break;                  case 2:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.TopRight = this.movePoint(1.0 - fCalibrationMargin' fCalibrationMargin);                      break;                  case 3:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomLeft = this.movePoint(fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 4:                      // Get the point and update the rectangle' step the calibration phase over and then break out.                      pDestinationRectangle.BottomRight = this.movePoint(1.0 - fCalibrationMargin' 1.0 - fCalibrationMargin);                      break;                  case 5:                      // We have finished calibrating.  Set the phase to 0 - disabled.                      iCalibrationPhase = 0;                        // Enable the transformation phase in the input provider.                      this.finishedCalibration();                      break;                  default:                      throw new Exception("Unknown calibration phase!");              }
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,movePoint,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  this.CalibrationPoint.Visibility = Visibility.Visible;                    // Move the canvas element.                  Canvas.SetLeft(this.CalibrationPoint' tPoint.X - (this.CalibrationPoint.ActualWidth / 2));                  Canvas.SetTop(this.CalibrationPoint' tPoint.Y - (this.CalibrationPoint.ActualHeight / 2));                })' null);
Magic Number,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,movePoint,The following statement contains a magic number: Dispatcher.BeginInvoke(new Action(delegate()              {                  this.CalibrationPoint.Visibility = Visibility.Visible;                    // Move the canvas element.                  Canvas.SetLeft(this.CalibrationPoint' tPoint.X - (this.CalibrationPoint.ActualWidth / 2));                  Canvas.SetTop(this.CalibrationPoint' tPoint.Y - (this.CalibrationPoint.ActualHeight / 2));                })' null);
Magic Number,WiiTUIO.Provider,CalibrationWindow,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\CalibrationWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 5 "..\..\..\..\..\Input\WiiProvider\Settings\CalibrationWindow.xaml"              ((WiiTUIO.Provider.CalibrationWindow)(target)).KeyUp += new System.Windows.Input.KeyEventHandler(this.Window_KeyUp_1);                            #line default              #line hidden              return;              case 2:              this.CalibrationCanvas = ((WiiTUIO.Provider.Calibrate)(target));              return;              }
Magic Number,WiiTUIO.Provider,WiiKeyMapper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Keymap\WiiKeyMapper.cs,WiiKeyMapper,The following statement contains a magic number: homeButtonTimer.Interval = 1000;
Magic Number,WiiTUIO.Provider,MouseSimulator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MouseSimulator.cs,WakeCursor,The following statement contains a magic number: SendInput(2' inputs' Marshal.SizeOf(input));
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following statement contains a magic number: if(irState.IRSensors[0].Found && irState.IRSensors[1].Found)              {                              foundMidpoint = true;                                relativePosition.X = (irState.IRSensors[0].Position.X + irState.IRSensors[1].Position.X) / 2.0f;                              relativePosition.Y = (irState.IRSensors[0].Position.Y + irState.IRSensors[1].Position.Y) / 2.0f;                                if (Settings.Default.pointer_considerRotation)                              {                                  //accelSmoothing.addValue(new System.Windows.Vector(args.WiimoteState.AccelState.RawValues.X' args.WiimoteState.AccelState.RawValues.Z));                                    //System.Windows.Vector smoothedRotation = accelSmoothing.getSmoothedValue();                                  /*                                  while (accXhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accXhistory.Dequeue();                                  }                                  while (accZhistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      accZhistory.Dequeue();                                  }                                    accXhistory.Enqueue(args.WiimoteState.AccelState.RawValues.X);                                  accZhistory.Enqueue(args.WiimoteState.AccelState.RawValues.Z);                                                                    smoothedX = 0;                                  smoothedZ = 0;                                    foreach (double accX in accXhistory)                                  {                                      smoothedX += accX;                                  }                                  smoothedX /= accXhistory.Count;                                    foreach (double accZ in accZhistory)                                  {                                      smoothedZ += accZ;                                  }                                  smoothedZ /= accZhistory.Count;                                  */                                    smoothedX = smoothedX * 0.9 + wiimoteState.AccelState.RawValues.X * 0.1;                                  smoothedZ = smoothedZ * 0.9 + wiimoteState.AccelState.RawValues.Z * 0.1;                                    double absx = Math.Abs(smoothedX - 128)' absz = Math.Abs(smoothedZ - 128);                                    if (orientation == 0 || orientation == 2) absx -= 5;                                  if (orientation == 1 || orientation == 3) absz -= 5;                                    if (absz >= absx)                                  {                                      if (absz > 5)                                          orientation = (smoothedZ > 128) ? 0 : 2;                                  }                                  else                                  {                                      if (absx > 5)                                          orientation = (smoothedX > 128) ? 3 : 1;                                  }                                    int l = leftPoint' r;                                  //if (leftPoint == -1)                                  //{                                      switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }                                      leftPoint = l;                                  //}                                  r = 1 - l;                                    double dx = irState.IRSensors[r].RawPosition.X - irState.IRSensors[l].RawPosition.X;                                  double dy = irState.IRSensors[r].RawPosition.Y - irState.IRSensors[l].RawPosition.Y;                                    double d = Math.Sqrt(dx * dx + dy * dy);                                    dx /= d;                                  dy /= d;                                    smoothedRotation = 0.7 * smoothedRotation + 0.3 * Math.Atan2(dy' dx);                                    /*                                  while (rotationHistory.Count >= Settings.Default.pointer_rotationSmoothing)                                  {                                      rotationHistory.Dequeue();                                  }                                    rotationHistory.Enqueue(rotation);                                    double smoothedRotation = 0;                                  foreach (double rot in rotationHistory)                                  {                                      smoothedRotation += rot;                                  }                                  smoothedRotation /= rotationHistory.Count;                                  */                                    //smoothedRotation = smoothedRotation * 0.9 + rotation * 0.1;                                  //rotation = smoothedRotation;                              }                          //}                      //}                  //}              }
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,initialiseWiimoteConnections,The following statement contains a magic number: try              {                  Dictionary<string' WiimoteControl> copy = new Dictionary<string' WiimoteControl>(pWiimoteMap);                  foreach (WiimoteControl control in copy.Values)                  {                      Wiimote pDevice = control.Wiimote;                      try                      {                          if (!control.Status.InPowerSave                              && control.LastWiimoteEventTime != null                              && DateTime.Now.Subtract(control.LastWiimoteEventTime).TotalMilliseconds > WIIMOTE_DISCONNECT_TIMEOUT)                          {                              Console.WriteLine("Teardown 1 " + pDevice.HIDDevicePath + " because of timeout with delta " + DateTime.Now.Subtract(pWiimoteMap[pDevice.HIDDevicePath].LastWiimoteEventTime).TotalMilliseconds);                              teardownWiimoteConnection(control.Wiimote);                          }                          else if (!control.Status.InPowerSave                              && control.LastSignificantWiimoteEventTime != null                              && DateTime.Now.Subtract(control.LastSignificantWiimoteEventTime).TotalMilliseconds > WIIMOTE_SIGNIFICANT_DISCONNECT_TIMEOUT)                          {                              Console.WriteLine("Put " + pDevice.HIDDevicePath + " to power saver mode because of timeout with delta " + DateTime.Now.Subtract(control.LastSignificantWiimoteEventTime).TotalMilliseconds);                              //teardownWiimoteConnection(pWiimoteMap[pDevice.HIDDevicePath].Wiimote);                              putToPowerSave(control);                          }                          else if (control.Status.InPowerSave                          && control.LastWiimoteEventTime != null                          && DateTime.Now.Subtract(control.LastWiimoteEventTime).TotalMilliseconds > WIIMOTE_POWER_SAVE_DISCONNECT_TIMEOUT)                          {                              Console.WriteLine("Teardown 2 " + pDevice.HIDDevicePath + " because of timeout with delta " + DateTime.Now.Subtract(control.LastWiimoteEventTime).TotalMilliseconds);                              teardownWiimoteConnection(control.Wiimote);                          }                          else if (control.Status.InPowerSave)                          {                                                              if (CONNECTION_THREAD_SLEEP * statusWait >= POWER_SAVE_STATUS_INTERVAL)                              {                                  statusWait = 0;                                  control.WiimoteMutex.WaitOne();                                  try                                  {                                      control.Wiimote.GetStatus();                                  }                                  catch { }                                  control.WiimoteMutex.ReleaseMutex();                              }                              else                              {                                  statusWait++;                              }                                if (CONNECTION_THREAD_SLEEP * blinkWait >= POWER_SAVE_BLINK_DELAY)                              {                                  blinkWait = 0;                                  control.Wiimote.SetLEDs(true' true' true' true);                                  Thread.Sleep(100);                                  control.Wiimote.SetLEDs(false' false' false' false);                              }                              else                              {                                  blinkWait++;                              }                          }                      }                      catch (Exception pError)                      {                          try                          {                              Console.WriteLine("Teardown 3 " + pDevice.HIDDevicePath + " because of " + pError.Message);                              this.teardownWiimoteConnection(pDevice);                          }                          finally                          {                          }                          pErrorReport = pError;                      }                  }                    this.pWC.Clear();                  this.pWC.FindAllWiimotes();                                    foreach (Wiimote pDevice in pWC)                  {                      try                      {                          if (!pWiimoteMap.Keys.Contains(pDevice.HIDDevicePath))                          {                              this.connectWiimote(pDevice);                          }                      }                      // If something went wrong - notify the user..                      catch (Exception pError)                      {                          // Ensure we are ok.                          try                          {                              Console.WriteLine("Teardown 4 "+ pDevice.HIDDevicePath +" because of " + pError.Message);                              this.teardownWiimoteConnection(pDevice);                          }                          finally { }                          // Say we screwed up.                          pErrorReport = pError;                          //throw new Exception("Error establishing connection: " + ' pError);                                            }                                    }              }              catch (Exception e)              {                  pErrorReport = e;              }
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,connectWiimote,The following statement contains a magic number: wiimote.SetLEDs(id == 1' id == 2' id == 3' id == 4);
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,connectWiimote,The following statement contains a magic number: wiimote.SetLEDs(id == 1' id == 2' id == 3' id == 4);
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,connectWiimote,The following statement contains a magic number: wiimote.SetLEDs(id == 1' id == 2' id == 3' id == 4);
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,wakeFromPowerSave,The following statement contains a magic number: try              {                  control.Wiimote.SetReportType(InputReport.IRExtensionAccel' IRSensitivity.Maximum' true);                  control.Status.InPowerSave = false;                  int id = control.Status.ID;                  control.Wiimote.SetLEDs(id == 1' id == 2' id == 3' id == 4);                  control.Wiimote.SetRumble(true);                  new Timer(connectRumble'control.Wiimote'0'Timeout.Infinite);              }              catch { }              finally              {                  control.WiimoteMutex.ReleaseMutex();              }
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,wakeFromPowerSave,The following statement contains a magic number: try              {                  control.Wiimote.SetReportType(InputReport.IRExtensionAccel' IRSensitivity.Maximum' true);                  control.Status.InPowerSave = false;                  int id = control.Status.ID;                  control.Wiimote.SetLEDs(id == 1' id == 2' id == 3' id == 4);                  control.Wiimote.SetRumble(true);                  new Timer(connectRumble'control.Wiimote'0'Timeout.Infinite);              }              catch { }              finally              {                  control.WiimoteMutex.ReleaseMutex();              }
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,wakeFromPowerSave,The following statement contains a magic number: try              {                  control.Wiimote.SetReportType(InputReport.IRExtensionAccel' IRSensitivity.Maximum' true);                  control.Status.InPowerSave = false;                  int id = control.Status.ID;                  control.Wiimote.SetLEDs(id == 1' id == 2' id == 3' id == 4);                  control.Wiimote.SetRumble(true);                  new Timer(connectRumble'control.Wiimote'0'Timeout.Infinite);              }              catch { }              finally              {                  control.WiimoteMutex.ReleaseMutex();              }
Magic Number,WiiTUIO.Provider,MultiWiiPointerProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\MultiWiiPointerProvider.cs,WiimoteHandlerWorker,The following statement contains a magic number: double millisecondsForEachFrame = 1000 / Settings.Default.pointer_FPS;
Magic Number,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MonitorComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 10 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.MonitorComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.MonitorComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 2:              this.SBPositionComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 14 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.SBPositionComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.SBPositionComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 3:              this.cbiCenter = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 4:              this.cbiTop = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 5:              this.cbiBottom = ((System.Windows.Controls.ComboBoxItem)(target));              return;              }
Magic Number,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MonitorComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 10 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.MonitorComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.MonitorComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 2:              this.SBPositionComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 14 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.SBPositionComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.SBPositionComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 3:              this.cbiCenter = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 4:              this.cbiTop = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 5:              this.cbiBottom = ((System.Windows.Controls.ComboBoxItem)(target));              return;              }
Magic Number,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MonitorComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 10 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.MonitorComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.MonitorComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 2:              this.SBPositionComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 14 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.SBPositionComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.SBPositionComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 3:              this.cbiCenter = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 4:              this.cbiTop = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 5:              this.cbiBottom = ((System.Windows.Controls.ComboBoxItem)(target));              return;              }
Magic Number,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MonitorComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 10 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.MonitorComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.MonitorComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 2:              this.SBPositionComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 14 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.SBPositionComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.SBPositionComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 3:              this.cbiCenter = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 4:              this.cbiTop = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 5:              this.cbiBottom = ((System.Windows.Controls.ComboBoxItem)(target));              return;              }
Magic Number,WiiTUIO.Provider,SpatioTemporalClassifier,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,SpatioTemporalClassifier,The following statement contains a magic number: this.lTrackers = new List<SpatioTemporalTracker>(4);
Magic Number,WiiTUIO.Provider,SpatioTemporalClassifier,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,SpatioTemporalClassifier,The following statement contains a magic number: this.DefaultSmoothSize = 3;
Magic Number,WiiTUIO.Provider,SpatioTemporalClassifier,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\SpatiotemporalClassifier.cs,SpatioTemporalClassifier,The following statement contains a magic number: this.DuplicateDistance = 10;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setSource,The following statement contains a magic number: srcX[2] = x2;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setSource,The following statement contains a magic number: srcY[2] = y2;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setSource,The following statement contains a magic number: srcX[3] = x3;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setSource,The following statement contains a magic number: srcY[3] = y3;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setDestination,The following statement contains a magic number: dstX[2] = x2;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setDestination,The following statement contains a magic number: dstY[2] = y2;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setDestination,The following statement contains a magic number: dstX[3] = x3;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,setDestination,The following statement contains a magic number: dstY[3] = y3;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeQuadToSquare(srcX[0]' srcY[0]' srcX[1]' srcY[1]' srcX[2]' srcY[2]' srcX[3]' srcY[3]' srcMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeQuadToSquare(srcX[0]' srcY[0]' srcX[1]' srcY[1]' srcX[2]' srcY[2]' srcX[3]' srcY[3]' srcMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeQuadToSquare(srcX[0]' srcY[0]' srcX[1]' srcY[1]' srcX[2]' srcY[2]' srcX[3]' srcY[3]' srcMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeQuadToSquare(srcX[0]' srcY[0]' srcX[1]' srcY[1]' srcX[2]' srcY[2]' srcX[3]' srcY[3]' srcMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeSquareToQuad(dstX[0]' dstY[0]' dstX[1]' dstY[1]' dstX[2]' dstY[2]' dstX[3]' dstY[3]' dstMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeSquareToQuad(dstX[0]' dstY[0]' dstX[1]' dstY[1]' dstX[2]' dstY[2]' dstX[3]' dstY[3]' dstMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeSquareToQuad(dstX[0]' dstY[0]' dstX[1]' dstY[1]' dstX[2]' dstY[2]' dstX[3]' dstY[3]' dstMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeWarp,The following statement contains a magic number: computeSquareToQuad(dstX[0]' dstY[0]' dstX[1]' dstY[1]' dstX[2]' dstY[2]' dstX[3]' dstY[3]' dstMat);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,multMats,The following statement contains a magic number: for (int r = 0; r < 4; r++)              {                  int ri = r * 4;                  for (int c = 0; c < 4; c++)                  {                      resMat[ri + c] = (srcMat[ri] * dstMat[c] +                                srcMat[ri + 1] * dstMat[c + 4] +                                srcMat[ri + 2] * dstMat[c + 8] +                                srcMat[ri + 3] * dstMat[c + 12]);                  }              }
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[2] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[3] = g;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[4] = b;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[5] = e;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[6] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[7] = h;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[8] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[9] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[10] = 1;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[11] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[12] = c;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[13] = f;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[14] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeSquareToQuad,The following statement contains a magic number: mat[15] = 1;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: float a = mat[0]' d = mat[1]'	/* ignore */		g = mat[3];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: float b = mat[4]' e = mat[5]'	/* 3rd col*/		h = mat[7];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: float b = mat[4]' e = mat[5]'	/* 3rd col*/		h = mat[7];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: float b = mat[4]' e = mat[5]'	/* 3rd col*/		h = mat[7];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: float c = mat[12]' f = mat[13];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: float c = mat[12]' f = mat[13];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[2] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[3] = G * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[4] = B * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[5] = E * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[6] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[7] = H * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[8] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[9] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[10] = 1;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[11] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[12] = C * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[13] = F * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[14] = 0;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,computeQuadToSquare,The following statement contains a magic number: mat[15] = I * idet;
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: float[] result = new float[4];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[0] = (float)(srcX * mat[0] + srcY * mat[4] + z * mat[8] + 1 * mat[12]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[0] = (float)(srcX * mat[0] + srcY * mat[4] + z * mat[8] + 1 * mat[12]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[0] = (float)(srcX * mat[0] + srcY * mat[4] + z * mat[8] + 1 * mat[12]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[1] = (float)(srcX * mat[1] + srcY * mat[5] + z * mat[9] + 1 * mat[13]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[1] = (float)(srcX * mat[1] + srcY * mat[5] + z * mat[9] + 1 * mat[13]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[1] = (float)(srcX * mat[1] + srcY * mat[5] + z * mat[9] + 1 * mat[13]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[2] = (float)(srcX * mat[2] + srcY * mat[6] + z * mat[10] + 1 * mat[14]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[2] = (float)(srcX * mat[2] + srcY * mat[6] + z * mat[10] + 1 * mat[14]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[2] = (float)(srcX * mat[2] + srcY * mat[6] + z * mat[10] + 1 * mat[14]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[2] = (float)(srcX * mat[2] + srcY * mat[6] + z * mat[10] + 1 * mat[14]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[2] = (float)(srcX * mat[2] + srcY * mat[6] + z * mat[10] + 1 * mat[14]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[3] = (float)(srcX * mat[3] + srcY * mat[7] + z * mat[11] + 1 * mat[15]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[3] = (float)(srcX * mat[3] + srcY * mat[7] + z * mat[11] + 1 * mat[15]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[3] = (float)(srcX * mat[3] + srcY * mat[7] + z * mat[11] + 1 * mat[15]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[3] = (float)(srcX * mat[3] + srcY * mat[7] + z * mat[11] + 1 * mat[15]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: result[3] = (float)(srcX * mat[3] + srcY * mat[7] + z * mat[11] + 1 * mat[15]);
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: dstX = result[0] / result[3];
Magic Number,WiiTUIO.Provider,Warper,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Warper.cs,warp,The following statement contains a magic number: dstY = result[1] / result[3];
Magic Number,WiiTUIO.Provider,WiiProvider,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\WiiProvider.cs,WiiProvider,The following statement contains a magic number: this.InputClassifier.DefaultSmoothSize = 4;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: for (Int32 Index = 0; Index < 28; Index++) Output[Index] = 0x00;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: Output[4] = Input[0];
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: Output[9] = 0x14;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputBus,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputBus.cs,Parse,The following statement contains a magic number: if (Input[1] == 0x02) // Pad is active              {                  UInt32 Buttons = (UInt32)((Input[10] << 0) | (Input[11] << 8) | (Input[12] << 16) | (Input[13] << 24));                    if ((Buttons & (0x1 << 0)) > 0) Output[10] |= (Byte)(1 << 5); // Back                  if ((Buttons & (0x1 << 1)) > 0) Output[10] |= (Byte)(1 << 6); // Left  Thumb                  if ((Buttons & (0x1 << 2)) > 0) Output[10] |= (Byte)(1 << 7); // Right Thumb                  if ((Buttons & (0x1 << 3)) > 0) Output[10] |= (Byte)(1 << 4); // Start                    if ((Buttons & (0x1 << 4)) > 0) Output[10] |= (Byte)(1 << 0); // Up                  if ((Buttons & (0x1 << 5)) > 0) Output[10] |= (Byte)(1 << 1); // Down                  if ((Buttons & (0x1 << 6)) > 0) Output[10] |= (Byte)(1 << 3); // Right                  if ((Buttons & (0x1 << 7)) > 0) Output[10] |= (Byte)(1 << 2); // Left                    if ((Buttons & (0x1 << 10)) > 0) Output[11] |= (Byte)(1 << 0); // Left  Shoulder                  if ((Buttons & (0x1 << 11)) > 0) Output[11] |= (Byte)(1 << 1); // Right Shoulder                    if ((Buttons & (0x1 << 12)) > 0) Output[11] |= (Byte)(1 << 7); // Y                  if ((Buttons & (0x1 << 13)) > 0) Output[11] |= (Byte)(1 << 5); // B                  if ((Buttons & (0x1 << 14)) > 0) Output[11] |= (Byte)(1 << 4); // A                  if ((Buttons & (0x1 << 15)) > 0) Output[11] |= (Byte)(1 << 6); // X                    if ((Buttons & (0x1 << 16)) > 0) Output[11] |= (Byte)(1 << 2); // Guide                    Output[12] = Input[26]; // Left Trigger                  Output[13] = Input[27]; // Right Trigger                    Output[14] = Input[14]; // LX                  Output[15] = Input[15];                    Output[16] = Input[16]; // LY                  Output[17] = Input[17];                    Output[18] = Input[18]; // RX                  Output[19] = Input[19];                    Output[20] = Input[20]; // RY                  Output[21] = Input[21];              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonUp,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 0.0;                          break;                      case "triggerl":                          report.TriggerL = 0.0;                          break;                      case "a":                          report.A = false;                          break;                      case "b":                          report.B = false;                          break;                      case "x":                          report.X = false;                          break;                      case "y":                          report.Y = false;                          break;                      case "back":                          report.Back = false;                          break;                      case "start":                          report.Start = false;                          break;                      case "stickpressl":                          report.StickPressL = false;                          break;                      case "stickpressr":                          report.StickPressR = false;                          break;                      case "up":                          report.Up = false;                          break;                      case "down":                          report.Down = false;                          break;                      case "right":                          report.Right = false;                          break;                      case "left":                          report.Left = false;                          break;                      case "guide":                          report.Guide = false;                          break;                      case "bumperl":                          report.BumperL = false;                          break;                      case "bumperr":                          report.BumperR = false;                          break;                      case "stickrright":                          report.StickRX = 0.5;                          break;                      case "stickrup":                          report.StickRY = 0.5;                          break;                      case "sticklright":                          report.StickLX = 0.5;                          break;                      case "sticklup":                          report.StickLY = 0.5;                          break;                      case "stickrleft":                          report.StickRX = 0.5;                          break;                      case "stickrdown":                          report.StickRY = 0.5;                          break;                      case "sticklleft":                          report.StickLX = 0.5;                          break;                      case "stickldown":                          report.StickLY = 0.5;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonDown,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 1.0;                          break;                      case "triggerl":                          report.TriggerL = 1.0;                          break;                      case "a":                          report.A = true;                          break;                      case "b":                          report.B = true;                          break;                      case "x":                          report.X = true;                          break;                      case "y":                          report.Y = true;                          break;                      case "back":                          report.Back = true;                          break;                      case "start":                          report.Start = true;                          break;                      case "stickpressl":                          report.StickPressL = true;                          break;                      case "stickpressr":                          report.StickPressR = true;                          break;                      case "up":                          report.Up = true;                          break;                      case "down":                          report.Down = true;                          break;                      case "right":                          report.Right = true;                          break;                      case "left":                          report.Left = true;                          break;                      case "guide":                          report.Guide = true;                          break;                      case "bumperl":                          report.BumperL = true;                          break;                      case "bumperr":                          report.BumperR = true;                          break;                      case "stickrright":                          report.StickRX = 1.0;                          break;                      case "stickrup":                          report.StickRY = 1.0;                          break;                      case "sticklright":                          report.StickLX = 1.0;                          break;                      case "sticklup":                          report.StickLY = 1.0;                          break;                      case "stickrleft":                          report.StickRX = 0.0;                          break;                      case "stickrdown":                          report.StickRY = 0.0;                          break;                      case "sticklleft":                          report.StickLX = 0.0;                          break;                      case "stickldown":                          report.StickLY = 0.0;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonDown,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 1.0;                          break;                      case "triggerl":                          report.TriggerL = 1.0;                          break;                      case "a":                          report.A = true;                          break;                      case "b":                          report.B = true;                          break;                      case "x":                          report.X = true;                          break;                      case "y":                          report.Y = true;                          break;                      case "back":                          report.Back = true;                          break;                      case "start":                          report.Start = true;                          break;                      case "stickpressl":                          report.StickPressL = true;                          break;                      case "stickpressr":                          report.StickPressR = true;                          break;                      case "up":                          report.Up = true;                          break;                      case "down":                          report.Down = true;                          break;                      case "right":                          report.Right = true;                          break;                      case "left":                          report.Left = true;                          break;                      case "guide":                          report.Guide = true;                          break;                      case "bumperl":                          report.BumperL = true;                          break;                      case "bumperr":                          report.BumperR = true;                          break;                      case "stickrright":                          report.StickRX = 1.0;                          break;                      case "stickrup":                          report.StickRY = 1.0;                          break;                      case "sticklright":                          report.StickLX = 1.0;                          break;                      case "sticklup":                          report.StickLY = 1.0;                          break;                      case "stickrleft":                          report.StickRX = 0.0;                          break;                      case "stickrdown":                          report.StickRY = 0.0;                          break;                      case "sticklleft":                          report.StickLX = 0.0;                          break;                      case "stickldown":                          report.StickLY = 0.0;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setButtonDown,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  string button = key.ToLower().Substring(4);                  switch (button)                  {                      case "triggerr":                          report.TriggerR = 1.0;                          break;                      case "triggerl":                          report.TriggerL = 1.0;                          break;                      case "a":                          report.A = true;                          break;                      case "b":                          report.B = true;                          break;                      case "x":                          report.X = true;                          break;                      case "y":                          report.Y = true;                          break;                      case "back":                          report.Back = true;                          break;                      case "start":                          report.Start = true;                          break;                      case "stickpressl":                          report.StickPressL = true;                          break;                      case "stickpressr":                          report.StickPressR = true;                          break;                      case "up":                          report.Up = true;                          break;                      case "down":                          report.Down = true;                          break;                      case "right":                          report.Right = true;                          break;                      case "left":                          report.Left = true;                          break;                      case "guide":                          report.Guide = true;                          break;                      case "bumperl":                          report.BumperL = true;                          break;                      case "bumperr":                          report.BumperR = true;                          break;                      case "stickrright":                          report.StickRX = 1.0;                          break;                      case "stickrup":                          report.StickRY = 1.0;                          break;                      case "sticklright":                          report.StickLX = 1.0;                          break;                      case "sticklup":                          report.StickLY = 1.0;                          break;                      case "stickrleft":                          report.StickRX = 0.0;                          break;                      case "stickrdown":                          report.StickRY = 0.0;                          break;                      case "sticklleft":                          report.StickLX = 0.0;                          break;                      case "stickldown":                          report.StickLY = 0.0;                          break;                      default:                          return false; //No valid key code was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setValue,The following statement contains a magic number: if (key.Length > 4 && key.ToLower().Substring(0' 4).Equals(PREFIX))              {                  key = key.ToLower().Substring(4);                  //Make sure value is in range 0-1                  value = value > 1 ? 1 : value;                  value = value < 0 ? 0 : value;                  switch (key)                  {                      case "sticklright":                          report.StickLX = 0.5 + (value * 0.5);                          break;                      case "sticklleft":                          report.StickLX = 0.5 - (value * 0.5);                          break;                      case "sticklup":                          report.StickLY = 0.5 + (value * 0.5);                          break;                      case "stickldown":                          report.StickLY = 0.5 - (value * 0.5);                          break;                      case "stickrright":                          report.StickRX = 0.5 + (value * 0.5);                          break;                      case "stickrleft":                          report.StickRX = 0.5 - (value * 0.5);                          break;                      case "stickrup":                          report.StickRY = 0.5 + (value * 0.5);                          break;                      case "stickrdown":                          report.StickRY = 0.5 - (value * 0.5);                          break;                      case "triggerr":                          report.TriggerR = value;                          break;                      case "triggerl":                          report.TriggerL = value;                          break;                      default:                          return false; //No valid key was found                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: Byte[] input = new Byte[28];
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] = 0;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] = 0;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[12] = 0;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[13] = 0;
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Back ? 1 << 0 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.StickPressL ? 1 << 1 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.StickPressR ? 1 << 2 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.StickPressR ? 1 << 2 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Start ? 1 << 3 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Start ? 1 << 3 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Up ? 1 << 4 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Up ? 1 << 4 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Down ? 1 << 5 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Down ? 1 << 5 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Right ? 1 << 6 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Right ? 1 << 6 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Left ? 1 << 7 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[10] |= (Byte)(this.Left ? 1 << 7 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.BumperL ? 1 << 2 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.BumperL ? 1 << 2 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.BumperR ? 1 << 3 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.BumperR ? 1 << 3 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.Y ? 1 << 4 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.Y ? 1 << 4 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.B ? 1 << 5 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.B ? 1 << 5 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.A ? 1 << 6 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.A ? 1 << 6 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.X ? 1 << 7 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[11] |= (Byte)(this.X ? 1 << 7 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[12] |= (Byte)(this.Guide ? 1 << 0 : 0);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[26] = getTriggerLRaw();
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[27] = getTriggerRRaw();
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[14] = (Byte)((ThumbLX >> 0) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[15] = (Byte)((ThumbLX >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[15] = (Byte)((ThumbLX >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[16] = (Byte)((ThumbLY >> 0) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[17] = (Byte)((ThumbLY >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[17] = (Byte)((ThumbLY >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[18] = (Byte)((ThumbRX >> 0) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[19] = (Byte)((ThumbRX >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[19] = (Byte)((ThumbRX >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[20] = (Byte)((ThumbRY >> 0) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[21] = (Byte)((ThumbRY >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,ToBytes,The following statement contains a magic number: input[21] = (Byte)((ThumbRY >> 8) & 0xFF);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLXRaw,The following statement contains a magic number: if (StickLX > 1.0)              {                  return 32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLXRaw,The following statement contains a magic number: if (StickLX < 0.0)              {                  return -32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLXRaw,The following statement contains a magic number: return (Int32)((StickLX-0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLXRaw,The following statement contains a magic number: return (Int32)((StickLX-0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLXRaw,The following statement contains a magic number: return (Int32)((StickLX-0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLYRaw,The following statement contains a magic number: if (StickLY > 1.0)              {                  return 32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLYRaw,The following statement contains a magic number: if (StickLY < 0.0)              {                  return -32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLYRaw,The following statement contains a magic number: return (Int32)((StickLY - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLYRaw,The following statement contains a magic number: return (Int32)((StickLY - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickLYRaw,The following statement contains a magic number: return (Int32)((StickLY - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRXRaw,The following statement contains a magic number: if (StickRX > 1.0)              {                  return 32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRXRaw,The following statement contains a magic number: if (StickRX < 0.0)              {                  return -32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRXRaw,The following statement contains a magic number: return (Int32)((StickRX - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRXRaw,The following statement contains a magic number: return (Int32)((StickRX - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRXRaw,The following statement contains a magic number: return (Int32)((StickRX - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRYRaw,The following statement contains a magic number: if (StickRY > 1.0)              {                  return 32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRYRaw,The following statement contains a magic number: if (StickRY < 0.0)              {                  return -32767;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRYRaw,The following statement contains a magic number: return (Int32)((StickRY - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRYRaw,The following statement contains a magic number: return (Int32)((StickRY - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getStickRYRaw,The following statement contains a magic number: return (Int32)((StickRY - 0.5) * 2 * 32767);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getTriggerLRaw,The following statement contains a magic number: if (TriggerL > 1.0)              {                  return 255;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getTriggerLRaw,The following statement contains a magic number: return (Byte)(TriggerL * 255);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getTriggerRRaw,The following statement contains a magic number: if (TriggerR > 1.0)              {                  return 255;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputReport,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputReport.cs,getTriggerRRaw,The following statement contains a magic number: return (Byte)(TriggerR * 255);
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputDevice,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputDevice.cs,Update,The following statement contains a magic number: Byte[] rumble = new Byte[8];
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputDevice,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputDevice.cs,Update,The following statement contains a magic number: Byte[] report = new Byte[28];
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputDevice,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputDevice.cs,Update,The following statement contains a magic number: if (bus.Report(report' rumble))              {                  if (rumble[1] == 0x08)                  {                      Byte big = (Byte)(rumble[3]);                      Byte small = (Byte)(rumble[4]);                        if (OnRumble != null)                      {                          OnRumble(big' small);                      }                  }                  return true;              }
Magic Number,WiiTUIO.Output.Handlers.Xinput,XinputDevice,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputDevice.cs,Update,The following statement contains a magic number: if (bus.Report(report' rumble))              {                  if (rumble[1] == 0x08)                  {                      Byte big = (Byte)(rumble[3]);                      Byte small = (Byte)(rumble[4]);                        if (OnRumble != null)                      {                          OnRumble(big' small);                      }                  }                  return true;              }
Magic Number,WiiTUIO.WinTouch,HidContactInfo,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\HumanInterfaceDevice.cs,ToBytes,The following statement contains a magic number: using (BinaryWriter pWriter = new BinaryWriter(new MemoryStream(tBuffer)))              {                  pWriter.Seek(2' SeekOrigin.Begin);                  pWriter.Write(X);                  pWriter.Write(Y);                  pWriter.Write(Pressure);                  pWriter.Write(Width);                  pWriter.Write(Height);                  pWriter.Write(Id);              }
Missing Default,WiiTUIO,AboutUC,C:\repos\simphax_Touchmote\WiiTUIO\AboutUC.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.btnAboutBack = ((System.Windows.Controls.Button)(target));                            #line 19 "..\..\AboutUC.xaml"              this.btnAboutBack.Click += new System.Windows.RoutedEventHandler(this.btnAboutBack_Click);                            #line default              #line hidden              return;              case 2:              this.versionLabel = ((System.Windows.Controls.Label)(target));              return;              case 3:                            #line 29 "..\..\AboutUC.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              }
Missing Default,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,reloadState,The following switch statement is missing a default case: switch (inputType)              {                  case InputFactory.InputType.POINTER:                      this.cbiPointer.IsSelected = true;                      break;                  case InputFactory.InputType.PEN:                      this.cbiPen.IsSelected = true;                      break;              }
Missing Default,WiiTUIO,AppSettingsUC,C:\repos\simphax_Touchmote\WiiTUIO\AppSettings.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.btnAppSettingsBack = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\AppSettings.xaml"              this.btnAppSettingsBack.Click += new System.Windows.RoutedEventHandler(this.btnAppSettingsBack_Click);                            #line default              #line hidden              return;              case 3:              this.cbWindowsStart = ((System.Windows.Controls.CheckBox)(target));                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Checked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Checked);                            #line default              #line hidden                            #line 29 "..\..\AppSettings.xaml"              this.cbWindowsStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbWindowsStart_Unchecked);                            #line default              #line hidden              return;              case 4:              this.ModeComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 32 "..\..\AppSettings.xaml"              this.ModeComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ComboBox_SelectionChanged_1);                            #line default              #line hidden              return;              case 5:              this.cbiPointer = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 6:              this.cbiPen = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 7:              this.cbPairOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Checked);                            #line default              #line hidden                            #line 37 "..\..\AppSettings.xaml"              this.cbPairOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbPairOnStart_Unchecked);                            #line default              #line hidden              return;              case 8:              this.cbMinimizeToTray = ((System.Windows.Controls.CheckBox)(target));                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Checked);                            #line default              #line hidden                            #line 38 "..\..\AppSettings.xaml"              this.cbMinimizeToTray.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeToTray_Unchecked);                            #line default              #line hidden              return;              case 9:              this.cbMinimizeOnStart = ((System.Windows.Controls.CheckBox)(target));                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Checked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Checked);                            #line default              #line hidden                            #line 39 "..\..\AppSettings.xaml"              this.cbMinimizeOnStart.Unchecked += new System.Windows.RoutedEventHandler(this.cbMinimizeOnStart_Unchecked);                            #line default              #line hidden              return;              case 10:              this.cbUseCustomCursor = ((System.Windows.Controls.CheckBox)(target));                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Checked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Checked);                            #line default              #line hidden                            #line 40 "..\..\AppSettings.xaml"              this.cbUseCustomCursor.Unchecked += new System.Windows.RoutedEventHandler(this.cbUseCustomCursor_Unchecked);                            #line default              #line hidden              return;              case 11:              this.btnEditKeymaps = ((System.Windows.Controls.Button)(target));                            #line 41 "..\..\AppSettings.xaml"              this.btnEditKeymaps.Click += new System.Windows.RoutedEventHandler(this.btnEditKeymaps_Click);                            #line default              #line hidden              return;              case 12:              this.providerSettingsContent = ((System.Windows.Controls.StackPanel)(target));              return;              }
Missing Default,WiiTUIO,KeymapOutputRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputRow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.mainGrid = ((System.Windows.Controls.Grid)(target));              return;              }
Missing Default,WiiTUIO,KeymapOutputItem,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapOutputItem.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));                            #line 15 "..\..\..\KeymapConfig\KeymapOutputItem.xaml"              this.border.MouseMove += new System.Windows.Input.MouseEventHandler(this.border_MouseMove);                            #line default              #line hidden                            #line 15 "..\..\..\KeymapConfig\KeymapOutputItem.xaml"              this.border.TouchDown += new System.EventHandler<System.Windows.Input.TouchEventArgs>(this.border_TouchDown);                            #line default              #line hidden                            #line 15 "..\..\..\KeymapConfig\KeymapOutputItem.xaml"              this.border.TouchMove += new System.EventHandler<System.Windows.Input.TouchEventArgs>(this.border_TouchMove);                            #line default              #line hidden              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,WiiTUIO,KeymapConnectionRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConnectionRow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.buttonBlup = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.stickBlup = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.cursorBlup = ((System.Windows.Controls.Grid)(target));              return;              case 4:              this.connection_input_border = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.connection_input_name = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.connection_input_config_openbutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 40 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_openbutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_openbutton_MouseUp);                            #line default              #line hidden              return;              case 7:              this.connection_input_config_closebutton = ((System.Windows.Shapes.Rectangle)(target));                            #line 45 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.connection_input_config_closebutton.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.connection_input_config_closebutton_MouseUp);                            #line default              #line hidden              return;              case 8:              this.connection_input_config_border = ((System.Windows.Controls.Border)(target));              return;              case 9:              this.deadzone_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 10:              this.scale_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 11:              this.threshold_updown = ((MahApps.Metro.Controls.NumericUpDown)(target));              return;              case 12:              this.connection_output_stack = ((System.Windows.Controls.StackPanel)(target));              return;              case 13:              this.rAdd = ((System.Windows.Shapes.Rectangle)(target));                            #line 105 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rAdd.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rAdd_MouseUp);                            #line default              #line hidden              return;              case 14:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));                            #line 110 "..\..\..\KeymapConfig\KeymapConnectionRow.xaml"              this.rClear.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.rClear_MouseUp);                            #line default              #line hidden              return;              }
Missing Default,WiiTUIO,KeymapConfigWindow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapConfigWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 2:              this.spLayoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 3:              this.bAddKeymap = ((System.Windows.Controls.Border)(target));                            #line 33 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.bAddKeymap.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.bAddKeymap_MouseUp);                            #line default              #line hidden              return;              case 4:              this.rClear = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.tbKeymapTitle = ((System.Windows.Controls.TextBox)(target));              return;              case 6:              this.tbDelete = ((System.Windows.Controls.TextBlock)(target));                            #line 51 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbDelete.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbDelete_MouseUp);                            #line default              #line hidden              return;              case 7:              this.cbLayoutChooser = ((System.Windows.Controls.CheckBox)(target));              return;              case 8:              this.cbApplicationSearch = ((System.Windows.Controls.CheckBox)(target));              return;              case 9:              this.tbApplicationSearch = ((System.Windows.Controls.TextBox)(target));              return;              case 10:              this.btnAllBorder = ((System.Windows.Controls.Border)(target));              return;              case 11:              this.btnAll = ((System.Windows.Controls.Button)(target));                            #line 63 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btnAll.Click += new System.Windows.RoutedEventHandler(this.btnAll_Click);                            #line default              #line hidden              return;              case 12:              this.btn1Border = ((System.Windows.Controls.Border)(target));              return;              case 13:              this.btn1 = ((System.Windows.Controls.Button)(target));                            #line 66 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn1.Click += new System.Windows.RoutedEventHandler(this.btn1_Click);                            #line default              #line hidden              return;              case 14:              this.btn2Border = ((System.Windows.Controls.Border)(target));              return;              case 15:              this.btn2 = ((System.Windows.Controls.Button)(target));                            #line 69 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn2.Click += new System.Windows.RoutedEventHandler(this.btn2_Click);                            #line default              #line hidden              return;              case 16:              this.btn3Border = ((System.Windows.Controls.Border)(target));              return;              case 17:              this.btn3 = ((System.Windows.Controls.Button)(target));                            #line 72 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn3.Click += new System.Windows.RoutedEventHandler(this.btn3_Click);                            #line default              #line hidden              return;              case 18:              this.btn4Border = ((System.Windows.Controls.Border)(target));              return;              case 19:              this.btn4 = ((System.Windows.Controls.Button)(target));                            #line 75 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.btn4.Click += new System.Windows.RoutedEventHandler(this.btn4_Click);                            #line default              #line hidden              return;              case 20:              this.spWiimoteConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 21:              this.spNunchukConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.spClassicConnections = ((System.Windows.Controls.StackPanel)(target));              return;              case 23:              this.cbOutput = ((System.Windows.Controls.ComboBox)(target));                            #line 93 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.cbOutput.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.cbOutput_SelectionChanged);                            #line default              #line hidden              return;              case 24:              this.cbiAll = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 25:              this.cbiKeyboard = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 26:              this.cbiMouse = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 27:              this.cbiTouch = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 28:              this.cbi360 = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 29:              this.cbiOther = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 30:              this.tbOutputFilter = ((System.Windows.Controls.TextBox)(target));                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.GotFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_GotFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.LostFocus += new System.Windows.RoutedEventHandler(this.tb_placeholder_LostFocus);                            #line default              #line hidden                            #line 101 "..\..\..\KeymapConfig\KeymapConfigWindow.xaml"              this.tbOutputFilter.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.tbOutputFilter_TextChanged);                            #line default              #line hidden              return;              case 31:              this.spOutputList = ((System.Windows.Controls.StackPanel)(target));              return;              }
Missing Default,WiiTUIO,KeymapRow,C:\repos\simphax_Touchmote\WiiTUIO\KeymapConfig\KeymapRow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.tbDefault = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,WiiTUIO,LayoutSelectionRow,C:\repos\simphax_Touchmote\WiiTUIO\LayoutSelectionRow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.border = ((System.Windows.Controls.Border)(target));                            #line 8 "..\..\LayoutSelectionRow.xaml"              this.border.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.tbName_MouseUp);                            #line default              #line hidden              return;              case 2:              this.tbName = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,ShowMessage,The following switch statement is missing a default case: switch (eType)              {                  case MessageType.Error:                      this.tbErrorMsg.Text = message;                      this.animateExpand(this.spErrorMsg);                      break;                  case MessageType.Info:                      this.tbInfoMsg.Text = message;                      this.animateExpand(this.spInfoMsg);                      break;              }
Missing Default,WiiTUIO,MainWindow,C:\repos\simphax_Touchmote\WiiTUIO\MainWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.btnAbout = ((System.Windows.Controls.Button)(target));                            #line 24 "..\..\MainWindow.xaml"              this.btnAbout.Click += new System.Windows.RoutedEventHandler(this.btnAbout_Click);                            #line default              #line hidden              return;              case 2:              this.btnAppSettings = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.btnAppSettings.Click += new System.Windows.RoutedEventHandler(this.btnAppSettings_Click);                            #line default              #line hidden              return;              case 3:              this.mainPanel = ((System.Windows.Controls.StackPanel)(target));              return;              case 4:              this.spErrorMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 42 "..\..\MainWindow.xaml"              this.spErrorMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spErrorMsg_MouseUp);                            #line default              #line hidden              return;              case 5:              this.tbErrorMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.spInfoMsg = ((System.Windows.Controls.StackPanel)(target));                            #line 47 "..\..\MainWindow.xaml"              this.spInfoMsg.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.spInfoMsg_MouseUp);                            #line default              #line hidden              return;              case 7:              this.tbInfoMsg = ((System.Windows.Controls.TextBlock)(target));              return;              case 8:              this.connectedCount = ((System.Windows.Controls.Label)(target));              return;              case 9:              this.statusStack = ((System.Windows.Controls.StackPanel)(target));              return;              case 10:              this.spPairing = ((System.Windows.Controls.StackPanel)(target));              return;              case 11:              this.canvasPairing = ((System.Windows.Controls.Canvas)(target));              return;              case 12:              this.pairWiimoteText = ((System.Windows.Controls.TextBlock)(target));              return;              case 13:              this.pairWiimotePressSync = ((System.Windows.Controls.TextBlock)(target));              return;              case 14:              this.pairWiimoteTryAgain = ((System.Windows.Controls.TextBlock)(target));              return;              case 15:                            #line 72 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).Click += new System.Windows.RoutedEventHandler(this.pairWiimoteTryAgain_Click);                            #line default              #line hidden              return;              case 16:              this.pairWiimoteTRFail = ((System.Windows.Controls.TextBlock)(target));              return;              case 17:                            #line 78 "..\..\MainWindow.xaml"              ((System.Windows.Documents.Hyperlink)(target)).RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.Hyperlink_RequestNavigate);                            #line default              #line hidden              return;              case 18:              this.pairProgress = ((MahApps.Metro.Controls.ProgressRing)(target));              return;              case 19:              this.tbPair2 = ((System.Windows.Controls.TextBlock)(target));                            #line 93 "..\..\MainWindow.xaml"              this.tbPair2.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotes_Click);                            #line default              #line hidden              return;              case 20:              this.tbPairDone = ((System.Windows.Controls.TextBlock)(target));                            #line 96 "..\..\MainWindow.xaml"              this.tbPairDone.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.PairWiimotesDone_Click);                            #line default              #line hidden              return;              case 21:              this.canvasSettings = ((System.Windows.Controls.StackPanel)(target));              return;              case 22:              this.canvasAbout = ((System.Windows.Controls.StackPanel)(target));              return;              }
Missing Default,WiiTUIO,OverlayNotice,C:\repos\simphax_Touchmote\WiiTUIO\OverlayNotice.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.noticeBorder = ((System.Windows.Controls.Border)(target));                            #line 8 "..\..\OverlayNotice.xaml"              this.noticeBorder.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.noticeBorder_MouseUp);                            #line default              #line hidden              return;              case 2:              this.noticeMessage = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,WiiTUIO,OverlayWindow,C:\repos\simphax_Touchmote\WiiTUIO\OverlayWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.baseCanvas = ((System.Windows.Controls.Canvas)(target));              return;              case 2:              this.baseGrid = ((System.Windows.Controls.Grid)(target));                            #line 14 "..\..\OverlayWindow.xaml"              this.baseGrid.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.Grid_MouseUp);                            #line default              #line hidden              return;              case 3:              this.layoutChooserOverlay = ((System.Windows.Controls.Border)(target));              return;              case 4:              this.titleBorder = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.title = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.scrollViewer = ((System.Windows.Controls.ScrollViewer)(target));                            #line 26 "..\..\OverlayWindow.xaml"              this.scrollViewer.MouseUp += new System.Windows.Input.MouseButtonEventHandler(this.layoutChooserOverlay_MouseUp);                            #line default              #line hidden              return;              case 7:              this.layoutList = ((System.Windows.Controls.StackPanel)(target));              return;              case 8:              this.noticeStack = ((System.Windows.Controls.StackPanel)(target));              return;              }
Missing Default,WiiTUIO,WiimoteStatusUC,C:\repos\simphax_Touchmote\WiiTUIO\WiimoteStatus.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.color = ((System.Windows.Shapes.Ellipse)(target));              return;              case 2:              this.lbId = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.lbStatus = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.battery1 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 5:              this.battery2 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 6:              this.battery3 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 7:              this.battery4 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 8:              this.battery5 = ((System.Windows.Shapes.Rectangle)(target));              return;              case 9:              this.battery6 = ((System.Windows.Shapes.Rectangle)(target));              return;              }
Missing Default,WiiTUIO.Output,DrawingProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\DrawingProviderHandler.cs,processEventFrame,The following switch statement is missing a default case: switch (contact.Type)                  {                      case ContactType.Start:                          color = Color.Green;                          break;                      case ContactType.Move:                          color = Color.Yellow;                          break;                      case ContactType.End:                          color = Color.Red;                          break;                  }
Missing Default,WiiTUIO.Output,TUIOSettings,C:\repos\simphax_Touchmote\WiiTUIO\Output\Settings\TUIOSettings.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing_1);                            #line default              #line hidden                            #line 4 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((WiiTUIO.Output.TUIOSettings)(target)).GotFocus += new System.Windows.RoutedEventHandler(this.Window_GotFocus_1);                            #line default              #line hidden              return;              case 2:              this.tbIP = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this.tbPort = ((System.Windows.Controls.TextBox)(target));              return;              case 4:                            #line 11 "..\..\..\..\Output\Settings\TUIOSettings.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.Button_Click_1);                            #line default              #line hidden              return;              }
Missing Default,WiiTUIO.Output.Handlers.Touch,CursorColor,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Touch\CursorColor.cs,randomColor,The following switch statement is missing a default case: switch (kill)              {                  case 0:                      red = 0;                      break;                  case 1:                      green = 0;                      break;                  case 2:                      blue = 0;                      break;              }
Missing Default,WiiTUIO.Provider,Calibrate,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\Calibrate.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.CalibrationPoint = ((System.Windows.Controls.Canvas)(target));              return;              }
Missing Default,WiiTUIO.Provider,CalibrationWindow,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\CalibrationWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 5 "..\..\..\..\..\Input\WiiProvider\Settings\CalibrationWindow.xaml"              ((WiiTUIO.Provider.CalibrationWindow)(target)).KeyUp += new System.Windows.Input.KeyEventHandler(this.Window_KeyUp_1);                            #line default              #line hidden              return;              case 2:              this.CalibrationCanvas = ((WiiTUIO.Provider.Calibrate)(target));              return;              }
Missing Default,WiiTUIO.Provider,ScreenPositionCalculator,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Pointer\ScreenPositionCalculator.cs,CalculateCursorPos,The following switch statement is missing a default case: switch (orientation)                                      {                                          case 0: l = (irState.IRSensors[0].RawPosition.X < irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 1: l = (irState.IRSensors[0].RawPosition.Y > irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                          case 2: l = (irState.IRSensors[0].RawPosition.X > irState.IRSensors[1].RawPosition.X) ? 0 : 1; break;                                          case 3: l = (irState.IRSensors[0].RawPosition.Y < irState.IRSensors[1].RawPosition.Y) ? 0 : 1; break;                                      }
Missing Default,WiiTUIO.Provider,WiiPointerProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.MonitorComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 10 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.MonitorComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.MonitorComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 2:              this.SBPositionComboBox = ((System.Windows.Controls.ComboBox)(target));                            #line 14 "..\..\..\..\..\Input\WiiProvider\Settings\WiiPointerProviderSettings.xaml"              this.SBPositionComboBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.SBPositionComboBox_SelectionChanged);                            #line default              #line hidden              return;              case 3:              this.cbiCenter = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 4:              this.cbiTop = ((System.Windows.Controls.ComboBoxItem)(target));              return;              case 5:              this.cbiBottom = ((System.Windows.Controls.ComboBoxItem)(target));              return;              }
Missing Default,WiiTUIO.Provider,WiiProviderSettings,C:\repos\simphax_Touchmote\WiiTUIO\Input\WiiProvider\Settings\WiiProviderSettings.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.btnCalibrate = ((System.Windows.Controls.Button)(target));                            #line 6 "..\..\..\..\..\Input\WiiProvider\Settings\WiiProviderSettings.xaml"              this.btnCalibrate.Click += new System.Windows.RoutedEventHandler(this.btnCalibrate_Click);                            #line default              #line hidden              return;              }
Missing Default,WiiTUIO.Output.Handlers.Xinput,XinputHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\Handlers\Xinput\XinputHandler.cs,setPosition,The following switch statement is missing a default case: switch (key)                      {                          case "360.stickl":                              report.StickLX = smoothedX;                              report.StickLY = smoothedY;                              break;                          case "360.stickr":                              report.StickRX = smoothedX;                              report.StickRY = smoothedY;                              break;                      }
Missing Default,WiiTUIO.WinTouch,MTVProviderHandler,C:\repos\simphax_Touchmote\WiiTUIO\Output\WinTouch\MTVProviderHandler.cs,processEventFrame,The following switch statement is missing a default case: switch (pContact.Type)                  {                      case ContactType.Start:                          this.enqueueContact(HidContactState.Adding' pContact);                          break;                      case ContactType.Move:                          this.enqueueContact(HidContactState.Updated' pContact);                          break;                      case ContactType.End:                          this.enqueueContact(HidContactState.Removing' pContact);                          break;                  }
