Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,Cyclomatic complexity of the method is 9
Complex Method,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,ReleaseManagedResources,Cyclomatic complexity of the method is 16
Complex Method,Emgu.CV,ConvolutionKernelF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ConvolutionKernelF.cs,Flip,Cyclomatic complexity of the method is 10
Complex Method,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,Cyclomatic complexity of the method is 12
Complex Method,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,Cyclomatic complexity of the method is 12
Complex Method,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,Cyclomatic complexity of the method is 8
Complex Method,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,Cyclomatic complexity of the method is 8
Complex Method,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,Cyclomatic complexity of the method is 22
Complex Method,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,Cyclomatic complexity of the method is 8
Complex Method,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,Cyclomatic complexity of the method is 13
Complex Method,Emgu.CV.Tiff,TiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TiffWriter.cs,WriteImage,Cyclomatic complexity of the method is 8
Complex Method,Emgu.CV.VideoSurveillance,BlobTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BlobTracker.cs,BlobTracker,Cyclomatic complexity of the method is 18
Complex Method,Emgu.CV.VideoSurveillance,BlobTrackPostProc,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BlobTrackPostProc.cs,BlobTrackPostProc,Cyclomatic complexity of the method is 9
Long Parameter List,Emgu.CV,Octree,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Octree.cs,CvOctreeBuildTree,The method has 5 parameters.
Long Parameter List,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,CvHOGDescriptorCreate,The method has 10 parameters.
Long Parameter List,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,CvHOGDescriptorDetectMultiScale,The method has 8 parameters.
Long Parameter List,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,CvHOGDescriptorCompute,The method has 6 parameters.
Long Parameter List,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,HOGDescriptor,The method has 9 parameters.
Long Parameter List,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The method has 6 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindHomography,The method has 6 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindFundamentalMat,The method has 7 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindStereoCorrespondenceGC,The method has 6 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindStereoCorrespondenceGC,The method has 6 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindStereoCorrespondence,The method has 10 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvProjectPoints2,The method has 12 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvCalibrateCamera2,The method has 9 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvCalibrationMatrixValues,The method has 10 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindExtrinsicCameraParams2,The method has 7 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvStereoCalibrate,The method has 15 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvStereoRectifyUncalibrated,The method has 7 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvStereoRectify,The method has 17 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvFindChessboardCorners,The method has 5 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvDrawChessboardCorners,The method has 5 parameters.
Long Parameter List,Emgu.CV,CvInvoke,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvInvokeCalib3d.cs,cvDrawChessboardCorners,The method has 5 parameters.
Long Parameter List,Emgu.CV,StereoSGBM,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\StereoSGBM.cs,CvStereoSGBMCreate,The method has 11 parameters.
Long Parameter List,Emgu.CV,StereoSGBM,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\StereoSGBM.cs,StereoSGBM,The method has 11 parameters.
Long Parameter List,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The method has 6 parameters.
Long Parameter List,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The method has 11 parameters.
Long Parameter List,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,GetIntrinsicMatrixValues,The method has 9 parameters.
Long Parameter List,Emgu.CV,CvException,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CvException.cs,CvException,The method has 5 parameters.
Long Parameter List,Emgu.CV,EigenObjectRecognizer,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\EigenObjectRecognizer.cs,EigenObjectRecognizer,The method has 5 parameters.
Long Parameter List,Emgu.CV,EigenObjectRecognizer,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\EigenObjectRecognizer.cs,CalcEigenObjects,The method has 6 parameters.
Long Parameter List,Emgu.CV,FeatureTree,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\FeatureTree.cs,FindFeatures,The method has 5 parameters.
Long Parameter List,Emgu.CV,FeatureTree,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\FeatureTree.cs,FindFeatures,The method has 5 parameters.
Long Parameter List,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,Kalman,The method has 6 parameters.
Long Parameter List,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,Kalman,The method has 5 parameters.
Long Parameter List,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,PyrLK,The method has 9 parameters.
Long Parameter List,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,PyrLK,The method has 12 parameters.
Long Parameter List,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,LK,The method has 5 parameters.
Long Parameter List,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,HS,The method has 7 parameters.
Long Parameter List,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,BM,The method has 8 parameters.
Long Parameter List,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,Farneback,The method has 11 parameters.
Long Parameter List,Emgu.CV,StructuringElementEx,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\StructuringElementEx.cs,StructuringElementEx,The method has 5 parameters.
Long Parameter List,Emgu.CV,DenseHistogram,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\DenseHistogram.cs,BackProjectPatch,The method has 5 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,DrawPolyline,The method has 7 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The method has 5 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The method has 6 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,DetectHaarCascade,The method has 7 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,HoughLinesBinary,The method has 7 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,HoughLines,The method has 7 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,HoughCircles,The method has 8 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,RoiParam,The method has 6 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Canny,The method has 5 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GoodFeaturesToTrack,The method has 5 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GoodFeaturesToTrack,The method has 8 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,FindCornerSubPix,The method has 6 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Snake,The method has 7 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Snake,The method has 7 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Cmp,The method has 5 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,WarpAffine,The method has 6 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,WarpPerspective,The method has 6 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertColor,The method has 5 parameters.
Long Parameter List,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ThresholdBase,The method has 7 parameters.
Long Parameter List,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Matrix,The method has 5 parameters.
Long Parameter List,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,ColorPaletteToLookupTable,The method has 5 parameters.
Long Parameter List,Emgu.CV,VideoWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoWriter.cs,VideoWriter,The method has 5 parameters.
Long Parameter List,Emgu.CV,VideoWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoWriter.cs,VideoWriter,The method has 6 parameters.
Long Parameter List,Emgu.CV,ZlibCompression,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ZlibCompression.cs,zlibCompress2,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,SIFTDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SIFTDetector.cs,CvSIFTDetectorDetectFeature,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,SIFTDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SIFTDetector.cs,CvSIFTDetectorComputeDescriptors,The method has 6 parameters.
Long Parameter List,Emgu.CV.Features2D,SIFTDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SIFTDetector.cs,CvSIFTDetectorCreate,The method has 9 parameters.
Long Parameter List,Emgu.CV.Features2D,SIFTDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SIFTDetector.cs,SIFTDetector,The method has 9 parameters.
Long Parameter List,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,CvLDetectorDetectKeyPoints,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,CvSURFDetectorDetectFeature,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,CvSURFDetectorComputeDescriptors,The method has 6 parameters.
Long Parameter List,Emgu.CV.Features2D,PlanarObjectDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\PlanarObjectDetector.cs,CvPlanarObjectDetectorTrain,The method has 9 parameters.
Long Parameter List,Emgu.CV.Features2D,PlanarObjectDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\PlanarObjectDetector.cs,Train,The method has 8 parameters.
Long Parameter List,Emgu.CV.Features2D,RTreeClassifierExtern,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\RTreeClassifier.cs,CvRTreeClassifierTrain,The method has 10 parameters.
Long Parameter List,Emgu.CV.Features2D,RTreeClassifierExtern,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\RTreeClassifier.cs,CvRTreeClassifierGetSigniture,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,RTreeClassifier,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\RTreeClassifier.cs,Train,The method has 7 parameters.
Long Parameter List,Emgu.CV.Features2D,SelfSimDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SelfSimDescriptor.cs,CvSelfSimDescriptorCreate,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,SelfSimDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SelfSimDescriptor.cs,CvSelfSimDescriptorCompute,The method has 6 parameters.
Long Parameter List,Emgu.CV.Features2D,SelfSimDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SelfSimDescriptor.cs,SelfSimDescriptor,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,StarDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\StarDetector.cs,StarDetector,The method has 5 parameters.
Long Parameter List,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,MSERDetector,The method has 9 parameters.
Long Parameter List,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,ExtractContours,The method has 5 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,CvFlannIndexCreateKMeans,The method has 5 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,CvFlannIndexCreateComposite,The method has 6 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,CvFlannIndexCreateAutotuned,The method has 5 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,CvFlannIndexKnnSearch,The method has 6 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,CvFlannIndexRadiusSearch,The method has 6 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,Index,The method has 6 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,Index,The method has 5 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,Index,The method has 5 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,KnnSearch,The method has 5 parameters.
Long Parameter List,Emgu.CV.Flann,Index,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index.cs,RadiusSearch,The method has 5 parameters.
Long Parameter List,Emgu.CV.Geodetic,Datum,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Geodetic\Datum.cs,transformGeodetic2ENU,The method has 5 parameters.
Long Parameter List,Emgu.CV.Geodetic,Datum,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Geodetic\Datum.cs,transformENU2Geodetic,The method has 5 parameters.
Long Parameter List,Emgu.CV.Geodetic,Datum,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Geodetic\Datum.cs,transformGeodetic2NED,The method has 5 parameters.
Long Parameter List,Emgu.CV.Geodetic,Datum,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Geodetic\Datum.cs,transformNED2Geodetic,The method has 5 parameters.
Long Identifier,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,Kalman,The length of the parameter measurementNoiseCovarianceMatrix is 32.
Long Identifier,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,Kalman,The length of the parameter measurementNoiseCovarianceMatrix is 32.
Long Statement,Emgu.CV,Contour,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Contour.cs,ApproxPoly,The length of the statement  "	return new Contour<T> (CvInvoke.cvApproxPoly (Ptr' StructSize.MCvContour' storage.Ptr' CvEnum.APPROX_POLY_TYPE.CV_POLY_APPROX_DP' accuracy' maxLevel)' storage); " is 160.
Long Statement,Emgu.CV,PlanarSubdivision,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PlanarSubdivision.cs,Locate,The length of the statement  "	subdiv2DPoint = (vertex == IntPtr.Zero) ? null : (MCvSubdiv2DPoint?)Marshal.PtrToStructure (vertex' typeof(MCvSubdiv2DPoint)); " is 126.
Long Statement,Emgu.CV,PlanarSubdivision,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PlanarSubdivision.cs,GetVoronoiFacets,The length of the statement  "	PlanarSubdivisionGetSubdiv2DPoints (_ptr' pointHandle.AddrOfPinnedObject ()' edgeHandle.AddrOfPinnedObject ()' ref size); " is 121.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The length of the statement  "	Debug.Assert (objectPoints.Length == imagePoints.Length' "The number of images for objects points should be equal to the number of images for image points"); " is 157.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The length of the statement  "		Debug.Assert (objectPoints [i].Length == imagePoints [i].Length' String.Format ("Number of 3D points and image points should be equal in the {0}th image"' i)); " is 159.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The length of the statement  "						reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags); " is 237.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The length of the statement  "	Debug.Assert (objectPoints.Length == imagePoints1.Length && objectPoints.Length == imagePoints2.Length' "The number of images for objects points should be equal to the number of images for image points"); " is 204.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The length of the statement  "		Debug.Assert (objectPoints [i].Length == imagePoints1 [i].Length && objectPoints [i].Length == imagePoints2 [i].Length' String.Format ("Number of 3D points and image points should be equal in the {0}th image"' i)); " is 214.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The length of the statement  "					CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags); " is 394.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindExtrinsicCameraParams2,The length of the statement  "			CvInvoke.cvFindExtrinsicCameraParams2 (objectPointMatrix' imagePointMatrix' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' p.RotationVector.Ptr' p.TranslationVector.Ptr' 0); " is 183.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The length of the statement  "	using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float))) " is 131.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The length of the statement  "		using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float))) " is 135.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The length of the statement  "			CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0); " is 382.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindHomography,The length of the statement  "	if (0 == CvInvoke.cvFindHomography (srcPoints.Ptr' dstPoints.Ptr' homography.Ptr' method' ransacReprojThreshold' IntPtr.Zero)) { " is 128.
Long Statement,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindChessboardCorners,The length of the statement  "	bool patternFound = CvInvoke.cvFindChessboardCorners (image.Ptr' patternSize' handle.AddrOfPinnedObject ()' ref cornerCount' flags) != 0; " is 137.
Long Statement,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,GetIntrinsicMatrixValues,The length of the statement  "	CvInvoke.cvCalibrationMatrixValues (_intrinsicMatrix.Ptr' imgWidth' imgHeight' apertureWidth' apertureHeight' ref fovx' ref fovy' ref focalLength' ref principalPoint' ref pixelAspectRatio); " is 189.
Long Statement,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The length of the statement  "	using (Matrix<float> srcPointMatrix = new Matrix<float> (src.Length' 1' 2' srcHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) " is 127.
Long Statement,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The length of the statement  "		using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) { " is 129.
Long Statement,Emgu.CV,EigenObjectRecognizer,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\EigenObjectRecognizer.cs,EigenDecomposite,The length of the statement  "	return CvInvoke.cvEigenDecomposite (src.Ptr' Array.ConvertAll<Image<Gray' Single>' IntPtr> (eigenImages' delegate (Image<Gray' Single> img) { " is 141.
Long Statement,Emgu.CV,EigenObjectRecognizer,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\EigenObjectRecognizer.cs,EigenProjection,The length of the statement  "	CvInvoke.cvEigenProjection (Array.ConvertAll<Image<Gray' Single>' IntPtr> (_eigenImages' delegate (Image<Gray' Single> img) { " is 125.
Long Statement,Emgu.CV,MotionHistory,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\MotionHistory.cs,GetMotionComponents,The length of the statement  "	Seq<MCvConnectedComp> seq = new Seq<MCvConnectedComp> (CvInvoke.cvSegmentMotion (_mhi' _segMask' storage' ts.TotalSeconds' _maxTimeDelta)' storage); " is 148.
Long Statement,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,PyrLK,The length of the statement  "	PyrLK (prev' curr' null' null' prevFeatures' winSize' level' criteria' Emgu.CV.CvEnum.LKFLOW_TYPE.DEFAULT' out currFeatures' out status' out trackError); " is 153.
Long Statement,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,PyrLK,The length of the statement  "	CvInvoke.cvCalcOpticalFlowPyrLK (prev' curr' prevPyrBufferParam' currPyrBufferParam' prevFeatures' currFeatures' prevFeatures.Length' winSize' level' status' trackError' criteria' flags); " is 187.
Long Statement,Emgu.CV,OpticalFlow,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\OpticalFlow.cs,Farneback,The length of the statement  "		CvInvoke.cvCalcOpticalFlowFarneback (prev0' next0' flow0' pyrScale' levels' winSize' iterations' polyN' polySigma' flags); " is 122.
Long Statement,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotatePoints,The length of the statement  "	Debug.Assert (typeof(TDepth) == typeof(float) || typeof(TDepth) == typeof(Double)' "Only type of double or float is supported"); " is 128.
Long Statement,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotatePoints,The length of the statement  "	Debug.Assert (points.NumberOfChannels == 1 && points.Cols == 2' "The matrix must be a single channel Nx2 matrix where N is the number of points"); " is 146.
Long Statement,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,ApproxPoly,The length of the statement  "	return new Seq<T> (CvInvoke.cvApproxPoly (Ptr' StructSize.MCvContour' stor.Ptr' CvEnum.APPROX_POLY_TYPE.CV_POLY_APPROX_DP' accuracy' maxLevel)' stor); " is 150.
Long Statement,Emgu.CV,ConvolutionKernelF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ConvolutionKernelF.cs,Flip,The length of the statement  "	res.Center = new System.Drawing.Point ((Center.X == -1 ? -1 : ((flipType & Emgu.CV.CvEnum.FLIP.HORIZONTAL) == Emgu.CV.CvEnum.FLIP.HORIZONTAL ? Width - Center.X - 1 : Center.X))' (Center.Y == -1 ? -1 : ((flipType & Emgu.CV.CvEnum.FLIP.VERTICAL) == Emgu.CV.CvEnum.FLIP.VERTICAL ? Height - Center.Y - 1 : Center.Y))); " is 314.
Long Statement,Emgu.CV,DenseHistogram,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\DenseHistogram.cs,InitializeComponent,The length of the statement  "	CvInvoke.cvMakeHistHeaderForArray (cvMatND.dims' Array.ConvertAll<MCvMatND.Dimension' int> (cvMatND.dim' delegate (MCvMatND.Dimension d) { " is 138.
Long Statement,Emgu.CV,DenseHistogram,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\DenseHistogram.cs,BackProjectPatch,The length of the statement  "	Image<Gray' Single> res = new Image<Gray' float> (imgSize.Width - patchSize.Width + 1' imgSize.Height - patchSize.Height + 1); " is 126.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The length of the statement  "	CvInvoke.cvSetData (_ptr' _dataHandle.AddrOfPinnedObject ()' _array.GetLength (1) * _array.GetLength (2) * SizeOfElement); " is 122.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Copy,The length of the statement  "		CvInvoke.cvWarpAffine (Ptr' res.Ptr' rot.Ptr' (int)Emgu.CV.CvEnum.INTER.CV_INTER_LINEAR | (int)Emgu.CV.CvEnum.WARP.CV_WARP_DEFAULT' new MCvScalar ()); " is 150.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The length of the statement  "	CvInvoke.cvRectangle (Ptr' rect.Location' Point.Add (rect.Location' rect.Size)' color.MCvScalar' (thickness <= 0) ? -1 : thickness' CvEnum.LINE_TYPE.EIGHT_CONNECTED' 0); " is 169.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The length of the statement  "		CvInvoke.cvLine (Ptr' Point.Round (line.P1)' Point.Round (line.P2)' color.MCvScalar' thickness' CvEnum.LINE_TYPE.EIGHT_CONNECTED' 0); " is 133.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The length of the statement  "	CvInvoke.cvCircle (Ptr' Point.Round (circle.Center)' (int)circle.Radius' color.MCvScalar' (thickness <= 0) ? -1 : thickness' CvEnum.LINE_TYPE.EIGHT_CONNECTED' 0); " is 162.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The length of the statement  "             0);*/CvInvoke.cvEllipseBox (Ptr' ellipse.MCvBox2D' color.MCvScalar' thickness' Emgu.CV.CvEnum.LINE_TYPE.EIGHT_CONNECTED' 0); " is 124.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Draw,The length of the statement  "	CvInvoke.cvDrawContours (Ptr' c.Ptr' externalColor.MCvScalar' holeColor.MCvScalar' maxLevel' thickness' CvEnum.LINE_TYPE.EIGHT_CONNECTED' offset); " is 146.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,DetectHaarCascade,The length of the statement  "			IntPtr objects = CvInvoke.cvHaarDetectObjects (img.Ptr' haarObj.Ptr' stor.Ptr' scaleFactor' minNeighbors' flag' minSize); " is 121.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,HoughLinesBinary,The length of the statement  "			IntPtr lines = CvInvoke.cvHoughLines2 (img.Ptr' stor.Ptr' CvEnum.HOUGH_TYPE.CV_HOUGH_PROBABILISTIC' rhoResolution' thetaResolution' threshold' minLineWidth' gapBetweenLines); " is 174.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,HoughCircles,The length of the statement  "			IntPtr circlesSeqPtr = CvInvoke.cvHoughCircles (img.Ptr' stor.Ptr' CvEnum.HOUGH_TYPE.CV_HOUGH_GRADIENT' dp' minDist' cannyThresh [channel]' accumulatorThresh [channel]' minRadius' maxRadius); " is 191.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,FindContours,The length of the statement  "	using (Image<TColor' TDepth> imagecopy = Copy ())//since cvFindContours modifies the content of the source' we need to make a clone " is 131.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ExtractSURF,The length of the statement  "		CvInvoke.cvExtractSURF (Ptr' mask == null ? IntPtr.Zero : mask.Ptr' ref keypointsPtr' ref descriptorPtr' stor.Ptr' param' 0); " is 125.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GoodFeaturesToTrack,The length of the statement  "				CvInvoke.cvGoodFeaturesToTrack (img.Ptr' eigImage.Ptr' tmpImage.Ptr' handle.AddrOfPinnedObject ()' ref cornercount' qualityLevel' minDistance' IntPtr.Zero' blockSize' useHarris ? 1 : 0' k); " is 189.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Sample,The length of the statement  "	int size = type == Emgu.CV.CvEnum.CONNECTIVITY.EIGHT_CONNECTED ? Math.Max (Math.Abs (line.P2.X - line.P1.X)' Math.Abs (line.P2.Y - line.P1.Y)) : Math.Abs (line.P2.X - line.P1.X) + Math.Abs (line.P2.Y - line.P1.Y); " is 213.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Resize,The length of the statement  "	return preserveScale ? Resize (Math.Min ((double)width / Width' (double)height / Height)' interpolationType) : Resize (width' height' interpolationType); " is 153.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,WarpPerspective,The length of the statement  "	CvInvoke.cvWarpPerspective (Ptr' res.Ptr' mapMatrix.Ptr' (int)interpolationType | (int)warpType' backgroundColor.MCvScalar); " is 124.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The length of the statement  "			return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background); " is 127.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The length of the statement  "		int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X))); " is 121.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The length of the statement  "		int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X))); " is 121.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The length of the statement  "		int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y))); " is 121.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The length of the statement  "		int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y))); " is 121.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The length of the statement  "		return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background); " is 161.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertColor,The length of the statement  "			throw new NotSupportedException (String.Format ("Convertion from Image<{0}' {1}> to Image<{2}' {3}> is not supported by OpenCV"' srcColor.ToString ()' typeof(TDepth).ToString ()' destColor.ToString ()' typeof(TDepth).ToString ())); " is 231.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,CopyFromBitmap,The length of the statement  "	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' bmp.Size)' System.Drawing.Imaging.ImageLockMode.ReadOnly' bmp.PixelFormat); " is 158.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The length of the statement  "			System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format8bppIndexed); " is 192.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The length of the statement  "			System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 190.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The length of the statement  "		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb); " is 189.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,MorphologyEx,The length of the statement  "	Image<TColor' TDepth> buffer = (operation == Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_GRADIENT) ? new Image<TColor' TDepth> (Size) : null; " is 131.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,MorphologyEx,The length of the statement  "	CvInvoke.cvMorphologyEx (Ptr' res.Ptr' buffer == null ? IntPtr.Zero : buffer.Ptr' element == null ? IntPtr.Zero : element.Ptr' operation' iterations); " is 150.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_MorphologyEx,The length of the statement  "	Image<TColor' TDepth> temp = (operation == Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_GRADIENT || operation == Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_TOPHAT || operation == Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_BLACKHAT) ? CopyBlank () : null; " is 225.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_MorphologyEx,The length of the statement  "	CvInvoke.cvMorphologyEx (Ptr' Ptr' temp == null ? IntPtr.Zero : temp.Ptr' element == null ? IntPtr.Zero : element.Ptr' operation' iterations); " is 142.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Convert,The length of the statement  "	Debug.Assert (Size.Equals (img2.Size) && Size.Equals (img3.Size) && Size.Equals (img4.Size)' "Image size do not match"); " is 120.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Convert,The length of the statement  "	for (int row = 0; row < height1; row++' data1 += step1' data2 += step2' data3 += step3' data4 += step4' data5 += step5) { " is 121.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,SmoothBlur,The length of the statement  "	Emgu.CV.CvEnum.SMOOTH_TYPE type = scale ? Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BLUR : Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BLUR_NO_SCALE; " is 123.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,SmoothBilatral,The length of the statement  "	CvInvoke.cvSmooth (Ptr' res.Ptr' Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BILATERAL' kernelSize' kernelSize' colorSigma' spaceSigma); " is 122.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Convolution,The length of the statement  "	Image<TColor' Single> floatImage = (typeof(TDepth) == typeof(Single)) ? this as Image<TColor' Single> : Convert<TColor' Single> (); " is 131.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,MinMax,The length of the statement  "		CvInvoke.cvMinMaxLoc (Ptr' ref minValues [0]' ref maxValues [0]' ref minLocations [0]' ref maxLocations [0]' IntPtr.Zero); " is 122.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,MinMax,The length of the statement  "			CvInvoke.cvMinMaxLoc (Ptr' ref minValues [i]' ref maxValues [i]' ref minLocations [i]' ref maxLocations [i]' IntPtr.Zero); " is 122.
Long Statement,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The length of the statement  "			CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr); " is 182.
Long Statement,Emgu.CV,ColorConversionCodeLookupTable,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GetColorCvtCode,The length of the statement  "	Dictionary<Type' CvEnum.COLOR_CONVERSION> table = _lookupTable.ContainsKey (srcType) ? _lookupTable [srcType] : (_lookupTable [srcType] = new Dictionary<Type' Emgu.CV.CvEnum.COLOR_CONVERSION> ()); " is 196.
Long Statement,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,Line2DFitting,The length of the statement  "	CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block); " is 185.
Long Statement,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,EllipseLeastSquareFitting,The length of the statement  "	CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block); " is 185.
Long Statement,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,ConvexHull,The length of the statement  "	CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block); " is 185.
Long Statement,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,BoundingRectangle,The length of the statement  "	CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block); " is 185.
Long Statement,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,MinAreaRect,The length of the statement  "	CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block); " is 185.
Long Statement,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,MinEnclosingCircle,The length of the statement  "	CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block); " is 185.
Long Statement,Emgu.CV,Map,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Map.cs,MapPointToImagePoint,The length of the statement  "	return new Point ((int)Math.Round ((pt.x - Area.Left) / Resolution.X)' (int)Math.Round ((pt.y - Area.Top) / Resolution.Y)); " is 123.
Long Statement,Emgu.CV,Map,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Map.cs,MapPointToImagePoint,The length of the statement  "	return new Point ((int)Math.Round ((pt.X - Area.Left) / Resolution.X)' (int)Math.Round ((pt.Y - Area.Top) / Resolution.Y)); " is 123.
Long Statement,Emgu.CV,Map,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Map.cs,MapRectangleToImageRectangle,The length of the statement  "	return new Rectangle (MapPointToImagePoint (rect.Location)' new Size ((int)(rect.Width / Resolution.X)' (int)(rect.Height / Resolution.Y))); " is 140.
Long Statement,Emgu.CV,Map,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Map.cs,ImageRectangleToMapRectangle,The length of the statement  "	return new RectangleF (ImagePointToMapPoint (rect.Location)' new SizeF (rect.Width * Resolution.X' rect.Height * Resolution.Y)); " is 128.
Long Statement,Emgu.CV,Map,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Map.cs,Draw,The length of the statement  "	base.Draw (new Rectangle (MapPointToImagePoint (new PointF (rect.Left + rect.Width / 2.0f' rect.Top + rect.Height / 2.0f))' new Size ((int)(rect.Width / Resolution.X)' (int)(rect.Height / Resolution.Y)))' color' thickness); " is 223.
Long Statement,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Split,The length of the statement  "	CvInvoke.cvSplit (Ptr' channels [0].Ptr' channelCount >= 2 ? channels [1].Ptr : IntPtr.Zero' channelCount >= 3 ? channels [2].Ptr : IntPtr.Zero' channelCount >= 4 ? channels [3].Ptr : IntPtr.Zero); " is 197.
Long Statement,Emgu.CV,ZlibCompression,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ZlibCompression.cs,Compress,The length of the statement  "	zlibCompress2 (resultHandle.AddrOfPinnedObject ()' ref compressDataSize' originalHandle.AddrOfPinnedObject ()' original.Length' compressionLevel); " is 146.
Long Statement,Emgu.CV,ZlibCompression,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ZlibCompression.cs,Uncompress,The length of the statement  "	zlibUncompress (resultHandle.AddrOfPinnedObject ()' ref uncompressDataSize' originalHandle.AddrOfPinnedObject ()' compressedData.Length); " is 137.
Long Statement,Emgu.CV.Structure,Cuboid,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\Cuboid.cs,Contains,The length of the statement  "	return point.x >= Min.x && point.y >= Min.y && point.z >= Min.z && point.x <= Max.x && point.y <= Max.y && point.z <= Max.z; " is 124.
Long Statement,Emgu.CV.Structure,Triangle2DF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Shape\Triangle2DF.cs,Equals,The length of the statement  "	return (V0.Equals (tri.V0) || V0.Equals (tri.V1) || V0.Equals (tri.V2)) && (V1.Equals (tri.V0) || V1.Equals (tri.V1) || V1.Equals (tri.V2)) && (V2.Equals (tri.V0) || V2.Equals (tri.V1) || V2.Equals (tri.V2)); " is 208.
Long Statement,Emgu.CV.Structure,Triangle3DF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Shape\Triangle3DF.cs,Equals,The length of the statement  "	return (V0.Equals (tri.V0) || V0.Equals (tri.V1) || V0.Equals (tri.V2)) && (V1.Equals (tri.V0) || V1.Equals (tri.V1) || V1.Equals (tri.V2)) && (V2.Equals (tri.V0) || V2.Equals (tri.V1) || V2.Equals (tri.V2)); " is 208.
Long Statement,Emgu.CV.Structure,MCvScalar,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvScalar.cs,ToCode,The length of the statement  "	return (language == Emgu.Util.TypeEnum.ProgrammingLanguage.CSharp || language == Emgu.Util.TypeEnum.ProgrammingLanguage.CPlusPlus) ? String.Format ("new MCvScalar({0}' {1}' {2}' {3})"' v0' v1' v2' v3) : ToString (); " is 215.
Long Statement,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The length of the statement  "		float scale = (float)matchedFeatures [i].ObservedFeature.KeyPoint.Size / (float)matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Size; " is 142.
Long Statement,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The length of the statement  "		float rotation = matchedFeatures [i].ObservedFeature.KeyPoint.Angle - matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Angle; " is 133.
Long Statement,Emgu.CV.Features2D,PlanarObjectDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\PlanarObjectDetector.cs,Train,The length of the statement  "	CvPlanarObjectDetectorTrain (Ptr' image' npoints' patchSize' nstructs' structSize' nviews' ref keyPointDetector' ref patchGenerator); " is 133.
Long Statement,Emgu.CV.Features2D,RTreeClassifier,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\RTreeClassifier.cs,Train,The length of the statement  "	RTreeClassifierExtern.CvRTreeClassifierTrain (_ptr' trainImage' handle.AddrOfPinnedObject ()' keypoints.Length' ref rng' numTrees' depth' views' new IntPtr (reducedNumDim)' numQuantBits); " is 187.
Long Statement,Emgu.CV.Features2D,RTreeClassifier,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\RTreeClassifier.cs,GetSigniture,The length of the statement  "	int count = RTreeClassifierExtern.CvRTreeClassifierGetSigniture (_ptr' image' ref keypoint' patchSize' handle.AddrOfPinnedObject ()); " is 133.
Long Statement,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The length of the statement  "		float scale = (float)matchedFeatures [i].ObservedFeature.Point.size / (float)matchedFeatures [i].SimilarFeatures [0].Feature.Point.size; " is 136.
Long Statement,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The length of the statement  "		float rotation = matchedFeatures [i].ObservedFeature.Point.dir - matchedFeatures [i].SimilarFeatures [0].Feature.Point.dir; " is 123.
Long Statement,Emgu.CV.Tiff,TiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TiffWriter.cs,WriteGeoTag,The length of the statement  "	GeodeticCoordinate lowerRight = Datum.WGS84.NED2Geodetic (new MCvPoint3D64f (pixelResolution.x * imageSize.Height' pixelResolution.y * imageSize.Width' 0.0)' originCoordinate); " is 176.
Long Statement,Emgu.CV.Tiff,TiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TiffWriter.cs,WriteGeoTag,The length of the statement  "	MCvPoint3D64f res = new MCvPoint3D64f ((lowerRight.Longitude - originCoordinate.Longitude) * (180.0 / Math.PI) / imageSize.Width' (lowerRight.Latitude - originCoordinate.Latitude) * (180.0 / Math.PI) / imageSize.Height' 0.0); " is 225.
Long Statement,Emgu.CV.Tiff,TileTiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TileTiffWriter.cs,WriteImage,The length of the statement  "			int actualRowLength = ((col + tileSize.Width) <= imageSize.Width) ? tileRowSizeInBytes : (imageSize.Width % tileSize.Width) * sizeOfElement; " is 140.
Long Statement,Emgu.CV.VideoSurveillance,BGStatModel,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BGStatModel.cs,Update,The length of the statement  "		updateFunction = (BGStatModelDelegates.UpdateFunctionDelagate)Marshal.GetDelegateForFunctionPointer (MCvBGStatModel.CvUpdateBGStatModel' typeof(BGStatModelDelegates.UpdateFunctionDelagate)); " is 190.
Long Statement,Emgu.CV.VideoSurveillance,BGStatModel,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BGStatModel.cs,DisposeObject,The length of the statement  "	BGStatModelDelegates.ReleaseFunction releaseFunction = (BGStatModelDelegates.ReleaseFunction)Marshal.GetDelegateForFunctionPointer (MCvBGStatModel.CvReleaseBGStatModel' typeof(BGStatModelDelegates.ReleaseFunction)); " is 215.
Long Statement,Emgu.CV.VideoSurveillance,BlobTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BlobTracker.cs,Add,The length of the statement  "	IntPtr bobPtr = CvInvoke.CvBlobTrackerAddBlob (_ptr' ref blob' currentImage == null ? IntPtr.Zero : currentImage.Ptr' currentForegroundMask); " is 141.
Virtual Method Call from Constructor,Emgu.CV,FeatureTree,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\FeatureTree.cs,FeatureTree,The constructor "FeatureTree" calls a virtual method "Clone".
Virtual Method Call from Constructor,Emgu.CV,FeatureTree,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\FeatureTree.cs,FeatureTree,The constructor "FeatureTree" calls a virtual method "Clone".
Virtual Method Call from Constructor,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,Kalman,The constructor "Kalman" calls a virtual method "Clone".
Virtual Method Call from Constructor,Emgu.CV,Kalman,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Kalman.cs,Kalman,The constructor "Kalman" calls a virtual method "Clone".
Magic Number,Emgu.CV,HomographyMatrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\HomographyMatrix.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMat = new Matrix<float> (points.Length' 1' 2' handle.AddrOfPinnedObject ()' 0))  	using (Matrix<float> homographyMat = Convert<float> ()) {  		CvInvoke.cvPerspectiveTransform (pointMat' pointMat' homographyMat);  	}  
Magic Number,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The following statement contains a magic number: return DetectMultiScale (image' 0' new Size (8' 8)' new Size (32' 32)' 1.05' 2);  
Magic Number,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The following statement contains a magic number: return DetectMultiScale (image' 0' new Size (8' 8)' new Size (32' 32)' 1.05' 2);  
Magic Number,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The following statement contains a magic number: return DetectMultiScale (image' 0' new Size (8' 8)' new Size (32' 32)' 1.05' 2);  
Magic Number,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The following statement contains a magic number: return DetectMultiScale (image' 0' new Size (8' 8)' new Size (32' 32)' 1.05' 2);  
Magic Number,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The following statement contains a magic number: return DetectMultiScale (image' 0' new Size (8' 8)' new Size (32' 32)' 1.05' 2);  
Magic Number,Emgu.CV,HOGDescriptor,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\HOGDescriptor.cs,DetectMultiScale,The following statement contains a magic number: return DetectMultiScale (image' 0' new Size (8' 8)' new Size (32' 32)' 1.05' 2);  
Magic Number,Emgu.CV,RotationVector3D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationVector3D.cs,RotationVector3D,The following statement contains a magic number: Debug.Assert (value.Length == 3' "Rodrigues rotation Vector must have size == 3");  
Magic Number,Emgu.CV,CvArray,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CvArray.cs,ReadXml,The following statement contains a magic number: if (SerializationCompressionRatio == 0) {  	Byte[] bytes = new Byte[size];  	reader.ReadElementContentAsBase64 (bytes' 0' bytes.Length);  	Bytes = bytes;  }  else {  	int extraHeaderBytes = 20000;  	Byte[] bytes = new Byte[size + extraHeaderBytes];  	int countOfBytesRead = reader.ReadElementContentAsBase64 (bytes' 0' bytes.Length);  	Array.Resize<Byte> (ref bytes' countOfBytesRead);  	Bytes = bytes;  }  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = ToMatrix (objectPoints))  	using (Matrix<float> imagePointMatrix = ToMatrix (imagePoints))  		using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts))  			using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  				using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  					reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  					extrinsicParams = new ExtrinsicCameraParameters[imageCount];  					IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  					for (int i = 0; i < imageCount; i++) {  						ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  						CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  						CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  						CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  						CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  						extrinsicParams [i] = p;  					}  					Marshal.FreeHGlobal (matPtr);  				}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = ToMatrix (objectPoints))  	using (Matrix<float> imagePointMatrix = ToMatrix (imagePoints))  		using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts))  			using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  				using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  					reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  					extrinsicParams = new ExtrinsicCameraParameters[imageCount];  					IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  					for (int i = 0; i < imageCount; i++) {  						ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  						CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  						CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  						CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  						CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  						extrinsicParams [i] = p;  					}  					Marshal.FreeHGlobal (matPtr);  				}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = ToMatrix (imagePoints))  	using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts))  		using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  			using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  				reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  				extrinsicParams = new ExtrinsicCameraParameters[imageCount];  				IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  				for (int i = 0; i < imageCount; i++) {  					ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  					CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  					CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  					CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  					CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  					extrinsicParams [i] = p;  				}  				Marshal.FreeHGlobal (matPtr);  			}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = ToMatrix (imagePoints))  	using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts))  		using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  			using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  				reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  				extrinsicParams = new ExtrinsicCameraParameters[imageCount];  				IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  				for (int i = 0; i < imageCount; i++) {  					ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  					CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  					CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  					CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  					CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  					extrinsicParams [i] = p;  				}  				Marshal.FreeHGlobal (matPtr);  			}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts))  	using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  		using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  			reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  			extrinsicParams = new ExtrinsicCameraParameters[imageCount];  			IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  			for (int i = 0; i < imageCount; i++) {  				ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  				CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  				CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  				CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  				CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  				extrinsicParams [i] = p;  			}  			Marshal.FreeHGlobal (matPtr);  		}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts))  	using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  		using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  			reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  			extrinsicParams = new ExtrinsicCameraParameters[imageCount];  			IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  			for (int i = 0; i < imageCount; i++) {  				ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  				CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  				CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  				CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  				CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  				extrinsicParams [i] = p;  			}  			Marshal.FreeHGlobal (matPtr);  		}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  	using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  		reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  		extrinsicParams = new ExtrinsicCameraParameters[imageCount];  		IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  		for (int i = 0; i < imageCount; i++) {  			ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  			CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  			CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  			CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  			CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  			extrinsicParams [i] = p;  		}  		Marshal.FreeHGlobal (matPtr);  	}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<double> rotationVectors = new Matrix<double> (imageCount' 3))  	using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  		reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  		extrinsicParams = new ExtrinsicCameraParameters[imageCount];  		IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  		for (int i = 0; i < imageCount; i++) {  			ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  			CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  			CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  			CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  			CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  			extrinsicParams [i] = p;  		}  		Marshal.FreeHGlobal (matPtr);  	}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,CalibrateCamera,The following statement contains a magic number: using (Matrix<double> translationVectors = new Matrix<double> (imageCount' 3)) {  	reprojectionError = CvInvoke.cvCalibrateCamera2 (objectPointMatrix.Ptr' imagePointMatrix.Ptr' pointCountsMatrix.Ptr' imageSize' intrinsicParam.IntrinsicMatrix' intrinsicParam.DistortionCoeffs' rotationVectors' translationVectors' flags);  	extrinsicParams = new ExtrinsicCameraParameters[imageCount];  	IntPtr matPtr = Marshal.AllocHGlobal (StructSize.MCvMat);  	for (int i = 0; i < imageCount; i++) {  		ExtrinsicCameraParameters p = new ExtrinsicCameraParameters ();  		CvInvoke.cvGetRow (rotationVectors.Ptr' matPtr' i);  		CvInvoke.cvTranspose (matPtr' p.RotationVector.Ptr);  		CvInvoke.cvGetRow (translationVectors.Ptr' matPtr' i);  		CvInvoke.cvTranspose (matPtr' p.TranslationVector.Ptr);  		extrinsicParams [i] = p;  	}  	Marshal.FreeHGlobal (matPtr);  }  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = ToMatrix (objectPoints))  	using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  		using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  			using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  				extrinsicParams = new ExtrinsicCameraParameters ();  				essentialMatrix = new Matrix<double> (3' 3);  				foundamentalMatrix = new Matrix<double> (3' 3);  				CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  			}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = ToMatrix (objectPoints))  	using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  		using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  			using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  				extrinsicParams = new ExtrinsicCameraParameters ();  				essentialMatrix = new Matrix<double> (3' 3);  				foundamentalMatrix = new Matrix<double> (3' 3);  				CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  			}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = ToMatrix (objectPoints))  	using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  		using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  			using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  				extrinsicParams = new ExtrinsicCameraParameters ();  				essentialMatrix = new Matrix<double> (3' 3);  				foundamentalMatrix = new Matrix<double> (3' 3);  				CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  			}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = ToMatrix (objectPoints))  	using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  		using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  			using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  				extrinsicParams = new ExtrinsicCameraParameters ();  				essentialMatrix = new Matrix<double> (3' 3);  				foundamentalMatrix = new Matrix<double> (3' 3);  				CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  			}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  	using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  		using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  			extrinsicParams = new ExtrinsicCameraParameters ();  			essentialMatrix = new Matrix<double> (3' 3);  			foundamentalMatrix = new Matrix<double> (3' 3);  			CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  		}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  	using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  		using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  			extrinsicParams = new ExtrinsicCameraParameters ();  			essentialMatrix = new Matrix<double> (3' 3);  			foundamentalMatrix = new Matrix<double> (3' 3);  			CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  		}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  	using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  		using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  			extrinsicParams = new ExtrinsicCameraParameters ();  			essentialMatrix = new Matrix<double> (3' 3);  			foundamentalMatrix = new Matrix<double> (3' 3);  			CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  		}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix1 = ToMatrix (imagePoints1))  	using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  		using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  			extrinsicParams = new ExtrinsicCameraParameters ();  			essentialMatrix = new Matrix<double> (3' 3);  			foundamentalMatrix = new Matrix<double> (3' 3);  			CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  		}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  	using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  		extrinsicParams = new ExtrinsicCameraParameters ();  		essentialMatrix = new Matrix<double> (3' 3);  		foundamentalMatrix = new Matrix<double> (3' 3);  		CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  	}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  	using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  		extrinsicParams = new ExtrinsicCameraParameters ();  		essentialMatrix = new Matrix<double> (3' 3);  		foundamentalMatrix = new Matrix<double> (3' 3);  		CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  	}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  	using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  		extrinsicParams = new ExtrinsicCameraParameters ();  		essentialMatrix = new Matrix<double> (3' 3);  		foundamentalMatrix = new Matrix<double> (3' 3);  		CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  	}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<float> imagePointMatrix2 = ToMatrix (imagePoints2))  	using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  		extrinsicParams = new ExtrinsicCameraParameters ();  		essentialMatrix = new Matrix<double> (3' 3);  		foundamentalMatrix = new Matrix<double> (3' 3);  		CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  	}  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  	extrinsicParams = new ExtrinsicCameraParameters ();  	essentialMatrix = new Matrix<double> (3' 3);  	foundamentalMatrix = new Matrix<double> (3' 3);  	CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  }  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  	extrinsicParams = new ExtrinsicCameraParameters ();  	essentialMatrix = new Matrix<double> (3' 3);  	foundamentalMatrix = new Matrix<double> (3' 3);  	CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  }  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  	extrinsicParams = new ExtrinsicCameraParameters ();  	essentialMatrix = new Matrix<double> (3' 3);  	foundamentalMatrix = new Matrix<double> (3' 3);  	CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  }  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: using (Matrix<int> pointCountsMatrix = new Matrix<int> (pointCounts)) {  	extrinsicParams = new ExtrinsicCameraParameters ();  	essentialMatrix = new Matrix<double> (3' 3);  	foundamentalMatrix = new Matrix<double> (3' 3);  	CvInvoke.cvStereoCalibrate (objectPointMatrix.Ptr' imagePointMatrix1.Ptr' imagePointMatrix2.Ptr' pointCountsMatrix.Ptr' intrinsicParam1.IntrinsicMatrix' intrinsicParam1.DistortionCoeffs' intrinsicParam2.IntrinsicMatrix' intrinsicParam2.DistortionCoeffs' imageSize' extrinsicParams.RotationVector' extrinsicParams.TranslationVector' essentialMatrix.Ptr' foundamentalMatrix.Ptr' termCrit' flags);  }  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: essentialMatrix = new Matrix<double> (3' 3);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: essentialMatrix = new Matrix<double> (3' 3);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: foundamentalMatrix = new Matrix<double> (3' 3);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,StereoCalibrate,The following statement contains a magic number: foundamentalMatrix = new Matrix<double> (3' 3);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindExtrinsicCameraParams2,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = new Matrix<float> (objectPoints.Length' 3' handle1.AddrOfPinnedObject ()))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 2' handle2.AddrOfPinnedObject ()))  		CvInvoke.cvFindExtrinsicCameraParams2 (objectPointMatrix' imagePointMatrix' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' p.RotationVector.Ptr' p.TranslationVector.Ptr' 0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindExtrinsicCameraParams2,The following statement contains a magic number: using (Matrix<float> objectPointMatrix = new Matrix<float> (objectPoints.Length' 3' handle1.AddrOfPinnedObject ()))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 2' handle2.AddrOfPinnedObject ()))  		CvInvoke.cvFindExtrinsicCameraParams2 (objectPointMatrix' imagePointMatrix' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' p.RotationVector.Ptr' p.TranslationVector.Ptr' 0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindExtrinsicCameraParams2,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 2' handle2.AddrOfPinnedObject ()))  	CvInvoke.cvFindExtrinsicCameraParams2 (objectPointMatrix' imagePointMatrix' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' p.RotationVector.Ptr' p.TranslationVector.Ptr' 0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> pointMatrix = new Matrix<float> (objectPoints.Length' 1' 3' handle1.AddrOfPinnedObject ()' 3 * sizeof(float)))  	using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  		CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: using (Matrix<float> imagePointMatrix = new Matrix<float> (imagePoints.Length' 1' 2' handle2.AddrOfPinnedObject ()' 2 * sizeof(float)))  	CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,ProjectPoints,The following statement contains a magic number: CvInvoke.cvProjectPoints2 (pointMatrix' extrin.RotationVector.Ptr' extrin.TranslationVector.Ptr' intrin.IntrinsicMatrix.Ptr' intrin.DistortionCoeffs.Ptr' imagePointMatrix' matsLength > 0 ? mats [0] : IntPtr.Zero' matsLength > 1 ? mats [1] : IntPtr.Zero' matsLength > 2 ? mats [2] : IntPtr.Zero' matsLength > 3 ? mats [3] : IntPtr.Zero' matsLength > 4 ? mats [4] : IntPtr.Zero' 0.0);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindHomography,The following statement contains a magic number: using (Matrix<float> srcPointMatrix = new Matrix<float> (srcPoints.Length' 2' srcHandle.AddrOfPinnedObject ()))  	using (Matrix<float> dstPointMatrix = new Matrix<float> (dstPoints.Length' 2' dstHandle.AddrOfPinnedObject ()))  		homography = FindHomography (srcPointMatrix' dstPointMatrix' method' ransacReprojThreshold);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindHomography,The following statement contains a magic number: using (Matrix<float> srcPointMatrix = new Matrix<float> (srcPoints.Length' 2' srcHandle.AddrOfPinnedObject ()))  	using (Matrix<float> dstPointMatrix = new Matrix<float> (dstPoints.Length' 2' dstHandle.AddrOfPinnedObject ()))  		homography = FindHomography (srcPointMatrix' dstPointMatrix' method' ransacReprojThreshold);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,FindHomography,The following statement contains a magic number: using (Matrix<float> dstPointMatrix = new Matrix<float> (dstPoints.Length' 2' dstHandle.AddrOfPinnedObject ()))  	homography = FindHomography (srcPointMatrix' dstPointMatrix' method' ransacReprojThreshold);  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,GetAffineTransform,The following statement contains a magic number: Debug.Assert (src.Length >= 3' "The source should contain at least 3 points");  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,GetAffineTransform,The following statement contains a magic number: Debug.Assert (dest.Length >= 3' "The destination should contain at least 3 points");  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,GetPerspectiveTransform,The following statement contains a magic number: Debug.Assert (src.Length >= 4' "The source should contain at least 4 points");  
Magic Number,Emgu.CV,CameraCalibration,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\CameraCalibration.cs,GetPerspectiveTransform,The following statement contains a magic number: Debug.Assert (dest.Length >= 4' "The destination should contain at least 4 points");  
Magic Number,Emgu.CV,ExtrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\ExtrinsicCameraParameters.cs,ExtrinsicCameraParameters,The following statement contains a magic number: TranslationVector = new Matrix<double> (3' 1);  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,IntrinsicCameraParameters,The following statement contains a magic number: IntrinsicMatrix = new Matrix<double> (3' 3);  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,IntrinsicCameraParameters,The following statement contains a magic number: IntrinsicMatrix = new Matrix<double> (3' 3);  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,IntrinsicCameraParameters,The following statement contains a magic number: DistortionCoeffs = new Matrix<double> (5' 1);  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The following statement contains a magic number: using (Matrix<float> srcPointMatrix = new Matrix<float> (src.Length' 1' 2' srcHandle.AddrOfPinnedObject ()' 2 * sizeof(float)))  	using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) {  		CvInvoke.cvUndistortPoints (srcPointMatrix' dstPointMatrix' _intrinsicMatrix.Ptr' _distortionCoeffs.Ptr' R' P);  	}  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The following statement contains a magic number: using (Matrix<float> srcPointMatrix = new Matrix<float> (src.Length' 1' 2' srcHandle.AddrOfPinnedObject ()' 2 * sizeof(float)))  	using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) {  		CvInvoke.cvUndistortPoints (srcPointMatrix' dstPointMatrix' _intrinsicMatrix.Ptr' _distortionCoeffs.Ptr' R' P);  	}  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The following statement contains a magic number: using (Matrix<float> srcPointMatrix = new Matrix<float> (src.Length' 1' 2' srcHandle.AddrOfPinnedObject ()' 2 * sizeof(float)))  	using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) {  		CvInvoke.cvUndistortPoints (srcPointMatrix' dstPointMatrix' _intrinsicMatrix.Ptr' _distortionCoeffs.Ptr' R' P);  	}  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The following statement contains a magic number: using (Matrix<float> srcPointMatrix = new Matrix<float> (src.Length' 1' 2' srcHandle.AddrOfPinnedObject ()' 2 * sizeof(float)))  	using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) {  		CvInvoke.cvUndistortPoints (srcPointMatrix' dstPointMatrix' _intrinsicMatrix.Ptr' _distortionCoeffs.Ptr' R' P);  	}  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The following statement contains a magic number: using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) {  	CvInvoke.cvUndistortPoints (srcPointMatrix' dstPointMatrix' _intrinsicMatrix.Ptr' _distortionCoeffs.Ptr' R' P);  }  
Magic Number,Emgu.CV,IntrinsicCameraParameters,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\IntrinsicCameraParameters.cs,Undistort,The following statement contains a magic number: using (Matrix<float> dstPointMatrix = new Matrix<float> (dst.Length' 1' 2' dstHandle.AddrOfPinnedObject ()' 2 * sizeof(float))) {  	CvInvoke.cvUndistortPoints (srcPointMatrix' dstPointMatrix' _intrinsicMatrix.Ptr' _distortionCoeffs.Ptr' R' P);  }  
Magic Number,Emgu.CV,MotionHistory,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\MotionHistory.cs,Update,The following statement contains a magic number: CvInvoke.cvCalcMotionGradient (_mhi.Ptr' _mask.Ptr' _orientation.Ptr' _maxTimeDelta' _minTimeDelta' 3);  
Magic Number,Emgu.CV,MotionHistory,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\MotionHistory.cs,MotionInfo,The following statement contains a magic number: angle = 360.0 - angle;  
Magic Number,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotatePoints,The following statement contains a magic number: using (Matrix<double> mat = new Matrix<double> (points.Length' 2' handle.AddrOfPinnedObject ()))  	RotatePoints (mat);  
Magic Number,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotatePoints,The following statement contains a magic number: using (Matrix<float> mat = new Matrix<float> (points.Length' 2' handle.AddrOfPinnedObject ()))  	RotatePoints (mat);  
Magic Number,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotateLines,The following statement contains a magic number: using (Matrix<float> mat = new Matrix<float> (lineSegments.Length * 2' 2' handle.AddrOfPinnedObject ()))  	RotatePoints (mat);  
Magic Number,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotateLines,The following statement contains a magic number: using (Matrix<float> mat = new Matrix<float> (lineSegments.Length * 2' 2' handle.AddrOfPinnedObject ()))  	RotatePoints (mat);  
Magic Number,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotatePoints,The following statement contains a magic number: Debug.Assert (points.NumberOfChannels == 1 && points.Cols == 2' "The matrix must be a single channel Nx2 matrix where N is the number of points");  
Magic Number,Emgu.CV,RotationMatrix2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\CameraCalibration\RotationMatrix2D.cs,RotatePoints,The following statement contains a magic number: using (Matrix<TDepth> tmp = new Matrix<TDepth> (points.Rows' 3)) {  	CvInvoke.cvCopyMakeBorder (points' tmp' Point.Empty' Emgu.CV.CvEnum.BORDER_TYPE.CONSTANT' new MCvScalar (1.0));  	Matrix<TDepth> rotationMatrix = this as Matrix<TDepth> ?? Convert<TDepth> ();  	CvInvoke.cvGEMM (tmp' rotationMatrix' 1.0' IntPtr.Zero' 0.0' points' Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_B_T);  	if (!Object.ReferenceEquals (rotationMatrix' this))  		rotationMatrix.Dispose ();  }  
Magic Number,Emgu.CV,Capture,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Capture\Capture.cs,QueryGrayFrame,The following statement contains a magic number: if (iplImage.nChannels == 3) {  	//if the image captured is Bgr' convert it to Grayscale  	res = new Image<Gray' Byte> (iplImage.width' iplImage.height);  	CvInvoke.cvCvtColor (img' res.Ptr' Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2GRAY);  }  else {  	res = new Image<Gray' byte> (iplImage.width' iplImage.height' iplImage.widthStep' iplImage.imageData);  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: if (elementType == typeof(PointF)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2);  }  else if (elementType == typeof(Point)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32S' 2);  }  else if (elementType == typeof(MCvPoint2D64f)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  }  else {  	// if no match found simply return the original value  	return seqType;  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: if (elementType == typeof(PointF)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2);  }  else if (elementType == typeof(Point)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32S' 2);  }  else if (elementType == typeof(MCvPoint2D64f)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  }  else {  	// if no match found simply return the original value  	return seqType;  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: if (elementType == typeof(PointF)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2);  }  else if (elementType == typeof(Point)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32S' 2);  }  else if (elementType == typeof(MCvPoint2D64f)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  }  else {  	// if no match found simply return the original value  	return seqType;  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2);  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: if (elementType == typeof(Point)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32S' 2);  }  else if (elementType == typeof(MCvPoint2D64f)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  }  else {  	// if no match found simply return the original value  	return seqType;  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: if (elementType == typeof(Point)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32S' 2);  }  else if (elementType == typeof(MCvPoint2D64f)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  }  else {  	// if no match found simply return the original value  	return seqType;  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32S' 2);  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: if (elementType == typeof(MCvPoint2D64f)) {  	elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  }  else {  	// if no match found simply return the original value  	return seqType;  }  
Magic Number,Emgu.CV,Seq,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Seq.cs,FixElementType,The following statement contains a magic number: elementTypeID = CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_64F' 2);  
Magic Number,Emgu.CV,ConvolutionKernelF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ConvolutionKernelF.cs,ConvolutionKernelF,The following statement contains a magic number: if (rows == 1 || cols == 1) {  	float['] data = new float[Math.Max (2' rows)' Math.Max (2' cols)];  	for (int i = 0; i < rows; i++)  		for (int j = 0; j < cols; j++)  			data [i' j] = kernel [i' j];  	Data = data;  }  else {  	Data = kernel;  }  
Magic Number,Emgu.CV,ConvolutionKernelF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\ConvolutionKernelF.cs,ConvolutionKernelF,The following statement contains a magic number: if (rows == 1 || cols == 1) {  	float['] data = new float[Math.Max (2' rows)' Math.Max (2' cols)];  	for (int i = 0; i < rows; i++)  		for (int j = 0; j < cols; j++)  			data [i' j] = kernel [i' j];  	Data = data;  }  else {  	Data = kernel;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,LoadImageUsingOpenCV,The following statement contains a magic number: if (typeof(TColor) == typeof(Gray))//TColor type is gray' load the image as grayscale   {  	ptr = CvInvoke.cvLoadImage (file.FullName' CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_GRAYSCALE);  	size = CvInvoke.cvGetSize (ptr);  }  else//color type is not gray   {  	//load the image as Bgr color  	ptr = CvInvoke.cvLoadImage (file.FullName' CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_COLOR);  	if (ptr == IntPtr.Zero)  		throw new NullReferenceException (String.Format ("Unable to load image from file \"{0}\"."' file.FullName));  	MIplImage mptr = (MIplImage)Marshal.PtrToStructure (ptr' typeof(MIplImage));  	size = new Size (mptr.width' mptr.height);  	if (typeof(TColor) != typeof(Bgr))//TColor type is not Bgr' a conversion is required  	 {  		IntPtr tmp = CvInvoke.cvCreateImage (size' (CvEnum.IPL_DEPTH)mptr.depth' 3);  		CvInvoke.cvCvtColor (ptr' tmp' ColorConversionCodeLookupTable.GetColorCvtCode (typeof(Bgr)' typeof(TColor)));  		CvInvoke.cvReleaseImage (ref ptr);  		ptr = tmp;  	}  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,LoadImageUsingOpenCV,The following statement contains a magic number: if (typeof(TColor) != typeof(Bgr))//TColor type is not Bgr' a conversion is required   {  	IntPtr tmp = CvInvoke.cvCreateImage (size' (CvEnum.IPL_DEPTH)mptr.depth' 3);  	CvInvoke.cvCvtColor (ptr' tmp' ColorConversionCodeLookupTable.GetColorCvtCode (typeof(Bgr)' typeof(TColor)));  	CvInvoke.cvReleaseImage (ref ptr);  	ptr = tmp;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: Debug.Assert (MIplImage.align == 4' "Only 4 align is supported at this moment");  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: if (typeof(TDepth) == typeof(Byte) && (cols & 3) != 0) {  	//if the managed data isn't 4 aligned' make it so  	_array = new TDepth[rows' (cols & (~3)) + 4' numberOfChannels];  }  else {  	_array = new TDepth[rows' cols' numberOfChannels];  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: if (typeof(TDepth) == typeof(Byte) && (cols & 3) != 0) {  	//if the managed data isn't 4 aligned' make it so  	_array = new TDepth[rows' (cols & (~3)) + 4' numberOfChannels];  }  else {  	_array = new TDepth[rows' cols' numberOfChannels];  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: if (typeof(TDepth) == typeof(Byte) && (cols & 3) != 0) {  	//if the managed data isn't 4 aligned' make it so  	_array = new TDepth[rows' (cols & (~3)) + 4' numberOfChannels];  }  else {  	_array = new TDepth[rows' cols' numberOfChannels];  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: _array = new TDepth[rows' (cols & (~3)) + 4' numberOfChannels];  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: _array = new TDepth[rows' (cols & (~3)) + 4' numberOfChannels];  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,AllocateData,The following statement contains a magic number: CvInvoke.cvSetData (_ptr' _dataHandle.AddrOfPinnedObject ()' _array.GetLength (1) * _array.GetLength (2) * SizeOfElement);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: if (NumberOfChannels == 1) {  	//if this image only have a single channel  	CvInvoke.cvCopy (channels [0].Ptr' Ptr' IntPtr.Zero);  }  else {  	int channelsCount = channels.Length;  	CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: if (NumberOfChannels == 1) {  	//if this image only have a single channel  	CvInvoke.cvCopy (channels [0].Ptr' Ptr' IntPtr.Zero);  }  else {  	int channelsCount = channels.Length;  	CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: if (NumberOfChannels == 1) {  	//if this image only have a single channel  	CvInvoke.cvCopy (channels [0].Ptr' Ptr' IntPtr.Zero);  }  else {  	int channelsCount = channels.Length;  	CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: if (NumberOfChannels == 1) {  	//if this image only have a single channel  	CvInvoke.cvCopy (channels [0].Ptr' Ptr' IntPtr.Zero);  }  else {  	int channelsCount = channels.Length;  	CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Image,The following statement contains a magic number: CvInvoke.cvMerge (channelsCount > 0 ? channels [0].Ptr : IntPtr.Zero' channelsCount > 1 ? channels [1].Ptr : IntPtr.Zero' channelsCount > 2 ? channels [2].Ptr : IntPtr.Zero' channelsCount > 3 ? channels [3].Ptr : IntPtr.Zero' Ptr);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,DetectHaarCascade,The following statement contains a magic number: return DetectHaarCascade (haarObj' 1.1' 3' CvEnum.HAAR_DETECTION_TYPE.DO_CANNY_PRUNING' new Size (0' 0));  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,DetectHaarCascade,The following statement contains a magic number: return DetectHaarCascade (haarObj' 1.1' 3' CvEnum.HAAR_DETECTION_TYPE.DO_CANNY_PRUNING' new Size (0' 0));  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,RoiParam,The following statement contains a magic number: if (ipl.roi != IntPtr.Zero) {  	Rectangle rec = CvInvoke.cvGetImageROI (ptr);  	elementCount = rec.Width * ipl.nChannels;  	byteWidth = ((int)ipl.depth >> 3) * elementCount;  	start += rec.Y * widthStep + ((int)ipl.depth >> 3) * rec.X;  	rows = rec.Height;  }  else {  	byteWidth = widthStep;  	elementCount = ipl.width * ipl.nChannels;  	rows = ipl.height;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,RoiParam,The following statement contains a magic number: if (ipl.roi != IntPtr.Zero) {  	Rectangle rec = CvInvoke.cvGetImageROI (ptr);  	elementCount = rec.Width * ipl.nChannels;  	byteWidth = ((int)ipl.depth >> 3) * elementCount;  	start += rec.Y * widthStep + ((int)ipl.depth >> 3) * rec.X;  	rows = rec.Height;  }  else {  	byteWidth = widthStep;  	elementCount = ipl.width * ipl.nChannels;  	rows = ipl.height;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,RoiParam,The following statement contains a magic number: byteWidth = ((int)ipl.depth >> 3) * elementCount;  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,RoiParam,The following statement contains a magic number: start += rec.Y * widthStep + ((int)ipl.depth >> 3) * rec.X;  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Canny,The following statement contains a magic number: CvInvoke.cvCanny (src' dest' t1 [channel]' t2 [channel]' 3);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ExtractSURF,The following statement contains a magic number: using (MemStorage stor = new MemStorage ()) {  	IntPtr descriptorPtr = new IntPtr ();  	IntPtr keypointsPtr = new IntPtr ();  	CvInvoke.cvExtractSURF (Ptr' mask == null ? IntPtr.Zero : mask.Ptr' ref keypointsPtr' ref descriptorPtr' stor.Ptr' param' 0);  	Seq<MCvSURFPoint> keypoints = new Seq<MCvSURFPoint> (keypointsPtr' stor);  	MCvSURFPoint[] surfPoints = keypoints.ToArray ();  	SURFFeature[] res = new SURFFeature[surfPoints.Length];  	int elementsInDescriptor = param.extended == 0 ? 64 : 128;  	for (int i = 0; i < res.Length; i++) {  		float[] descriptor = new float[elementsInDescriptor];  		Marshal.Copy (CvInvoke.cvGetSeqElem (descriptorPtr' i)' descriptor' 0' elementsInDescriptor);  		res [i] = new SURFFeature (ref surfPoints [i]' descriptor);  	}  	return res;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ExtractSURF,The following statement contains a magic number: using (MemStorage stor = new MemStorage ()) {  	IntPtr descriptorPtr = new IntPtr ();  	IntPtr keypointsPtr = new IntPtr ();  	CvInvoke.cvExtractSURF (Ptr' mask == null ? IntPtr.Zero : mask.Ptr' ref keypointsPtr' ref descriptorPtr' stor.Ptr' param' 0);  	Seq<MCvSURFPoint> keypoints = new Seq<MCvSURFPoint> (keypointsPtr' stor);  	MCvSURFPoint[] surfPoints = keypoints.ToArray ();  	SURFFeature[] res = new SURFFeature[surfPoints.Length];  	int elementsInDescriptor = param.extended == 0 ? 64 : 128;  	for (int i = 0; i < res.Length; i++) {  		float[] descriptor = new float[elementsInDescriptor];  		Marshal.Copy (CvInvoke.cvGetSeqElem (descriptorPtr' i)' descriptor' 0' elementsInDescriptor);  		res [i] = new SURFFeature (ref surfPoints [i]' descriptor);  	}  	return res;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GrabCut,The following statement contains a magic number: using (Matrix<double> bgdModel = new Matrix<double> (1' 13 * 5))  	using (Matrix<double> fgdModel = new Matrix<double> (1' 13 * 5)) {  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' 0' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT);  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' iteration' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL);  	}  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GrabCut,The following statement contains a magic number: using (Matrix<double> bgdModel = new Matrix<double> (1' 13 * 5))  	using (Matrix<double> fgdModel = new Matrix<double> (1' 13 * 5)) {  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' 0' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT);  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' iteration' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL);  	}  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GrabCut,The following statement contains a magic number: using (Matrix<double> bgdModel = new Matrix<double> (1' 13 * 5))  	using (Matrix<double> fgdModel = new Matrix<double> (1' 13 * 5)) {  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' 0' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT);  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' iteration' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL);  	}  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GrabCut,The following statement contains a magic number: using (Matrix<double> bgdModel = new Matrix<double> (1' 13 * 5))  	using (Matrix<double> fgdModel = new Matrix<double> (1' 13 * 5)) {  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' 0' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT);  		CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' iteration' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL);  	}  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GrabCut,The following statement contains a magic number: using (Matrix<double> fgdModel = new Matrix<double> (1' 13 * 5)) {  	CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' 0' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT);  	CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' iteration' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,GrabCut,The following statement contains a magic number: using (Matrix<double> fgdModel = new Matrix<double> (1' 13 * 5)) {  	CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' 0' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT);  	CvInvoke.CvGrabCut (Ptr' mask.Ptr' ref rect' bgdModel' fgdModel' iteration' Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: using (RotationMatrix2D<float> rotationMatrix = new RotationMatrix2D<float> (center' -angle' 1)) {  	if (crop)  		return WarpAffine (rotationMatrix' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  	PointF[] corners = new PointF[] {  		new PointF (0' 0)'  		new PointF (size.Width - 1' 0)'  		new PointF (size.Width - 1' size.Height - 1)'  		new PointF (0' size.Height - 1)  	};  	rotationMatrix.RotatePoints (corners);  	int minX = (int)Math.Round (Math.Min (Math.Min (corners [0].X' corners [1].X)' Math.Min (corners [2].X' corners [3].X)));  	int maxX = (int)Math.Round (Math.Max (Math.Max (corners [0].X' corners [1].X)' Math.Max (corners [2].X' corners [3].X)));  	int minY = (int)Math.Round (Math.Min (Math.Min (corners [0].Y' corners [1].Y)' Math.Min (corners [2].Y' corners [3].Y)));  	int maxY = (int)Math.Round (Math.Max (Math.Max (corners [0].Y' corners [1].Y)' Math.Max (corners [2].Y' corners [3].Y)));  	rotationMatrix [0' 2] -= minX;  	rotationMatrix [1' 2] -= minY;  	return WarpAffine (rotationMatrix' maxX - minX + 1' maxY - minY + 1' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC' Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' background);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: rotationMatrix [0' 2] -= minX;  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Rotate,The following statement contains a magic number: rotationMatrix [1' 2] -= minY;  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (typeof(TColor) == typeof(TSrcColor)) {  	#region same color  	if (typeof(TDepth) == typeof(TSrcDepth)) {  		//same depth  		CvInvoke.cvCopy (srcImage.Ptr' Ptr' IntPtr.Zero);  	}  	else {  		//different depth  		//int channelCount = NumberOfChannels;  		{  			if (typeof(TDepth) == typeof(Byte) && typeof(TSrcDepth) != typeof(Byte)) {  				double[] minVal' maxVal;  				Point[] minLoc' maxLoc;  				srcImage.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				double min = minVal [0];  				double max = maxVal [0];  				for (int i = 1; i < minVal.Length; i++) {  					min = Math.Min (min' minVal [i]);  					max = Math.Max (max' maxVal [i]);  				}  				double scale = 1.0' shift = 0.0;  				if (max > 255.0 || min < 0) {  					scale = (max == min) ? 0.0 : 255.0 / (max - min);  					shift = (scale == 0) ? min : -min * scale;  				}  				CvInvoke.cvConvertScaleAbs (srcImage.Ptr' Ptr' scale' shift);  			}  			else {  				CvInvoke.cvConvertScale (srcImage.Ptr' Ptr' 1.0' 0.0);  			}  		}  	}  	#endregion  }  else {  	#region different color  	if (typeof(TDepth) == typeof(TSrcDepth)) {  		//same depth  		ConvertColor (srcImage.Ptr' Ptr' typeof(TSrcColor)' typeof(TColor)' Size);  	}  	else {  		//different depth  		using (Image<TSrcColor' TDepth> tmp = srcImage.Convert<TSrcColor' TDepth> ())  			//convert depth  			ConvertColor (tmp.Ptr' Ptr' typeof(TSrcColor)' typeof(TColor)' Size);  	}  	#endregion  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (typeof(TColor) == typeof(TSrcColor)) {  	#region same color  	if (typeof(TDepth) == typeof(TSrcDepth)) {  		//same depth  		CvInvoke.cvCopy (srcImage.Ptr' Ptr' IntPtr.Zero);  	}  	else {  		//different depth  		//int channelCount = NumberOfChannels;  		{  			if (typeof(TDepth) == typeof(Byte) && typeof(TSrcDepth) != typeof(Byte)) {  				double[] minVal' maxVal;  				Point[] minLoc' maxLoc;  				srcImage.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				double min = minVal [0];  				double max = maxVal [0];  				for (int i = 1; i < minVal.Length; i++) {  					min = Math.Min (min' minVal [i]);  					max = Math.Max (max' maxVal [i]);  				}  				double scale = 1.0' shift = 0.0;  				if (max > 255.0 || min < 0) {  					scale = (max == min) ? 0.0 : 255.0 / (max - min);  					shift = (scale == 0) ? min : -min * scale;  				}  				CvInvoke.cvConvertScaleAbs (srcImage.Ptr' Ptr' scale' shift);  			}  			else {  				CvInvoke.cvConvertScale (srcImage.Ptr' Ptr' 1.0' 0.0);  			}  		}  	}  	#endregion  }  else {  	#region different color  	if (typeof(TDepth) == typeof(TSrcDepth)) {  		//same depth  		ConvertColor (srcImage.Ptr' Ptr' typeof(TSrcColor)' typeof(TColor)' Size);  	}  	else {  		//different depth  		using (Image<TSrcColor' TDepth> tmp = srcImage.Convert<TSrcColor' TDepth> ())  			//convert depth  			ConvertColor (tmp.Ptr' Ptr' typeof(TSrcColor)' typeof(TColor)' Size);  	}  	#endregion  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (typeof(TDepth) == typeof(TSrcDepth)) {  	//same depth  	CvInvoke.cvCopy (srcImage.Ptr' Ptr' IntPtr.Zero);  }  else {  	//different depth  	//int channelCount = NumberOfChannels;  	{  		if (typeof(TDepth) == typeof(Byte) && typeof(TSrcDepth) != typeof(Byte)) {  			double[] minVal' maxVal;  			Point[] minLoc' maxLoc;  			srcImage.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  			double min = minVal [0];  			double max = maxVal [0];  			for (int i = 1; i < minVal.Length; i++) {  				min = Math.Min (min' minVal [i]);  				max = Math.Max (max' maxVal [i]);  			}  			double scale = 1.0' shift = 0.0;  			if (max > 255.0 || min < 0) {  				scale = (max == min) ? 0.0 : 255.0 / (max - min);  				shift = (scale == 0) ? min : -min * scale;  			}  			CvInvoke.cvConvertScaleAbs (srcImage.Ptr' Ptr' scale' shift);  		}  		else {  			CvInvoke.cvConvertScale (srcImage.Ptr' Ptr' 1.0' 0.0);  		}  	}  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (typeof(TDepth) == typeof(TSrcDepth)) {  	//same depth  	CvInvoke.cvCopy (srcImage.Ptr' Ptr' IntPtr.Zero);  }  else {  	//different depth  	//int channelCount = NumberOfChannels;  	{  		if (typeof(TDepth) == typeof(Byte) && typeof(TSrcDepth) != typeof(Byte)) {  			double[] minVal' maxVal;  			Point[] minLoc' maxLoc;  			srcImage.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  			double min = minVal [0];  			double max = maxVal [0];  			for (int i = 1; i < minVal.Length; i++) {  				min = Math.Min (min' minVal [i]);  				max = Math.Max (max' maxVal [i]);  			}  			double scale = 1.0' shift = 0.0;  			if (max > 255.0 || min < 0) {  				scale = (max == min) ? 0.0 : 255.0 / (max - min);  				shift = (scale == 0) ? min : -min * scale;  			}  			CvInvoke.cvConvertScaleAbs (srcImage.Ptr' Ptr' scale' shift);  		}  		else {  			CvInvoke.cvConvertScale (srcImage.Ptr' Ptr' 1.0' 0.0);  		}  	}  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (typeof(TDepth) == typeof(Byte) && typeof(TSrcDepth) != typeof(Byte)) {  	double[] minVal' maxVal;  	Point[] minLoc' maxLoc;  	srcImage.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  	double min = minVal [0];  	double max = maxVal [0];  	for (int i = 1; i < minVal.Length; i++) {  		min = Math.Min (min' minVal [i]);  		max = Math.Max (max' maxVal [i]);  	}  	double scale = 1.0' shift = 0.0;  	if (max > 255.0 || min < 0) {  		scale = (max == min) ? 0.0 : 255.0 / (max - min);  		shift = (scale == 0) ? min : -min * scale;  	}  	CvInvoke.cvConvertScaleAbs (srcImage.Ptr' Ptr' scale' shift);  }  else {  	CvInvoke.cvConvertScale (srcImage.Ptr' Ptr' 1.0' 0.0);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (typeof(TDepth) == typeof(Byte) && typeof(TSrcDepth) != typeof(Byte)) {  	double[] minVal' maxVal;  	Point[] minLoc' maxLoc;  	srcImage.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  	double min = minVal [0];  	double max = maxVal [0];  	for (int i = 1; i < minVal.Length; i++) {  		min = Math.Min (min' minVal [i]);  		max = Math.Max (max' maxVal [i]);  	}  	double scale = 1.0' shift = 0.0;  	if (max > 255.0 || min < 0) {  		scale = (max == min) ? 0.0 : 255.0 / (max - min);  		shift = (scale == 0) ? min : -min * scale;  	}  	CvInvoke.cvConvertScaleAbs (srcImage.Ptr' Ptr' scale' shift);  }  else {  	CvInvoke.cvConvertScale (srcImage.Ptr' Ptr' 1.0' 0.0);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (max > 255.0 || min < 0) {  	scale = (max == min) ? 0.0 : 255.0 / (max - min);  	shift = (scale == 0) ? min : -min * scale;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: if (max > 255.0 || min < 0) {  	scale = (max == min) ? 0.0 : 255.0 / (max - min);  	shift = (scale == 0) ? min : -min * scale;  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ConvertFrom,The following statement contains a magic number: scale = (max == min) ? 0.0 : 255.0 / (max - min);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: if (typeOfColor == typeof(Gray))// if this is a gray scale image   {  	if (typeofDepth == typeof(Byte)) {  		Size size = Size;  		Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format8bppIndexed);  		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format8bppIndexed);  		using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' data.Scan0' data.Stride))  			CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  		bmp.UnlockBits (data);  		bmp.Palette = Util.GrayscalePalette;  		return bmp;  	}  	else {  		using (Image<Gray' Byte> temp = Convert<Gray' Byte> ())  			return temp.ToBitmap ();  	}  }  else if (typeOfColor == typeof(Bgra))//if this is Bgra image   {  	if (typeofDepth == typeof(byte)) {  		Size size = Size;  		Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 4' data.Scan0' data.Stride))  			CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  		bmp.UnlockBits (data);  		return bmp;  	}  	else {  		using (Image<Bgra' Byte> tmp = Convert<Bgra' Byte> ())  			return tmp.ToBitmap ();  	}  }  else if (this is Image<Bgr' Byte>) {  	//if this is a Bgr Byte image  	Size size = Size;  	//create the bitmap and get the pointer to the data  	Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 3' data.Scan0' data.Stride))  		CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  	bmp.UnlockBits (data);  	return bmp;  }  else {  	using (Image<Bgr' Byte> temp = Convert<Bgr' Byte> ())  		return temp.ToBitmap ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: if (typeOfColor == typeof(Gray))// if this is a gray scale image   {  	if (typeofDepth == typeof(Byte)) {  		Size size = Size;  		Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format8bppIndexed);  		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format8bppIndexed);  		using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' data.Scan0' data.Stride))  			CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  		bmp.UnlockBits (data);  		bmp.Palette = Util.GrayscalePalette;  		return bmp;  	}  	else {  		using (Image<Gray' Byte> temp = Convert<Gray' Byte> ())  			return temp.ToBitmap ();  	}  }  else if (typeOfColor == typeof(Bgra))//if this is Bgra image   {  	if (typeofDepth == typeof(byte)) {  		Size size = Size;  		Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 4' data.Scan0' data.Stride))  			CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  		bmp.UnlockBits (data);  		return bmp;  	}  	else {  		using (Image<Bgra' Byte> tmp = Convert<Bgra' Byte> ())  			return tmp.ToBitmap ();  	}  }  else if (this is Image<Bgr' Byte>) {  	//if this is a Bgr Byte image  	Size size = Size;  	//create the bitmap and get the pointer to the data  	Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 3' data.Scan0' data.Stride))  		CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  	bmp.UnlockBits (data);  	return bmp;  }  else {  	using (Image<Bgr' Byte> temp = Convert<Bgr' Byte> ())  		return temp.ToBitmap ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: if (typeOfColor == typeof(Bgra))//if this is Bgra image   {  	if (typeofDepth == typeof(byte)) {  		Size size = Size;  		Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 4' data.Scan0' data.Stride))  			CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  		bmp.UnlockBits (data);  		return bmp;  	}  	else {  		using (Image<Bgra' Byte> tmp = Convert<Bgra' Byte> ())  			return tmp.ToBitmap ();  	}  }  else if (this is Image<Bgr' Byte>) {  	//if this is a Bgr Byte image  	Size size = Size;  	//create the bitmap and get the pointer to the data  	Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 3' data.Scan0' data.Stride))  		CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  	bmp.UnlockBits (data);  	return bmp;  }  else {  	using (Image<Bgr' Byte> temp = Convert<Bgr' Byte> ())  		return temp.ToBitmap ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: if (typeOfColor == typeof(Bgra))//if this is Bgra image   {  	if (typeofDepth == typeof(byte)) {  		Size size = Size;  		Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  		using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 4' data.Scan0' data.Stride))  			CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  		bmp.UnlockBits (data);  		return bmp;  	}  	else {  		using (Image<Bgra' Byte> tmp = Convert<Bgra' Byte> ())  			return tmp.ToBitmap ();  	}  }  else if (this is Image<Bgr' Byte>) {  	//if this is a Bgr Byte image  	Size size = Size;  	//create the bitmap and get the pointer to the data  	Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 3' data.Scan0' data.Stride))  		CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  	bmp.UnlockBits (data);  	return bmp;  }  else {  	using (Image<Bgr' Byte> temp = Convert<Bgr' Byte> ())  		return temp.ToBitmap ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: if (typeofDepth == typeof(byte)) {  	Size size = Size;  	Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  	using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 4' data.Scan0' data.Stride))  		CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  	bmp.UnlockBits (data);  	return bmp;  }  else {  	using (Image<Bgra' Byte> tmp = Convert<Bgra' Byte> ())  		return tmp.ToBitmap ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 4' data.Scan0' data.Stride))  	CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: if (this is Image<Bgr' Byte>) {  	//if this is a Bgr Byte image  	Size size = Size;  	//create the bitmap and get the pointer to the data  	Bitmap bmp = new Bitmap (size.Width' size.Height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	System.Drawing.Imaging.BitmapData data = bmp.LockBits (new Rectangle (Point.Empty' size)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 3' data.Scan0' data.Stride))  		CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  	bmp.UnlockBits (data);  	return bmp;  }  else {  	using (Image<Bgr' Byte> temp = Convert<Bgr' Byte> ())  		return temp.ToBitmap ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,ToBitmap,The following statement contains a magic number: using (Matrix<Byte> m = new Matrix<byte> (size.Height' size.Width' 3' data.Scan0' data.Stride))  	CvInvoke.cvCopy (Ptr' m.Ptr' IntPtr.Zero);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	gammaLUT [i' 0] = (Byte)(Math.Pow (i / 255.0' gamma) * 255.0);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	gammaLUT [i' 0] = (Byte)(Math.Pow (i / 255.0' gamma) * 255.0);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	gammaLUT [i' 0] = (Byte)(Math.Pow (i / 255.0' gamma) * 255.0);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: gammaLUT [i' 0] = (Byte)(Math.Pow (i / 255.0' gamma) * 255.0);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: gammaLUT [i' 0] = (Byte)(Math.Pow (i / 255.0' gamma) * 255.0);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: using (Matrix<Byte> lut = new Matrix<byte> (gammaLUT)) {  	Matrix<Byte> lookupTable;  	if (lut.NumberOfChannels == 1)  		lookupTable = lut;  	else {  		lookupTable = new Matrix<byte> (lut.Rows' lut.Cols' NumberOfChannels);  		CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr);  	}  	CvInvoke.cvLUT (Ptr' Ptr' lookupTable.Ptr);  	if (!object.ReferenceEquals (lut' lookupTable))  		lookupTable.Dispose ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: using (Matrix<Byte> lut = new Matrix<byte> (gammaLUT)) {  	Matrix<Byte> lookupTable;  	if (lut.NumberOfChannels == 1)  		lookupTable = lut;  	else {  		lookupTable = new Matrix<byte> (lut.Rows' lut.Cols' NumberOfChannels);  		CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr);  	}  	CvInvoke.cvLUT (Ptr' Ptr' lookupTable.Ptr);  	if (!object.ReferenceEquals (lut' lookupTable))  		lookupTable.Dispose ();  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: if (lut.NumberOfChannels == 1)  	lookupTable = lut;  else {  	lookupTable = new Matrix<byte> (lut.Rows' lut.Cols' NumberOfChannels);  	CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: if (lut.NumberOfChannels == 1)  	lookupTable = lut;  else {  	lookupTable = new Matrix<byte> (lut.Rows' lut.Cols' NumberOfChannels);  	CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_GammaCorrect,The following statement contains a magic number: CvInvoke.cvMerge (lut.Ptr' NumberOfChannels > 1 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 2 ? lut.Ptr : IntPtr.Zero' NumberOfChannels > 3 ? lut.Ptr : IntPtr.Zero' lookupTable.Ptr);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' a [0]' a [1]' a [2]' a [3]);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' a [0]' a [1]' a [2]' a [3]);  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_EqualizeHist,The following statement contains a magic number: if (NumberOfChannels == 1)//Gray scale image   {  	CvInvoke.cvEqualizeHist (Ptr' Ptr);  }  else//Color image   {  	//Get an hsv representation of this image  	Image<Hsv' TDepth> hsv = this as Image<Hsv' TDepth> ?? Convert<Hsv' TDepth> ();  	//equalize the V (value) channel  	using (Image<Gray' TDepth> v = new Image<Gray' TDepth> (Size)) {  		CvInvoke.cvSetImageCOI (hsv.Ptr' 3);  		CvInvoke.cvCopy (hsv.Ptr' v.Ptr' IntPtr.Zero);  		v._EqualizeHist ();  		CvInvoke.cvCopy (v.Ptr' hsv.Ptr' IntPtr.Zero);  		CvInvoke.cvSetImageCOI (hsv.Ptr' 0);  	}  	if (!Object.ReferenceEquals (this' hsv)) {  		ConvertFrom (hsv);  		hsv.Dispose ();  	}  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_EqualizeHist,The following statement contains a magic number: using (Image<Gray' TDepth> v = new Image<Gray' TDepth> (Size)) {  	CvInvoke.cvSetImageCOI (hsv.Ptr' 3);  	CvInvoke.cvCopy (hsv.Ptr' v.Ptr' IntPtr.Zero);  	v._EqualizeHist ();  	CvInvoke.cvCopy (v.Ptr' hsv.Ptr' IntPtr.Zero);  	CvInvoke.cvSetImageCOI (hsv.Ptr' 0);  }  
Magic Number,Emgu.CV,Image,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Image.cs,_EqualizeHist,The following statement contains a magic number: CvInvoke.cvSetImageCOI (hsv.Ptr' 3);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,Line2DFitting,The following statement contains a magic number: CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,Line2DFitting,The following statement contains a magic number: CvInvoke.cvFitLine (seq' type' 0.0' 0.01' 0.01' data);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,Line2DFitting,The following statement contains a magic number: CvInvoke.cvFitLine (seq' type' 0.0' 0.01' 0.01' data);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,Line2DFitting,The following statement contains a magic number: aPointOnLine = new PointF (data [2]' data [3]);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,Line2DFitting,The following statement contains a magic number: aPointOnLine = new PointF (data [2]' data [3]);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,EllipseLeastSquareFitting,The following statement contains a magic number: CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,EllipseLeastSquareFitting,The following statement contains a magic number: if (b.angle < 0)  	b.angle += 360;  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,EllipseLeastSquareFitting,The following statement contains a magic number: b.angle += 360;  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,ConvexHull,The following statement contains a magic number: CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,BoundingRectangle,The following statement contains a magic number: CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,MinAreaRect,The following statement contains a magic number: CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,MinEnclosingCircle,The following statement contains a magic number: CvInvoke.cvMakeSeqHeaderForArray (CvInvoke.CV_MAKETYPE ((int)CvEnum.MAT_DEPTH.CV_32F' 2)' StructSize.MCvSeq' StructSize.PointF' handle.AddrOfPinnedObject ()' points.Length' seq' block);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,ReprojectImageTo3D,The following statement contains a magic number: using (Matrix<float> pts = new Matrix<float> (size.Height' size.Width' 3' handle.AddrOfPinnedObject ()' 0))  	CvInvoke.cvReprojectImageTo3D (disparity.Ptr' pts.Ptr' Q);  
Magic Number,Emgu.CV,PointCollection,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\PointCollection.cs,GeneratePointCloud,The following statement contains a magic number: using (Matrix<float> points = new Matrix<float> (numberOfPoints' 2' handle.AddrOfPinnedObject ()))  	using (Matrix<float> xValues = points.GetCol (0))  		using (Matrix<float> yValues = points.GetCol (1))  			using (RotationMatrix2D<float> rotation = new RotationMatrix2D<float> (e.MCvBox2D.center' e.MCvBox2D.angle' 1.0)) {  				xValues.SetRandNormal (new MCvScalar (e.MCvBox2D.center.X)' new MCvScalar (e.MCvBox2D.size.Width / 2.0f));  				yValues.SetRandNormal (new MCvScalar (e.MCvBox2D.center.Y)' new MCvScalar (e.MCvBox2D.size.Height / 2.0f));  				rotation.RotatePoints (points);  			}  
Magic Number,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' channels [0].Ptr' channelCount >= 2 ? channels [1].Ptr : IntPtr.Zero' channelCount >= 3 ? channels [2].Ptr : IntPtr.Zero' channelCount >= 4 ? channels [3].Ptr : IntPtr.Zero);  
Magic Number,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' channels [0].Ptr' channelCount >= 2 ? channels [1].Ptr : IntPtr.Zero' channelCount >= 3 ? channels [2].Ptr : IntPtr.Zero' channelCount >= 4 ? channels [3].Ptr : IntPtr.Zero);  
Magic Number,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' channels [0].Ptr' channelCount >= 2 ? channels [1].Ptr : IntPtr.Zero' channelCount >= 3 ? channels [2].Ptr : IntPtr.Zero' channelCount >= 4 ? channels [3].Ptr : IntPtr.Zero);  
Magic Number,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' channels [0].Ptr' channelCount >= 2 ? channels [1].Ptr : IntPtr.Zero' channelCount >= 3 ? channels [2].Ptr : IntPtr.Zero' channelCount >= 4 ? channels [3].Ptr : IntPtr.Zero);  
Magic Number,Emgu.CV,Matrix,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Matrix.cs,Split,The following statement contains a magic number: CvInvoke.cvSplit (Ptr' channels [0].Ptr' channelCount >= 2 ? channels [1].Ptr : IntPtr.Zero' channelCount >= 3 ? channels [2].Ptr : IntPtr.Zero' channelCount >= 4 ? channels [3].Ptr : IntPtr.Zero);  
Magic Number,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,GenerateGrayscalePalette,The following statement contains a magic number: using (Bitmap image = new Bitmap (1' 1' PixelFormat.Format8bppIndexed)) {  	ColorPalette palette = image.Palette;  	for (int i = 0; i < 256; i++) {  		palette.Entries [i] = Color.FromArgb (i' i' i);  	}  	return palette;  }  
Magic Number,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,GenerateGrayscalePalette,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	palette.Entries [i] = Color.FromArgb (i' i' i);  }  
Magic Number,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,ColorPaletteToLookupTable,The following statement contains a magic number: bTable = new Matrix<byte> (256' 1);  
Magic Number,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,ColorPaletteToLookupTable,The following statement contains a magic number: gTable = new Matrix<byte> (256' 1);  
Magic Number,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,ColorPaletteToLookupTable,The following statement contains a magic number: rTable = new Matrix<byte> (256' 1);  
Magic Number,Emgu.CV,Util,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Util.cs,ColorPaletteToLookupTable,The following statement contains a magic number: aTable = new Matrix<byte> (256' 1);  
Magic Number,Emgu.CV.Structure,LineSegment2DF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2DF.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,LineSegment2DF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2DF.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,LineSegment2DF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2DF.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,LineSegment2DF,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2DF.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,MCvQuadEdge2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvQuadEdge2D.cs,GetCvSubdiv2DPoint,The following statement contains a magic number: Debug.Assert (0 <= index && index < 4' "index must be >= 0 and < 4");  
Magic Number,Emgu.CV.Structure,MCvSubdiv2DEdge,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvSubdiv2DEdge.cs,cvSubdiv2DRotateEdge,The following statement contains a magic number: return new MCvSubdiv2DEdge (new IntPtr ((edgeInt64 & -4) | ((edgeInt64 + rotate) & 3)));  
Magic Number,Emgu.CV.Structure,MCvSubdiv2DEdge,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvSubdiv2DEdge.cs,cvSubdiv2DRotateEdge,The following statement contains a magic number: return new MCvSubdiv2DEdge (new IntPtr ((edgeInt64 & -4) | ((edgeInt64 + rotate) & 3)));  
Magic Number,Emgu.CV.Structure,MCvSubdiv2DEdge,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvSubdiv2DEdge.cs,cvSubdiv2DGetEdge,The following statement contains a magic number: edgePtr = (edgePtr & -4) + ((edgePtr + ((int)type >> 4)) & 3);  
Magic Number,Emgu.CV.Structure,MCvSubdiv2DEdge,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvSubdiv2DEdge.cs,cvSubdiv2DGetEdge,The following statement contains a magic number: edgePtr = (edgePtr & -4) + ((edgePtr + ((int)type >> 4)) & 3);  
Magic Number,Emgu.CV.Structure,MCvSubdiv2DEdge,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvSubdiv2DEdge.cs,cvSubdiv2DGetEdge,The following statement contains a magic number: edgePtr = (edgePtr & -4) + ((edgePtr + ((int)type >> 4)) & 3);  
Magic Number,Emgu.CV.Structure,MCvScalar,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PInvoke\CvType\MCvScalar.cs,ToArray,The following statement contains a magic number: return new double[4] {  	v0'  	v1'  	v2'  	v3  };  
Magic Number,Emgu.CV.Structure,LineSegment2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2D.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,LineSegment2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2D.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,LineSegment2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2D.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Structure,LineSegment2D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\PointAndLine\LineSegment2D.cs,GetExteriorAngleDegree,The following statement contains a magic number: return degreeAngle <= -180.0 ? degreeAngle + 360 : degreeAngle > 180.0 ? degreeAngle - 360 : degreeAngle;  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedImageFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedImageFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.KeyPoint.Point;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the Image features that belongs to the current Region  	MatchedImageFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedImageFeature f) {  			return contour.InContour (f.ObservedFeature.KeyPoint.Point) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,CamShiftTrack,The following statement contains a magic number: return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,Detect,The following statement contains a magic number: if (matchedGoodFeatures.Length < 4)  	return null;  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,Detect,The following statement contains a magic number: matchedGoodFeatures = VoteForSizeAndOrientation (matchedGoodFeatures' 1.5' 20);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,Detect,The following statement contains a magic number: matchedGoodFeatures = VoteForSizeAndOrientation (matchedGoodFeatures' 1.5' 20);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,Detect,The following statement contains a magic number: if (matchedGoodFeatures.Length < 4)  	return null;  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < 4)  	return null;  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  		pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Point;  	pts2 [i] = matchedFeatures [i].ObservedFeature.KeyPoint.Point;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: homography = CameraCalibration.FindHomography (pts1' //points on the model image  pts2' //points on the observed image  CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (homography.IsValid (10))  	return homography;  else {  	homography.Dispose ();  	return null;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: for (int i = 0; i < matchedFeatures.Length; i++) {  	float scale = (float)matchedFeatures [i].ObservedFeature.KeyPoint.Size / (float)matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Size;  	scale = (float)Math.Log10 (scale);  	scales [i] = scale;  	if (scale < minScale)  		minScale = scale;  	if (scale > maxScale)  		maxScale = scale;  	float rotation = matchedFeatures [i].ObservedFeature.KeyPoint.Angle - matchedFeatures [i].SimilarFeatures [0].Feature.KeyPoint.Angle;  	rotations [i] = rotation < 0.0 ? rotation + 360 : rotation;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: rotations [i] = rotation < 0.0 ? rotation + 360 : rotation;  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: if (scaleBinSize == 1) {  	//handle the case where there is only one scale bin  	using (DenseHistogram h = new DenseHistogram (new int[] {  		rotationBins  	}' new RangeF[] {  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  else {  	using (DenseHistogram h = new DenseHistogram (new int[] {  		scaleBinSize'  		rotationBins  	}' new RangeF[] {  		new RangeF (minScale' maxScale)'  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  				using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  					h.Calculate (new Matrix<float>[] {  						scalesMat'  						rotationsMat  					}' true' null);  					float minVal' maxVal;  					int[] minLoc' maxLoc;  					h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  					h.Threshold (maxVal * 0.5);  					CvInvoke.cvCalcBackProject (new IntPtr[] {  						scalesMat.Ptr'  						rotationsMat.Ptr  					}' flagsMat.Ptr' h.Ptr);  					count = CvInvoke.cvCountNonZero (flagsMat);  				}  		scaleHandle.Free ();  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: if (scaleBinSize == 1) {  	//handle the case where there is only one scale bin  	using (DenseHistogram h = new DenseHistogram (new int[] {  		rotationBins  	}' new RangeF[] {  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  else {  	using (DenseHistogram h = new DenseHistogram (new int[] {  		scaleBinSize'  		rotationBins  	}' new RangeF[] {  		new RangeF (minScale' maxScale)'  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  				using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  					h.Calculate (new Matrix<float>[] {  						scalesMat'  						rotationsMat  					}' true' null);  					float minVal' maxVal;  					int[] minLoc' maxLoc;  					h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  					h.Threshold (maxVal * 0.5);  					CvInvoke.cvCalcBackProject (new IntPtr[] {  						scalesMat.Ptr'  						rotationsMat.Ptr  					}' flagsMat.Ptr' h.Ptr);  					count = CvInvoke.cvCountNonZero (flagsMat);  				}  		scaleHandle.Free ();  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: if (scaleBinSize == 1) {  	//handle the case where there is only one scale bin  	using (DenseHistogram h = new DenseHistogram (new int[] {  		rotationBins  	}' new RangeF[] {  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  else {  	using (DenseHistogram h = new DenseHistogram (new int[] {  		scaleBinSize'  		rotationBins  	}' new RangeF[] {  		new RangeF (minScale' maxScale)'  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  				using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  					h.Calculate (new Matrix<float>[] {  						scalesMat'  						rotationsMat  					}' true' null);  					float minVal' maxVal;  					int[] minLoc' maxLoc;  					h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  					h.Threshold (maxVal * 0.5);  					CvInvoke.cvCalcBackProject (new IntPtr[] {  						scalesMat.Ptr'  						rotationsMat.Ptr  					}' flagsMat.Ptr' h.Ptr);  					count = CvInvoke.cvCountNonZero (flagsMat);  				}  		scaleHandle.Free ();  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: if (scaleBinSize == 1) {  	//handle the case where there is only one scale bin  	using (DenseHistogram h = new DenseHistogram (new int[] {  		rotationBins  	}' new RangeF[] {  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  else {  	using (DenseHistogram h = new DenseHistogram (new int[] {  		scaleBinSize'  		rotationBins  	}' new RangeF[] {  		new RangeF (minScale' maxScale)'  		new RangeF (0' 360)  	})) {  		int count;  		GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  		GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  		GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  		using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  			using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  				using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  					h.Calculate (new Matrix<float>[] {  						scalesMat'  						rotationsMat  					}' true' null);  					float minVal' maxVal;  					int[] minLoc' maxLoc;  					h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  					h.Threshold (maxVal * 0.5);  					CvInvoke.cvCalcBackProject (new IntPtr[] {  						scalesMat.Ptr'  						rotationsMat.Ptr  					}' flagsMat.Ptr' h.Ptr);  					count = CvInvoke.cvCountNonZero (flagsMat);  				}  		scaleHandle.Free ();  		rotationHandle.Free ();  		flagsHandle.Free ();  		MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  		int index = 0;  		for (int i = 0; i < matchedFeatures.Length; i++)  			if (flags [i] != 0)  				matchedGoodFeatures [index++] = matchedFeatures [i];  		return matchedGoodFeatures;  	}  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (DenseHistogram h = new DenseHistogram (new int[] {  	rotationBins  }' new RangeF[] {  	new RangeF (0' 360)  })) {  	int count;  	GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  	GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  	using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  		using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  			h.Calculate (new Matrix<float>[] {  				rotationsMat  			}' true' null);  			float minVal' maxVal;  			int[] minLoc' maxLoc;  			h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  			h.Threshold (maxVal * 0.5);  			CvInvoke.cvCalcBackProject (new IntPtr[] {  				rotationsMat.Ptr  			}' flagsMat.Ptr' h.Ptr);  			count = CvInvoke.cvCountNonZero (flagsMat);  		}  	rotationHandle.Free ();  	flagsHandle.Free ();  	MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  	int index = 0;  	for (int i = 0; i < matchedFeatures.Length; i++)  		if (flags [i] != 0)  			matchedGoodFeatures [index++] = matchedFeatures [i];  	return matchedGoodFeatures;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (DenseHistogram h = new DenseHistogram (new int[] {  	rotationBins  }' new RangeF[] {  	new RangeF (0' 360)  })) {  	int count;  	GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  	GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  	using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  		using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  			h.Calculate (new Matrix<float>[] {  				rotationsMat  			}' true' null);  			float minVal' maxVal;  			int[] minLoc' maxLoc;  			h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  			h.Threshold (maxVal * 0.5);  			CvInvoke.cvCalcBackProject (new IntPtr[] {  				rotationsMat.Ptr  			}' flagsMat.Ptr' h.Ptr);  			count = CvInvoke.cvCountNonZero (flagsMat);  		}  	rotationHandle.Free ();  	flagsHandle.Free ();  	MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  	int index = 0;  	for (int i = 0; i < matchedFeatures.Length; i++)  		if (flags [i] != 0)  			matchedGoodFeatures [index++] = matchedFeatures [i];  	return matchedGoodFeatures;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  	using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  		h.Calculate (new Matrix<float>[] {  			rotationsMat  		}' true' null);  		float minVal' maxVal;  		int[] minLoc' maxLoc;  		h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  		h.Threshold (maxVal * 0.5);  		CvInvoke.cvCalcBackProject (new IntPtr[] {  			rotationsMat.Ptr  		}' flagsMat.Ptr' h.Ptr);  		count = CvInvoke.cvCountNonZero (flagsMat);  	}  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  	h.Calculate (new Matrix<float>[] {  		rotationsMat  	}' true' null);  	float minVal' maxVal;  	int[] minLoc' maxLoc;  	h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  	h.Threshold (maxVal * 0.5);  	CvInvoke.cvCalcBackProject (new IntPtr[] {  		rotationsMat.Ptr  	}' flagsMat.Ptr' h.Ptr);  	count = CvInvoke.cvCountNonZero (flagsMat);  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: h.Threshold (maxVal * 0.5);  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (DenseHistogram h = new DenseHistogram (new int[] {  	scaleBinSize'  	rotationBins  }' new RangeF[] {  	new RangeF (minScale' maxScale)'  	new RangeF (0' 360)  })) {  	int count;  	GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  	GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  	GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  	using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  		using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					scalesMat'  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					scalesMat.Ptr'  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  	scaleHandle.Free ();  	rotationHandle.Free ();  	flagsHandle.Free ();  	MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  	int index = 0;  	for (int i = 0; i < matchedFeatures.Length; i++)  		if (flags [i] != 0)  			matchedGoodFeatures [index++] = matchedFeatures [i];  	return matchedGoodFeatures;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (DenseHistogram h = new DenseHistogram (new int[] {  	scaleBinSize'  	rotationBins  }' new RangeF[] {  	new RangeF (minScale' maxScale)'  	new RangeF (0' 360)  })) {  	int count;  	GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  	GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  	GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  	using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  		using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					scalesMat'  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					scalesMat.Ptr'  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  	scaleHandle.Free ();  	rotationHandle.Free ();  	flagsHandle.Free ();  	MatchedImageFeature[] matchedGoodFeatures = new MatchedImageFeature[count];  	int index = 0;  	for (int i = 0; i < matchedFeatures.Length; i++)  		if (flags [i] != 0)  			matchedGoodFeatures [index++] = matchedFeatures [i];  	return matchedGoodFeatures;  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  	using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  		using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  			h.Calculate (new Matrix<float>[] {  				scalesMat'  				rotationsMat  			}' true' null);  			float minVal' maxVal;  			int[] minLoc' maxLoc;  			h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  			h.Threshold (maxVal * 0.5);  			CvInvoke.cvCalcBackProject (new IntPtr[] {  				scalesMat.Ptr'  				rotationsMat.Ptr  			}' flagsMat.Ptr' h.Ptr);  			count = CvInvoke.cvCountNonZero (flagsMat);  		}  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  	using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  		h.Calculate (new Matrix<float>[] {  			scalesMat'  			rotationsMat  		}' true' null);  		float minVal' maxVal;  		int[] minLoc' maxLoc;  		h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  		h.Threshold (maxVal * 0.5);  		CvInvoke.cvCalcBackProject (new IntPtr[] {  			scalesMat.Ptr'  			rotationsMat.Ptr  		}' flagsMat.Ptr' h.Ptr);  		count = CvInvoke.cvCountNonZero (flagsMat);  	}  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  	h.Calculate (new Matrix<float>[] {  		scalesMat'  		rotationsMat  	}' true' null);  	float minVal' maxVal;  	int[] minLoc' maxLoc;  	h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  	h.Threshold (maxVal * 0.5);  	CvInvoke.cvCalcBackProject (new IntPtr[] {  		scalesMat.Ptr'  		rotationsMat.Ptr  	}' flagsMat.Ptr' h.Ptr);  	count = CvInvoke.cvCountNonZero (flagsMat);  }  
Magic Number,Emgu.CV.Features2D,Features2DTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\Features2DTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: h.Threshold (maxVal * 0.5);  
Magic Number,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,Init,The following statement contains a magic number: Radius = 7;  
Magic Number,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,Init,The following statement contains a magic number: Threshold = 20;  
Magic Number,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,Init,The following statement contains a magic number: NOctaves = 3;  
Magic Number,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,Init,The following statement contains a magic number: NViews = 1000;  
Magic Number,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,Init,The following statement contains a magic number: BaseFeatureSize = 32;  
Magic Number,Emgu.CV.Features2D,LDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\LDetector.cs,Init,The following statement contains a magic number: ClusteringDistance = 2;  
Magic Number,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,DetectFeatures,The following statement contains a magic number: using (MemStorage stor = new MemStorage ())  	using (VectorOfFloat descs = new VectorOfFloat ()) {  		Seq<MKeyPoint> pts = new Seq<MKeyPoint> (stor);  		CvSURFDetectorDetectFeature (ref this' image' mask' pts' descs);  		MKeyPoint[] kpts = pts.ToArray ();  		int n = kpts.Length;  		long add = descs.StartAddress.ToInt64 ();  		ImageFeature[] features = new ImageFeature[n];  		int sizeOfdescriptor = extended == 0 ? 64 : 128;  		for (int i = 0; i < n; i++' add += sizeOfdescriptor * sizeof(float)) {  			features [i].KeyPoint = kpts [i];  			float[] desc = new float[sizeOfdescriptor];  			Marshal.Copy (new IntPtr (add)' desc' 0' sizeOfdescriptor);  			features [i].Descriptor = desc;  		}  		return features;  	}  
Magic Number,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,DetectFeatures,The following statement contains a magic number: using (MemStorage stor = new MemStorage ())  	using (VectorOfFloat descs = new VectorOfFloat ()) {  		Seq<MKeyPoint> pts = new Seq<MKeyPoint> (stor);  		CvSURFDetectorDetectFeature (ref this' image' mask' pts' descs);  		MKeyPoint[] kpts = pts.ToArray ();  		int n = kpts.Length;  		long add = descs.StartAddress.ToInt64 ();  		ImageFeature[] features = new ImageFeature[n];  		int sizeOfdescriptor = extended == 0 ? 64 : 128;  		for (int i = 0; i < n; i++' add += sizeOfdescriptor * sizeof(float)) {  			features [i].KeyPoint = kpts [i];  			float[] desc = new float[sizeOfdescriptor];  			Marshal.Copy (new IntPtr (add)' desc' 0' sizeOfdescriptor);  			features [i].Descriptor = desc;  		}  		return features;  	}  
Magic Number,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,DetectFeatures,The following statement contains a magic number: using (VectorOfFloat descs = new VectorOfFloat ()) {  	Seq<MKeyPoint> pts = new Seq<MKeyPoint> (stor);  	CvSURFDetectorDetectFeature (ref this' image' mask' pts' descs);  	MKeyPoint[] kpts = pts.ToArray ();  	int n = kpts.Length;  	long add = descs.StartAddress.ToInt64 ();  	ImageFeature[] features = new ImageFeature[n];  	int sizeOfdescriptor = extended == 0 ? 64 : 128;  	for (int i = 0; i < n; i++' add += sizeOfdescriptor * sizeof(float)) {  		features [i].KeyPoint = kpts [i];  		float[] desc = new float[sizeOfdescriptor];  		Marshal.Copy (new IntPtr (add)' desc' 0' sizeOfdescriptor);  		features [i].Descriptor = desc;  	}  	return features;  }  
Magic Number,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,DetectFeatures,The following statement contains a magic number: using (VectorOfFloat descs = new VectorOfFloat ()) {  	Seq<MKeyPoint> pts = new Seq<MKeyPoint> (stor);  	CvSURFDetectorDetectFeature (ref this' image' mask' pts' descs);  	MKeyPoint[] kpts = pts.ToArray ();  	int n = kpts.Length;  	long add = descs.StartAddress.ToInt64 ();  	ImageFeature[] features = new ImageFeature[n];  	int sizeOfdescriptor = extended == 0 ? 64 : 128;  	for (int i = 0; i < n; i++' add += sizeOfdescriptor * sizeof(float)) {  		features [i].KeyPoint = kpts [i];  		float[] desc = new float[sizeOfdescriptor];  		Marshal.Copy (new IntPtr (add)' desc' 0' sizeOfdescriptor);  		features [i].Descriptor = desc;  	}  	return features;  }  
Magic Number,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,ComputeDescriptors,The following statement contains a magic number: using (VectorOfFloat descs = new VectorOfFloat ()) {  	GCHandle handle = GCHandle.Alloc (keyPoints' GCHandleType.Pinned);  	CvSURFDetectorComputeDescriptors (ref this' image' mask' handle.AddrOfPinnedObject ()' keyPoints.Length' descs);  	handle.Free ();  	int n = keyPoints.Length;  	long address = descs.StartAddress.ToInt64 ();  	ImageFeature[] features = new ImageFeature[n];  	int sizeOfdescriptor = extended == 0 ? 64 : 128;  	for (int i = 0; i < n; i++' address += sizeOfdescriptor * sizeof(float)) {  		features [i].KeyPoint = keyPoints [i];  		float[] desc = new float[sizeOfdescriptor];  		Marshal.Copy (new IntPtr (address)' desc' 0' sizeOfdescriptor);  		features [i].Descriptor = desc;  	}  	return features;  }  
Magic Number,Emgu.CV.Features2D,SURFDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFDetector.cs,ComputeDescriptors,The following statement contains a magic number: using (VectorOfFloat descs = new VectorOfFloat ()) {  	GCHandle handle = GCHandle.Alloc (keyPoints' GCHandleType.Pinned);  	CvSURFDetectorComputeDescriptors (ref this' image' mask' handle.AddrOfPinnedObject ()' keyPoints.Length' descs);  	handle.Free ();  	int n = keyPoints.Length;  	long address = descs.StartAddress.ToInt64 ();  	ImageFeature[] features = new ImageFeature[n];  	int sizeOfdescriptor = extended == 0 ? 64 : 128;  	for (int i = 0; i < n; i++' address += sizeOfdescriptor * sizeof(float)) {  		features [i].KeyPoint = keyPoints [i];  		float[] desc = new float[sizeOfdescriptor];  		Marshal.Copy (new IntPtr (address)' desc' 0' sizeOfdescriptor);  		features [i].Descriptor = desc;  	}  	return features;  }  
Magic Number,Emgu.CV.Features2D,StarDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\StarDetector.cs,Init,The following statement contains a magic number: MaxSize = 45;  
Magic Number,Emgu.CV.Features2D,StarDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\StarDetector.cs,Init,The following statement contains a magic number: ResponseThreshold = 30;  
Magic Number,Emgu.CV.Features2D,StarDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\StarDetector.cs,Init,The following statement contains a magic number: LineThresholdProjected = 10;  
Magic Number,Emgu.CV.Features2D,StarDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\StarDetector.cs,Init,The following statement contains a magic number: LineThresholdBinarized = 8;  
Magic Number,Emgu.CV.Features2D,StarDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\StarDetector.cs,Init,The following statement contains a magic number: SuppressNonmaxSize = 5;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: Delta = 5;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: MinArea = 60;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: MaxArea = 14400;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: MaxEvolution = 200;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: AreaThreshold = 1.01;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: MinMargin = 0.003;  
Magic Number,Emgu.CV.Features2D,MSERDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\MSERDetector.cs,Init,The following statement contains a magic number: EdgeBlurSize = 5;  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: using (Image<Gray' Single> matchMask = new Image<Gray' Single> (priorMask.Size)) {  	#region get the list of matched point on the observed image  	Single[''] matchMaskData = matchMask.Data;  	//Compute the matched features  	MatchedSURFFeature[] matchedFeature = _matcher.MatchFeature (observedFeatures' 2' 20);  	matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  	foreach (MatchedSURFFeature f in matchedFeature) {  		PointF p = f.ObservedFeature.Point.pt;  		matchMaskData [(int)p.Y' (int)p.X' 0] = 1.0f / (float)f.SimilarFeatures [0].Distance;  	}  	#endregion  	Rectangle startRegion;  	if (initRegion.Equals (MCvBox2D.Empty))  		startRegion = matchMask.ROI;  	else {  		startRegion = PointCollection.BoundingRectangle (initRegion.GetVertices ());  		if (startRegion.IntersectsWith (matchMask.ROI))  			startRegion.Intersect (matchMask.ROI);  	}  	CvInvoke.cvMul (matchMask.Ptr' priorMask.Ptr' matchMask.Ptr' 1.0);  	MCvConnectedComp comp;  	MCvBox2D currentRegion;  	//Updates the current location  	CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  	#region find the SURF features that belongs to the current Region  	MatchedSURFFeature[] featuesInCurrentRegion;  	using (MemStorage stor = new MemStorage ()) {  		Contour<System.Drawing.PointF> contour = new Contour<PointF> (stor);  		contour.PushMulti (currentRegion.GetVertices ()' Emgu.CV.CvEnum.BACK_OR_FRONT.BACK);  		CvInvoke.cvBoundingRect (contour.Ptr' 1);  		//this is required before calling the InContour function  		featuesInCurrentRegion = Array.FindAll (matchedFeature' delegate (MatchedSURFFeature f) {  			return contour.InContour (f.ObservedFeature.Point.pt) >= 0;  		});  	}  	#endregion  	return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: matchedFeature = VoteForUniqueness (matchedFeature' 0.8);  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: CvInvoke.cvCamShift (matchMask.Ptr' startRegion' new MCvTermCriteria (10' 1.0e-8)' out comp' out currentRegion);  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,CamShiftTrack,The following statement contains a magic number: return GetHomographyMatrixFromMatchedFeatures (VoteForSizeAndOrientation (featuesInCurrentRegion' 1.5' 20));  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,Detect,The following statement contains a magic number: if (matchedGoodFeatures.Length < 4)  	return null;  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,Detect,The following statement contains a magic number: matchedGoodFeatures = VoteForSizeAndOrientation (matchedGoodFeatures' 1.5' 20);  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,Detect,The following statement contains a magic number: matchedGoodFeatures = VoteForSizeAndOrientation (matchedGoodFeatures' 1.5' 20);  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,Detect,The following statement contains a magic number: if (matchedGoodFeatures.Length < 4)  	return null;  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < 4)  	return null;  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (matchedFeatures.Length < _randsacRequiredMatch) {  	// Too few points for randsac' use 4 points only  	PointF[] pts1 = new PointF[4];  	PointF[] pts2 = new PointF[4];  	for (int i = 0; i < 4; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.GetPerspectiveTransform (pts1' pts2);  }  else {  	//use randsac to find the Homography Matrix  	PointF[] pts1 = new PointF[matchedFeatures.Length];  	PointF[] pts2 = new PointF[matchedFeatures.Length];  	for (int i = 0; i < matchedFeatures.Length; i++) {  		pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  		pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  	}  	homography = CameraCalibration.FindHomography (pts1' //points on the model image  	pts2' //points on the observed image  	CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  	if (homography == null)  		return null;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	pts1 [i] = matchedFeatures [i].SimilarFeatures [0].Feature.Point.pt;  	pts2 [i] = matchedFeatures [i].ObservedFeature.Point.pt;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: homography = CameraCalibration.FindHomography (pts1' //points on the model image  pts2' //points on the observed image  CvEnum.HOMOGRAPHY_METHOD.RANSAC' 3);  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,GetHomographyMatrixFromMatchedFeatures,The following statement contains a magic number: if (homography.IsValid (10))  	return homography;  else {  	homography.Dispose ();  	return null;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: for (int i = 0; i < matchedFeatures.Length; i++) {  	float scale = (float)matchedFeatures [i].ObservedFeature.Point.size / (float)matchedFeatures [i].SimilarFeatures [0].Feature.Point.size;  	scale = (float)Math.Log10 (scale);  	scales [i] = scale;  	if (scale < minScale)  		minScale = scale;  	if (scale > maxScale)  		maxScale = scale;  	float rotation = matchedFeatures [i].ObservedFeature.Point.dir - matchedFeatures [i].SimilarFeatures [0].Feature.Point.dir;  	rotations [i] = rotation < 0.0 ? rotation + 360 : rotation;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: rotations [i] = rotation < 0.0 ? rotation + 360 : rotation;  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (DenseHistogram h = new DenseHistogram (new int[] {  	scaleBinSize'  	rotationBins  }' new RangeF[] {  	new RangeF (minScale' maxScale)'  	new RangeF (0' 360)  })) {  	GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  	GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  	GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  	using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  		using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					scalesMat'  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					scalesMat.Ptr'  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  	scaleHandle.Free ();  	rotationHandle.Free ();  	flagsHandle.Free ();  	MatchedSURFFeature[] matchedGoodFeatures = new MatchedSURFFeature[count];  	int index = 0;  	for (int i = 0; i < matchedFeatures.Length; i++)  		if (flags [i] != 0)  			matchedGoodFeatures [index++] = matchedFeatures [i];  	return matchedGoodFeatures;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (DenseHistogram h = new DenseHistogram (new int[] {  	scaleBinSize'  	rotationBins  }' new RangeF[] {  	new RangeF (minScale' maxScale)'  	new RangeF (0' 360)  })) {  	GCHandle scaleHandle = GCHandle.Alloc (scales' GCHandleType.Pinned);  	GCHandle rotationHandle = GCHandle.Alloc (rotations' GCHandleType.Pinned);  	GCHandle flagsHandle = GCHandle.Alloc (flags' GCHandleType.Pinned);  	using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  		using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  			using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  				h.Calculate (new Matrix<float>[] {  					scalesMat'  					rotationsMat  				}' true' null);  				float minVal' maxVal;  				int[] minLoc' maxLoc;  				h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  				h.Threshold (maxVal * 0.5);  				CvInvoke.cvCalcBackProject (new IntPtr[] {  					scalesMat.Ptr'  					rotationsMat.Ptr  				}' flagsMat.Ptr' h.Ptr);  				count = CvInvoke.cvCountNonZero (flagsMat);  			}  	scaleHandle.Free ();  	rotationHandle.Free ();  	flagsHandle.Free ();  	MatchedSURFFeature[] matchedGoodFeatures = new MatchedSURFFeature[count];  	int index = 0;  	for (int i = 0; i < matchedFeatures.Length; i++)  		if (flags [i] != 0)  			matchedGoodFeatures [index++] = matchedFeatures [i];  	return matchedGoodFeatures;  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> flagsMat = new Matrix<float> (1' elementsCount' flagsHandle.AddrOfPinnedObject ()))  	using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  		using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  			h.Calculate (new Matrix<float>[] {  				scalesMat'  				rotationsMat  			}' true' null);  			float minVal' maxVal;  			int[] minLoc' maxLoc;  			h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  			h.Threshold (maxVal * 0.5);  			CvInvoke.cvCalcBackProject (new IntPtr[] {  				scalesMat.Ptr'  				rotationsMat.Ptr  			}' flagsMat.Ptr' h.Ptr);  			count = CvInvoke.cvCountNonZero (flagsMat);  		}  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> scalesMat = new Matrix<float> (1' elementsCount' scaleHandle.AddrOfPinnedObject ()))  	using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  		h.Calculate (new Matrix<float>[] {  			scalesMat'  			rotationsMat  		}' true' null);  		float minVal' maxVal;  		int[] minLoc' maxLoc;  		h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  		h.Threshold (maxVal * 0.5);  		CvInvoke.cvCalcBackProject (new IntPtr[] {  			scalesMat.Ptr'  			rotationsMat.Ptr  		}' flagsMat.Ptr' h.Ptr);  		count = CvInvoke.cvCountNonZero (flagsMat);  	}  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: using (Matrix<float> rotationsMat = new Matrix<float> (1' elementsCount' rotationHandle.AddrOfPinnedObject ())) {  	h.Calculate (new Matrix<float>[] {  		scalesMat'  		rotationsMat  	}' true' null);  	float minVal' maxVal;  	int[] minLoc' maxLoc;  	h.MinMax (out minVal' out maxVal' out minLoc' out maxLoc);  	h.Threshold (maxVal * 0.5);  	CvInvoke.cvCalcBackProject (new IntPtr[] {  		scalesMat.Ptr'  		rotationsMat.Ptr  	}' flagsMat.Ptr' h.Ptr);  	count = CvInvoke.cvCountNonZero (flagsMat);  }  
Magic Number,Emgu.CV.Features2D,SURFTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Features2D\SURFTracker.cs,VoteForSizeAndOrientation,The following statement contains a magic number: h.Threshold (maxVal * 0.5);  
Magic Number,Emgu.CV.Flann,Index3D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index3D.cs,Index3D,The following statement contains a magic number: _dataMatrix = new Matrix<float> (_points.Length' 3' _dataHandle.AddrOfPinnedObject ());  
Magic Number,Emgu.CV.Flann,Index3D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index3D.cs,Index3D,The following statement contains a magic number: _query = new Matrix<float> (1' 3);  
Magic Number,Emgu.CV.Flann,Index3D,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Flann\Index3D.cs,ApproximateNearestNeighbour,The following statement contains a magic number: _query.Data [0' 2] = position.z;  
Magic Number,Emgu.CV.Geodetic,GeodeticCoordinate,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Geodetic\GeodeticCoordinate.cs,RadianToDegree,The following statement contains a magic number: return radian * (180.0 / Math.PI);  
Magic Number,Emgu.CV.Geodetic,GeodeticCoordinate,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Geodetic\GeodeticCoordinate.cs,DegreeToRadian,The following statement contains a magic number: return degree * (Math.PI / 180.0);  
Magic Number,Emgu.CV.Reflection,ReflectIImage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Reflection\ReflectIImage.cs,GetPixelColor,The following statement contains a magic number: return indexers == null ? new Bgra () : indexers.Invoke (image' new object[2] {  	location.Y'  	location.X  }) as IColor;  
Magic Number,Emgu.CV.Tiff,TiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TiffWriter.cs,TiffWriter,The following statement contains a magic number: TIFFInvoke.tiffWriteImageInfo (_ptr' Image<TColor' TDepth>.SizeOfElement * 8' new TColor ().Dimension);  
Magic Number,Emgu.CV.Tiff,TiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TiffWriter.cs,WriteGeoTag,The following statement contains a magic number: Debug.Assert (modelTiepoint.Length == 6' "Model Tiepoint should have length of 6");  
Magic Number,Emgu.CV.Tiff,TiffWriter,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\Tiff\TiffWriter.cs,WriteGeoTag,The following statement contains a magic number: Debug.Assert (modelPixelScale.Length == 3' "Model Pixel Scale should have length of 3");  
Missing Default,Emgu.CV.VideoSurveillance,BlobDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BlobDetector.cs,BlobDetector,The following switch statement is missing a default case: switch (type) {  case Emgu.CV.CvEnum.BLOB_DETECTOR_TYPE.Simple:  	_ptr = CvInvoke.CvCreateBlobDetectorSimple ();  	break;  case Emgu.CV.CvEnum.BLOB_DETECTOR_TYPE.CC:  	_ptr = CvInvoke.CvCreateBlobDetectorCC ();  	break;  }  
Missing Default,Emgu.CV.VideoSurveillance,BlobTracker,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BlobTracker.cs,BlobTracker,The following switch statement is missing a default case: switch (type) {  case Emgu.CV.CvEnum.BLOBTRACKER_TYPE.CC:  	_ptr = CvInvoke.CvCreateBlobTrackerCC ();  	break;  case Emgu.CV.CvEnum.BLOBTRACKER_TYPE.CCMSPF:  	_ptr = CvInvoke.CvCreateBlobTrackerCCMSPF ();  	break;  case Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MS:  	_ptr = CvInvoke.CvCreateBlobTrackerMS ();  	break;  case Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MSFG:  	_ptr = CvInvoke.CvCreateBlobTrackerMSFG ();  	break;  case Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MSFGS:  	_ptr = CvInvoke.CvCreateBlobTrackerMSFGS ();  	break;  case Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MSPF:  	_ptr = CvInvoke.CvCreateBlobTrackerMSPF ();  	break;  }  
Missing Default,Emgu.CV.VideoSurveillance,BlobTrackPostProc,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV\VideoSurveillance\BlobTrackPostProc.cs,BlobTrackPostProc,The following switch statement is missing a default case: switch (type) {  case Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE.Kalman:  	_ptr = CvInvoke.CvCreateModuleBlobTrackPostProcKalman ();  	break;  case Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE.TimeAverExp:  	_ptr = CvInvoke.CvCreateModuleBlobTrackPostProcTimeAverExp ();  	break;  case Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE.TimeAverRect:  	_ptr = CvInvoke.CvCreateModuleBlobTrackPostProcTimeAverRect ();  	break;  }  
