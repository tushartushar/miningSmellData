Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The method has 148 lines of code.
Complex Method,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,Cyclomatic complexity of the method is 15
Long Statement,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,WindowLoaded,The length of the statement  "	// it is recommended to use KinectSensorChooser provided in Microsoft.Kinect.Toolkit (See components in Toolkit Browser). " is 121.
Long Statement,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The length of the statement  "		this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates); " is 123.
Long Statement,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The length of the statement  "		this.colorBitmap.WritePixels (new Int32Rect (0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)' this.colorPixels' this.colorBitmap.PixelWidth * sizeof(int)' 0); " is 175.
Long Statement,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,ButtonScreenshotClick,The length of the statement  "		this.statusBarText.Text = string.Format (CultureInfo.InvariantCulture' "{0} {1}"' Properties.Resources.ScreenshotWriteSuccess' path); " is 133.
Long Statement,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,ButtonScreenshotClick,The length of the statement  "		this.statusBarText.Text = string.Format (CultureInfo.InvariantCulture' "{0} {1}"' Properties.Resources.ScreenshotWriteFailed' path); " is 132.
Complex Conditional,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The conditional expression  "colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight"  is complex.
Empty Catch Block,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CheckBoxNearModeChanged,The method has an empty catch block.
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: if (newDistance >= 0)  	return (byte)(255 - (255 * newDistance / (MaxDepthDistanceOffset)));  else  	return (byte)255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: if (newDistance >= 0)  	return (byte)(255 - (255 * newDistance / (MaxDepthDistanceOffset)));  else  	return (byte)255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: if (newDistance >= 0)  	return (byte)(255 - (255 * newDistance / (MaxDepthDistanceOffset)));  else  	return (byte)255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: return (byte)(255 - (255 * newDistance / (MaxDepthDistanceOffset)));  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: return (byte)(255 - (255 * newDistance / (MaxDepthDistanceOffset)));  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: return (byte)255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,WindowLoaded,The following statement contains a magic number: if (null != this.sensor) {  	// Turn on the depth stream to receive depth frames  	this.sensor.DepthStream.Enable (DepthFormat);  	this.depthWidth = this.sensor.DepthStream.FrameWidth;  	this.depthHeight = this.sensor.DepthStream.FrameHeight;  	this.sensor.ColorStream.Enable (ColorFormat);  	int colorWidth = this.sensor.ColorStream.FrameWidth;  	int colorHeight = this.sensor.ColorStream.FrameHeight;  	this.colorToDepthDivisor = colorWidth / this.depthWidth;  	// Turn on to get player masks  	this.sensor.SkeletonStream.Enable ();  	// Allocate space to put the depth pixels we'll receive  	this.depthPixels = new DepthImagePixel[this.sensor.DepthStream.FramePixelDataLength];  	// Allocate space to put the color pixels we'll create  	this.colorPixels = new byte[this.sensor.ColorStream.FramePixelDataLength];  	this.playerPixelData = new int[this.sensor.DepthStream.FramePixelDataLength];  	this.colorCoordinates = new ColorImagePoint[this.sensor.DepthStream.FramePixelDataLength];  	// This is the bitmap we'll display on-screen  	this.colorBitmap = new WriteableBitmap (colorWidth' colorHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  	// Set the image we display to point to the bitmap where we'll put the image data  	this.MaskedColor.Source = this.colorBitmap;  	// Add an event handler to be called whenever there is new depth frame data  	this.sensor.AllFramesReady += this.SensorAllFramesReady;  	// Start the sensor!  	try {  		this.sensor.Start ();  	}  	catch (IOException) {  		this.sensor = null;  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,WindowLoaded,The following statement contains a magic number: if (null != this.sensor) {  	// Turn on the depth stream to receive depth frames  	this.sensor.DepthStream.Enable (DepthFormat);  	this.depthWidth = this.sensor.DepthStream.FrameWidth;  	this.depthHeight = this.sensor.DepthStream.FrameHeight;  	this.sensor.ColorStream.Enable (ColorFormat);  	int colorWidth = this.sensor.ColorStream.FrameWidth;  	int colorHeight = this.sensor.ColorStream.FrameHeight;  	this.colorToDepthDivisor = colorWidth / this.depthWidth;  	// Turn on to get player masks  	this.sensor.SkeletonStream.Enable ();  	// Allocate space to put the depth pixels we'll receive  	this.depthPixels = new DepthImagePixel[this.sensor.DepthStream.FramePixelDataLength];  	// Allocate space to put the color pixels we'll create  	this.colorPixels = new byte[this.sensor.ColorStream.FramePixelDataLength];  	this.playerPixelData = new int[this.sensor.DepthStream.FramePixelDataLength];  	this.colorCoordinates = new ColorImagePoint[this.sensor.DepthStream.FramePixelDataLength];  	// This is the bitmap we'll display on-screen  	this.colorBitmap = new WriteableBitmap (colorWidth' colorHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  	// Set the image we display to point to the bitmap where we'll put the image data  	this.MaskedColor.Source = this.colorBitmap;  	// Add an event handler to be called whenever there is new depth frame data  	this.sensor.AllFramesReady += this.SensorAllFramesReady;  	// Start the sensor!  	try {  		this.sensor.Start ();  	}  	catch (IOException) {  		this.sensor = null;  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,WindowLoaded,The following statement contains a magic number: this.colorBitmap = new WriteableBitmap (colorWidth' colorHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,WindowLoaded,The following statement contains a magic number: this.colorBitmap = new WriteableBitmap (colorWidth' colorHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (true == depthReceived) {  	this.sensor.CoordinateMapper.MapDepthFrameToColorFrame (DepthFormat' this.depthPixels' ColorFormat' this.colorCoordinates);  	//Array.Clear(this.playerPixelData' 0' this.playerPixelData.Length);  	var pixels = new byte[this.colorBitmap.PixelWidth * this.colorBitmap.PixelHeight * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	//Initialize - All green  	for (int i = 0; i < pixels.Length; i += 4) {  		pixels [i + BlueIndex] = 0;  		//blue  		pixels [i + GreenIndex] = 0;  		//green  		pixels [i + RedIndex] = 0;  		//red  		pixels [i + AlphaIndex] = 255;  		// alpha  	}  	//Loop through colorCoordinates  	for (int i = 0; i < this.colorCoordinates.Length; i++) {  		if (this.depthPixels [i].IsKnownDepth) {  			// scale color coordinates to depth resolution  			int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  			int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  			// make sure the depth pixel maps to a valid point in color space  			// check y > 0 and y < depthHeight to make sure we don't write outside of the array  			// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  			// because of how the sensor works it is more correct to do it this way than to set to the right  			if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  				// calculate index into the player mask pixel array  				int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  				if (this.depthPixels [i].Depth < 4000) {  					var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  					// Apply the intensity to the color channels  					pixels [PixelIndex * 4 + BlueIndex] = intensity;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = intensity;  					//green  					pixels [PixelIndex * 4 + RedIndex] = intensity;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  				else {  					pixels [PixelIndex * 4 + BlueIndex] = 0;  					//blue  					pixels [PixelIndex * 4 + GreenIndex] = 0;  					//green  					pixels [PixelIndex * 4 + RedIndex] = 0;  					//red  					pixels [PixelIndex * 4 + AlphaIndex] = 255;  					// *3 / 4; // alpha  				}  			}  		}  	}  	WriteableBitmap source = new WriteableBitmap (this.depthWidth' this.depthHeight' 96' 96' PixelFormats.Bgra32' null);  	source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  	depthImage.Source = source;  	/*BitmapSource source = BitmapSource.Create(this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight'                                         96' 96' PixelFormats.Bgra32' null' pixels' this.colorBitmap.PixelWidth * 4);                                          //BitmapSource.Create(this.depthWidth' this.depthHeight' 96' 96'                     //PixelFormats.Bgra32' null' pixels' 640 * 4);                     //                this.colorBitmap.WritePixels(                     //new Int32Rect(0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)'                     //this.colorPixels'                     //this.colorBitmap.PixelWidth * sizeof(int)'                     //0);*///depthImage.Source = source;  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < pixels.Length; i += 4) {  	pixels [i + BlueIndex] = 0;  	//blue  	pixels [i + GreenIndex] = 0;  	//green  	pixels [i + RedIndex] = 0;  	//red  	pixels [i + AlphaIndex] = 255;  	// alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < pixels.Length; i += 4) {  	pixels [i + BlueIndex] = 0;  	//blue  	pixels [i + GreenIndex] = 0;  	//green  	pixels [i + RedIndex] = 0;  	//red  	pixels [i + AlphaIndex] = 255;  	// alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: i += 4
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [i + AlphaIndex] = 255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: for (int i = 0; i < this.colorCoordinates.Length; i++) {  	if (this.depthPixels [i].IsKnownDepth) {  		// scale color coordinates to depth resolution  		int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  		int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  		// make sure the depth pixel maps to a valid point in color space  		// check y > 0 and y < depthHeight to make sure we don't write outside of the array  		// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  		// because of how the sensor works it is more correct to do it this way than to set to the right  		if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  			// calculate index into the player mask pixel array  			int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  			if (this.depthPixels [i].Depth < 4000) {  				var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  				// Apply the intensity to the color channels  				pixels [PixelIndex * 4 + BlueIndex] = intensity;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = intensity;  				//green  				pixels [PixelIndex * 4 + RedIndex] = intensity;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  			else {  				pixels [PixelIndex * 4 + BlueIndex] = 0;  				//blue  				pixels [PixelIndex * 4 + GreenIndex] = 0;  				//green  				pixels [PixelIndex * 4 + RedIndex] = 0;  				//red  				pixels [PixelIndex * 4 + AlphaIndex] = 255;  				// *3 / 4; // alpha  			}  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].IsKnownDepth) {  	// scale color coordinates to depth resolution  	int colorInDepthX = this.colorCoordinates [i].X / this.colorToDepthDivisor;  	int colorInDepthY = this.colorCoordinates [i].Y / this.colorToDepthDivisor;  	// make sure the depth pixel maps to a valid point in color space  	// check y > 0 and y < depthHeight to make sure we don't write outside of the array  	// check x > 0 instead of >= 0 since to fill gaps we set opaque current pixel plus the one to the left  	// because of how the sensor works it is more correct to do it this way than to set to the right  	if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  		// calculate index into the player mask pixel array  		int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  		if (this.depthPixels [i].Depth < 4000) {  			var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  			// Apply the intensity to the color channels  			pixels [PixelIndex * 4 + BlueIndex] = intensity;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = intensity;  			//green  			pixels [PixelIndex * 4 + RedIndex] = intensity;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  		else {  			pixels [PixelIndex * 4 + BlueIndex] = 0;  			//blue  			pixels [PixelIndex * 4 + GreenIndex] = 0;  			//green  			pixels [PixelIndex * 4 + RedIndex] = 0;  			//red  			pixels [PixelIndex * 4 + AlphaIndex] = 255;  			// *3 / 4; // alpha  		}  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (colorInDepthX > 0 && colorInDepthX < this.depthWidth && colorInDepthY >= 0 && colorInDepthY < this.depthHeight) {  	// calculate index into the player mask pixel array  	int PixelIndex = colorInDepthX + (colorInDepthY * this.depthWidth);  	if (this.depthPixels [i].Depth < 4000) {  		var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  		// Apply the intensity to the color channels  		pixels [PixelIndex * 4 + BlueIndex] = intensity;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = intensity;  		//green  		pixels [PixelIndex * 4 + RedIndex] = intensity;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  	else {  		pixels [PixelIndex * 4 + BlueIndex] = 0;  		//blue  		pixels [PixelIndex * 4 + GreenIndex] = 0;  		//green  		pixels [PixelIndex * 4 + RedIndex] = 0;  		//red  		pixels [PixelIndex * 4 + AlphaIndex] = 255;  		// *3 / 4; // alpha  	}  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: if (this.depthPixels [i].Depth < 4000) {  	var intensity = CalculateIntensityFromDistance (this.depthPixels [i].Depth);  	// Apply the intensity to the color channels  	pixels [PixelIndex * 4 + BlueIndex] = intensity;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = intensity;  	//green  	pixels [PixelIndex * 4 + RedIndex] = intensity;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  else {  	pixels [PixelIndex * 4 + BlueIndex] = 0;  	//blue  	pixels [PixelIndex * 4 + GreenIndex] = 0;  	//green  	pixels [PixelIndex * 4 + RedIndex] = 0;  	//red  	pixels [PixelIndex * 4 + AlphaIndex] = 255;  	// *3 / 4; // alpha  }  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + BlueIndex] = intensity;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + GreenIndex] = intensity;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + RedIndex] = intensity;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + AlphaIndex] = 255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + AlphaIndex] = 255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + BlueIndex] = 0;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + GreenIndex] = 0;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + RedIndex] = 0;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + AlphaIndex] = 255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: pixels [PixelIndex * 4 + AlphaIndex] = 255;  
Magic Number,Microsoft.Samples.Kinect.CoordinateMappingBasics,MainWindow,C:\repos\VisionWithGrace_cv\CoordinateMappingBasics-WPF\MainWindow.xaml.cs,SensorAllFramesReady,The following statement contains a magic number: source.WritePixels (new Int32Rect (0' 0' this.depthWidth' this.depthHeight)' pixels' this.depthWidth * 4' 0);  
