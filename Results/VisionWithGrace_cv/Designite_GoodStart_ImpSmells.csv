Implementation smell,Namespace,Class,File,Method,Description
Long Statement,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The length of the statement  "			this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null); " is 151.
Long Statement,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The length of the statement  "				this.colorBitmap.WritePixels (new Int32Rect (0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)' this.colorPixels' this.colorBitmap.PixelWidth * sizeof(int)' 0); " is 175.
Long Statement,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The length of the statement  "			for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) { " is 137.
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The following statement contains a magic number: using (ColorImageFrame colorFrame = e.OpenColorImageFrame ()) {  	if (colorFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		this.colorPixels = new byte[this.sensor.ColorStream.FramePixelDataLength];  		colorFrame.CopyPixelDataTo (this.colorPixels);  		this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  		if (colorFrame != null) {  			// Write the pixel data into our bitmap  			this.colorBitmap.WritePixels (new Int32Rect (0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)' this.colorPixels' this.colorBitmap.PixelWidth * sizeof(int)' 0);  			colorImage.Source = this.colorBitmap;  		}  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The following statement contains a magic number: using (ColorImageFrame colorFrame = e.OpenColorImageFrame ()) {  	if (colorFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		this.colorPixels = new byte[this.sensor.ColorStream.FramePixelDataLength];  		colorFrame.CopyPixelDataTo (this.colorPixels);  		this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  		if (colorFrame != null) {  			// Write the pixel data into our bitmap  			this.colorBitmap.WritePixels (new Int32Rect (0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)' this.colorPixels' this.colorBitmap.PixelWidth * sizeof(int)' 0);  			colorImage.Source = this.colorBitmap;  		}  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The following statement contains a magic number: if (colorFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	this.colorPixels = new byte[this.sensor.ColorStream.FramePixelDataLength];  	colorFrame.CopyPixelDataTo (this.colorPixels);  	this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  	if (colorFrame != null) {  		// Write the pixel data into our bitmap  		this.colorBitmap.WritePixels (new Int32Rect (0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)' this.colorPixels' this.colorBitmap.PixelWidth * sizeof(int)' 0);  		colorImage.Source = this.colorBitmap;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The following statement contains a magic number: if (colorFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	this.colorPixels = new byte[this.sensor.ColorStream.FramePixelDataLength];  	colorFrame.CopyPixelDataTo (this.colorPixels);  	this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  	if (colorFrame != null) {  		// Write the pixel data into our bitmap  		this.colorBitmap.WritePixels (new Int32Rect (0' 0' this.colorBitmap.PixelWidth' this.colorBitmap.PixelHeight)' this.colorPixels' this.colorBitmap.PixelWidth * sizeof(int)' 0);  		colorImage.Source = this.colorBitmap;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The following statement contains a magic number: this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_ColorFrameReady,The following statement contains a magic number: this.colorBitmap = new WriteableBitmap (this.sensor.ColorStream.FrameWidth' this.sensor.ColorStream.FrameHeight' 96.0' 96.0' PixelFormats.Bgr32' null);  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: using (DepthImageFrame DFrame = e.OpenDepthImageFrame ()) {  	if (DFrame == null) {  		// The image processing took too long. More than 2 frames behind.  	}  	else {  		rawDepthData = new short[DFrame.PixelDataLength];  		DFrame.CopyPixelDataTo (rawDepthData);  		var pixels = new byte[640 * 480 * 4];  		const int BlueIndex = 0;  		const int GreenIndex = 1;  		const int RedIndex = 2;  		const int AlphaIndex = 3;  		for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  			// Calculate the distance represented by the two depth bytes  			int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  			// Map the distance to an intesity that can be represented in RGB  			var intensity = CalculateIntensityFromDistance (depth);  			if (depth >= 0 && depth < 4000) {  				// Apply the intensity to the color channels  				pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = intensity;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else if (depth == -1) {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 255;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  			else {  				pixels [colorIndex + BlueIndex] = 0;  				//blue  				pixels [colorIndex + GreenIndex] = 0;  				//green  				pixels [colorIndex + RedIndex] = 0;  				//red  				pixels [colorIndex + AlphaIndex] = 255 / 4;  				// alpha  			}  		}  		receivedData = true;  		BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  		depthImage.Source = source;  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (DFrame == null) {  	// The image processing took too long. More than 2 frames behind.  }  else {  	rawDepthData = new short[DFrame.PixelDataLength];  	DFrame.CopyPixelDataTo (rawDepthData);  	var pixels = new byte[640 * 480 * 4];  	const int BlueIndex = 0;  	const int GreenIndex = 1;  	const int RedIndex = 2;  	const int AlphaIndex = 3;  	for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  		// Calculate the distance represented by the two depth bytes  		int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  		// Map the distance to an intesity that can be represented in RGB  		var intensity = CalculateIntensityFromDistance (depth);  		if (depth >= 0 && depth < 4000) {  			// Apply the intensity to the color channels  			pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = intensity;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else if (depth == -1) {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 255;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  		else {  			pixels [colorIndex + BlueIndex] = 0;  			//blue  			pixels [colorIndex + GreenIndex] = 0;  			//green  			pixels [colorIndex + RedIndex] = 0;  			//red  			pixels [colorIndex + AlphaIndex] = 255 / 4;  			// alpha  		}  	}  	receivedData = true;  	BitmapSource source = BitmapSource.Create (640' 480' 96' 96' PixelFormats.Bgra32' null' pixels' 640 * 4);  	depthImage.Source = source;  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < rawDepthData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) {  	// Calculate the distance represented by the two depth bytes  	int depth = rawDepthData [depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;  	// Map the distance to an intesity that can be represented in RGB  	var intensity = CalculateIntensityFromDistance (depth);  	if (depth >= 0 && depth < 4000) {  		// Apply the intensity to the color channels  		pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = intensity;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else if (depth == -1) {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 255;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  	else {  		pixels [colorIndex + BlueIndex] = 0;  		//blue  		pixels [colorIndex + GreenIndex] = 0;  		//green  		pixels [colorIndex + RedIndex] = 0;  		//red  		pixels [colorIndex + AlphaIndex] = 255 / 4;  		// alpha  	}  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: colorIndex += 4
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth >= 0 && depth < 4000) {  	// Apply the intensity to the color channels  	pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = intensity;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + BlueIndex] = (byte)(255 - intensity);  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + AlphaIndex] = 255 / 4;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + AlphaIndex] = 255 / 4;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: if (depth == -1) {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 255;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  else {  	pixels [colorIndex + BlueIndex] = 0;  	//blue  	pixels [colorIndex + GreenIndex] = 0;  	//green  	pixels [colorIndex + RedIndex] = 0;  	//red  	pixels [colorIndex + AlphaIndex] = 255 / 4;  	// alpha  }  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + GreenIndex] = 255;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + AlphaIndex] = 255 / 4;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + AlphaIndex] = 255 / 4;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + AlphaIndex] = 255 / 4;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,sensor_DepthFrameReady,The following statement contains a magic number: pixels [colorIndex + AlphaIndex] = 255 / 4;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: if (newMax > 0)  	return (byte)(255 - (255 * newMax / (MaxDepthDistanceOffset)));  else  	return (byte)255;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: if (newMax > 0)  	return (byte)(255 - (255 * newMax / (MaxDepthDistanceOffset)));  else  	return (byte)255;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: if (newMax > 0)  	return (byte)(255 - (255 * newMax / (MaxDepthDistanceOffset)));  else  	return (byte)255;  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: return (byte)(255 - (255 * newMax / (MaxDepthDistanceOffset)));  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: return (byte)(255 - (255 * newMax / (MaxDepthDistanceOffset)));  
Magic Number,KinectDepthApplication1,MainWindow,C:\repos\VisionWithGrace_cv\GoodStart\GoodStart\MainWindow.xaml.cs,CalculateIntensityFromDistance,The following statement contains a magic number: return (byte)255;  
