Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,LinearSubsample,Cyclomatic complexity of the method is 9
Complex Method,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,Cyclomatic complexity of the method is 10
Complex Method,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinTwoInterpolatables,Cyclomatic complexity of the method is 15
Long Statement,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,Peek,The length of the statement  "			return (stream.Read (buffer.Array' 0' elementSize) > 0) ? (T)Marshal.PtrToStructure (buffer.AddrOfPinnedObject ()' typeof(T)) : new T (); " is 137.
Empty Catch Block,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,ExecuteCmd,The method has an empty catch block.
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,BinaryFileStorage,The following statement contains a magic number: using (PinnedArray<Byte> buffer = new PinnedArray<byte> (size))  	using (FileStream stream = _fileInfo.OpenWrite ())  		using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize)) {  			IntPtr ptr = buffer.AddrOfPinnedObject ();  			foreach (T s in samples) {  				Marshal.StructureToPtr (s' ptr' false);  				bufferStream.Write (buffer.Array' 0' size);  			}  		}  
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,BinaryFileStorage,The following statement contains a magic number: using (FileStream stream = _fileInfo.OpenWrite ())  	using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize)) {  		IntPtr ptr = buffer.AddrOfPinnedObject ();  		foreach (T s in samples) {  			Marshal.StructureToPtr (s' ptr' false);  			bufferStream.Write (buffer.Array' 0' size);  		}  	}  
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,BinaryFileStorage,The following statement contains a magic number: using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize)) {  	IntPtr ptr = buffer.AddrOfPinnedObject ();  	foreach (T s in samples) {  		Marshal.StructureToPtr (s' ptr' false);  		bufferStream.Write (buffer.Array' 0' size);  	}  }  
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,GetSubsamples,The following statement contains a magic number: using (FileStream stream = _fileInfo.OpenRead ())  	using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize))  		using (PinnedArray<Byte> buffer = new PinnedArray<byte> (bufferSize))  			using (PinnedArray<T> structure = new PinnedArray<T> (subsampleRate)) {  				IntPtr structAddr = structure.AddrOfPinnedObject ();  				IntPtr addr = buffer.AddrOfPinnedObject ();  				while (bufferStream.Read (buffer.Array' 0' bufferSize) > 0) {  					Toolbox.memcpy (structAddr' addr' bufferSize);  					yield return structure.Array [0];  				}  			}  
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,GetSubsamples,The following statement contains a magic number: using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize))  	using (PinnedArray<Byte> buffer = new PinnedArray<byte> (bufferSize))  		using (PinnedArray<T> structure = new PinnedArray<T> (subsampleRate)) {  			IntPtr structAddr = structure.AddrOfPinnedObject ();  			IntPtr addr = buffer.AddrOfPinnedObject ();  			while (bufferStream.Read (buffer.Array' 0' bufferSize) > 0) {  				Toolbox.memcpy (structAddr' addr' bufferSize);  				yield return structure.Array [0];  			}  		}  
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,GetEnumerator,The following statement contains a magic number: using (FileStream stream = _fileInfo.OpenRead ())  	using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize))  		using (PinnedArray<Byte> buffer = new PinnedArray<byte> (elementSize))  			using (PinnedArray<T> structure = new PinnedArray<T> (1)) {  				IntPtr structAddr = structure.AddrOfPinnedObject ();  				IntPtr addr = buffer.AddrOfPinnedObject ();  				while (bufferStream.Read (buffer.Array' 0' elementSize) > 0) {  					Toolbox.memcpy (structAddr' addr' elementSize);  					yield return structure.Array [0];  				}  			}  
Magic Number,Emgu.Util,BinaryFileStorage,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\BinaryFileStorage.cs,GetEnumerator,The following statement contains a magic number: using (BufferedStream bufferStream = new BufferedStream (stream' _trunkSize <= 0 ? 4096 : _trunkSize))  	using (PinnedArray<Byte> buffer = new PinnedArray<byte> (elementSize))  		using (PinnedArray<T> structure = new PinnedArray<T> (1)) {  			IntPtr structAddr = structure.AddrOfPinnedObject ();  			IntPtr addr = buffer.AddrOfPinnedObject ();  			while (bufferStream.Read (buffer.Array' 0' elementSize) > 0) {  				Toolbox.memcpy (structAddr' addr' elementSize);  				yield return structure.Array [0];  			}  		}  
Magic Number,Emgu.Util,Platform,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Platform.cs,Platform,The following statement contains a magic number: _os = ((p == 4) || (p == 128)) ? OS.Linux : OS.Windows;  
Magic Number,Emgu.Util,Platform,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Platform.cs,Platform,The following statement contains a magic number: _os = ((p == 4) || (p == 128)) ? OS.Linux : OS.Windows;  
Magic Number,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,The following statement contains a magic number: if (enums.Length == 0)  	yield break;  else if (enums.Length == 1) {  	foreach (T sample in enums [0])  		yield return sample;  }  else if (enums.Length == 2) {  	foreach (T sample in JoinTwoInterpolatables (enums [0]' enums [1]))  		yield return sample;  }  else {  	int middle = enums.Length / 2;  	IEnumerable<T>[] lower = new IEnumerable<T>[middle];  	IEnumerable<T>[] upper = new IEnumerable<T>[enums.Length - middle];  	Array.Copy (enums' lower' middle);  	Array.Copy (enums' middle' upper' 0' enums.Length - middle);  	foreach (T sample in JoinTwoInterpolatables<T> (JoinInterpolatables<T> (lower)' JoinInterpolatables<T> (upper)))  		yield return sample;  }  
Magic Number,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,The following statement contains a magic number: if (enums.Length == 0)  	yield break;  else if (enums.Length == 1) {  	foreach (T sample in enums [0])  		yield return sample;  }  else if (enums.Length == 2) {  	foreach (T sample in JoinTwoInterpolatables (enums [0]' enums [1]))  		yield return sample;  }  else {  	int middle = enums.Length / 2;  	IEnumerable<T>[] lower = new IEnumerable<T>[middle];  	IEnumerable<T>[] upper = new IEnumerable<T>[enums.Length - middle];  	Array.Copy (enums' lower' middle);  	Array.Copy (enums' middle' upper' 0' enums.Length - middle);  	foreach (T sample in JoinTwoInterpolatables<T> (JoinInterpolatables<T> (lower)' JoinInterpolatables<T> (upper)))  		yield return sample;  }  
Magic Number,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,The following statement contains a magic number: if (enums.Length == 1) {  	foreach (T sample in enums [0])  		yield return sample;  }  else if (enums.Length == 2) {  	foreach (T sample in JoinTwoInterpolatables (enums [0]' enums [1]))  		yield return sample;  }  else {  	int middle = enums.Length / 2;  	IEnumerable<T>[] lower = new IEnumerable<T>[middle];  	IEnumerable<T>[] upper = new IEnumerable<T>[enums.Length - middle];  	Array.Copy (enums' lower' middle);  	Array.Copy (enums' middle' upper' 0' enums.Length - middle);  	foreach (T sample in JoinTwoInterpolatables<T> (JoinInterpolatables<T> (lower)' JoinInterpolatables<T> (upper)))  		yield return sample;  }  
Magic Number,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,The following statement contains a magic number: if (enums.Length == 1) {  	foreach (T sample in enums [0])  		yield return sample;  }  else if (enums.Length == 2) {  	foreach (T sample in JoinTwoInterpolatables (enums [0]' enums [1]))  		yield return sample;  }  else {  	int middle = enums.Length / 2;  	IEnumerable<T>[] lower = new IEnumerable<T>[middle];  	IEnumerable<T>[] upper = new IEnumerable<T>[enums.Length - middle];  	Array.Copy (enums' lower' middle);  	Array.Copy (enums' middle' upper' 0' enums.Length - middle);  	foreach (T sample in JoinTwoInterpolatables<T> (JoinInterpolatables<T> (lower)' JoinInterpolatables<T> (upper)))  		yield return sample;  }  
Magic Number,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,The following statement contains a magic number: if (enums.Length == 2) {  	foreach (T sample in JoinTwoInterpolatables (enums [0]' enums [1]))  		yield return sample;  }  else {  	int middle = enums.Length / 2;  	IEnumerable<T>[] lower = new IEnumerable<T>[middle];  	IEnumerable<T>[] upper = new IEnumerable<T>[enums.Length - middle];  	Array.Copy (enums' lower' middle);  	Array.Copy (enums' middle' upper' 0' enums.Length - middle);  	foreach (T sample in JoinTwoInterpolatables<T> (JoinInterpolatables<T> (lower)' JoinInterpolatables<T> (upper)))  		yield return sample;  }  
Magic Number,Emgu.Util,Toolbox,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.Util\Toolbox.cs,JoinInterpolatables,The following statement contains a magic number: if (enums.Length == 2) {  	foreach (T sample in JoinTwoInterpolatables (enums [0]' enums [1]))  		yield return sample;  }  else {  	int middle = enums.Length / 2;  	IEnumerable<T>[] lower = new IEnumerable<T>[middle];  	IEnumerable<T>[] upper = new IEnumerable<T>[enums.Length - middle];  	Array.Copy (enums' lower' middle);  	Array.Copy (enums' middle' upper' 0' enums.Length - middle);  	foreach (T sample in JoinTwoInterpolatables<T> (JoinInterpolatables<T> (lower)' JoinInterpolatables<T> (upper)))  		yield return sample;  }  
