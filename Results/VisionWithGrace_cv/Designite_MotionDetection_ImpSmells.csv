Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,Cyclomatic complexity of the method is 8
Long Statement,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The length of the statement  "			UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount)); " is 130.
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,Form1,The following statement contains a magic number: if (_capture != null)//if camera capture has been successfully created   {  	_motionHistory = new MotionHistory (1.0' //in second' the duration of motion history you wants to keep  	0.05' //in second' parameter for cvCalcMotionGradient  	0.5);  	//in second' parameter for cvCalcMotionGradient  	Application.Idle += ProcessFrame;  }  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,Form1,The following statement contains a magic number: if (_capture != null)//if camera capture has been successfully created   {  	_motionHistory = new MotionHistory (1.0' //in second' the duration of motion history you wants to keep  	0.05' //in second' parameter for cvCalcMotionGradient  	0.5);  	//in second' parameter for cvCalcMotionGradient  	Application.Idle += ProcessFrame;  }  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,Form1,The following statement contains a magic number: _motionHistory = new MotionHistory (1.0' //in second' the duration of motion history you wants to keep  0.05' //in second' parameter for cvCalcMotionGradient  0.5);  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,Form1,The following statement contains a magic number: _motionHistory = new MotionHistory (1.0' //in second' the duration of motion history you wants to keep  0.05' //in second' parameter for cvCalcMotionGradient  0.5);  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: using (Image<Bgr' Byte> image = _capture.QueryFrame ())  	using (MemStorage storage = new MemStorage ())//create storage for motion components  	 {  		if (_forgroundDetector == null) {  			//_forgroundDetector = new BGCodeBookModel<Bgr>();  			//_forgroundDetector = new FGDetector<Bgr>(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD);  			_forgroundDetector = new BGStatModel<Bgr> (image' Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL);  		}  		_forgroundDetector.Update (image);  		capturedImageBox.Image = image;  		//update the motion history  		_motionHistory.Update (_forgroundDetector.ForgroundMask);  		#region get a copy of the motion mask and enhance its color  		double[] minValues' maxValues;  		Point[] minLoc' maxLoc;  		_motionHistory.Mask.MinMax (out minValues' out maxValues' out minLoc' out maxLoc);  		Image<Gray' Byte> motionMask = _motionHistory.Mask.Mul (255.0 / maxValues [0]);  		#endregion  		//create the motion image   		Image<Bgr' Byte> motionImage = new Image<Bgr' byte> (motionMask.Size);  		//display the motion pixels in blue (first channel)  		motionImage [0] = motionMask;  		//Threshold to define a motion area' reduce the value to detect smaller motion  		double minArea = 100;  		storage.Clear ();  		//clear the storage  		Seq<MCvConnectedComp> motionComponents = _motionHistory.GetMotionComponents (storage);  		//iterate through each of the motion component  		foreach (MCvConnectedComp comp in motionComponents) {  			//reject the components that have small area;  			if (comp.area < minArea)  				continue;  			// find the angle and motion pixel count of the specific area  			double angle' motionPixelCount;  			_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  			//reject the area that contains too few motion  			if (motionPixelCount < comp.area * 0.05)  				continue;  			//Draw each individual motion in red  			DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  		}  		// find and draw the overall motion angle  		double overallAngle' overallMotionPixelCount;  		_motionHistory.MotionInfo (motionMask.ROI' out overallAngle' out overallMotionPixelCount);  		DrawMotion (motionImage' motionMask.ROI' overallAngle' new Bgr (Color.Green));  		//Display the amount of motions found on the current image  		UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount));  		//Display the image of the motion  		motionImageBox.Image = motionImage;  	}  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: using (Image<Bgr' Byte> image = _capture.QueryFrame ())  	using (MemStorage storage = new MemStorage ())//create storage for motion components  	 {  		if (_forgroundDetector == null) {  			//_forgroundDetector = new BGCodeBookModel<Bgr>();  			//_forgroundDetector = new FGDetector<Bgr>(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD);  			_forgroundDetector = new BGStatModel<Bgr> (image' Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL);  		}  		_forgroundDetector.Update (image);  		capturedImageBox.Image = image;  		//update the motion history  		_motionHistory.Update (_forgroundDetector.ForgroundMask);  		#region get a copy of the motion mask and enhance its color  		double[] minValues' maxValues;  		Point[] minLoc' maxLoc;  		_motionHistory.Mask.MinMax (out minValues' out maxValues' out minLoc' out maxLoc);  		Image<Gray' Byte> motionMask = _motionHistory.Mask.Mul (255.0 / maxValues [0]);  		#endregion  		//create the motion image   		Image<Bgr' Byte> motionImage = new Image<Bgr' byte> (motionMask.Size);  		//display the motion pixels in blue (first channel)  		motionImage [0] = motionMask;  		//Threshold to define a motion area' reduce the value to detect smaller motion  		double minArea = 100;  		storage.Clear ();  		//clear the storage  		Seq<MCvConnectedComp> motionComponents = _motionHistory.GetMotionComponents (storage);  		//iterate through each of the motion component  		foreach (MCvConnectedComp comp in motionComponents) {  			//reject the components that have small area;  			if (comp.area < minArea)  				continue;  			// find the angle and motion pixel count of the specific area  			double angle' motionPixelCount;  			_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  			//reject the area that contains too few motion  			if (motionPixelCount < comp.area * 0.05)  				continue;  			//Draw each individual motion in red  			DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  		}  		// find and draw the overall motion angle  		double overallAngle' overallMotionPixelCount;  		_motionHistory.MotionInfo (motionMask.ROI' out overallAngle' out overallMotionPixelCount);  		DrawMotion (motionImage' motionMask.ROI' overallAngle' new Bgr (Color.Green));  		//Display the amount of motions found on the current image  		UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount));  		//Display the image of the motion  		motionImageBox.Image = motionImage;  	}  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: using (Image<Bgr' Byte> image = _capture.QueryFrame ())  	using (MemStorage storage = new MemStorage ())//create storage for motion components  	 {  		if (_forgroundDetector == null) {  			//_forgroundDetector = new BGCodeBookModel<Bgr>();  			//_forgroundDetector = new FGDetector<Bgr>(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD);  			_forgroundDetector = new BGStatModel<Bgr> (image' Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL);  		}  		_forgroundDetector.Update (image);  		capturedImageBox.Image = image;  		//update the motion history  		_motionHistory.Update (_forgroundDetector.ForgroundMask);  		#region get a copy of the motion mask and enhance its color  		double[] minValues' maxValues;  		Point[] minLoc' maxLoc;  		_motionHistory.Mask.MinMax (out minValues' out maxValues' out minLoc' out maxLoc);  		Image<Gray' Byte> motionMask = _motionHistory.Mask.Mul (255.0 / maxValues [0]);  		#endregion  		//create the motion image   		Image<Bgr' Byte> motionImage = new Image<Bgr' byte> (motionMask.Size);  		//display the motion pixels in blue (first channel)  		motionImage [0] = motionMask;  		//Threshold to define a motion area' reduce the value to detect smaller motion  		double minArea = 100;  		storage.Clear ();  		//clear the storage  		Seq<MCvConnectedComp> motionComponents = _motionHistory.GetMotionComponents (storage);  		//iterate through each of the motion component  		foreach (MCvConnectedComp comp in motionComponents) {  			//reject the components that have small area;  			if (comp.area < minArea)  				continue;  			// find the angle and motion pixel count of the specific area  			double angle' motionPixelCount;  			_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  			//reject the area that contains too few motion  			if (motionPixelCount < comp.area * 0.05)  				continue;  			//Draw each individual motion in red  			DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  		}  		// find and draw the overall motion angle  		double overallAngle' overallMotionPixelCount;  		_motionHistory.MotionInfo (motionMask.ROI' out overallAngle' out overallMotionPixelCount);  		DrawMotion (motionImage' motionMask.ROI' overallAngle' new Bgr (Color.Green));  		//Display the amount of motions found on the current image  		UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount));  		//Display the image of the motion  		motionImageBox.Image = motionImage;  	}  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: using (MemStorage storage = new MemStorage ())//create storage for motion components   {  	if (_forgroundDetector == null) {  		//_forgroundDetector = new BGCodeBookModel<Bgr>();  		//_forgroundDetector = new FGDetector<Bgr>(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD);  		_forgroundDetector = new BGStatModel<Bgr> (image' Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL);  	}  	_forgroundDetector.Update (image);  	capturedImageBox.Image = image;  	//update the motion history  	_motionHistory.Update (_forgroundDetector.ForgroundMask);  	#region get a copy of the motion mask and enhance its color  	double[] minValues' maxValues;  	Point[] minLoc' maxLoc;  	_motionHistory.Mask.MinMax (out minValues' out maxValues' out minLoc' out maxLoc);  	Image<Gray' Byte> motionMask = _motionHistory.Mask.Mul (255.0 / maxValues [0]);  	#endregion  	//create the motion image   	Image<Bgr' Byte> motionImage = new Image<Bgr' byte> (motionMask.Size);  	//display the motion pixels in blue (first channel)  	motionImage [0] = motionMask;  	//Threshold to define a motion area' reduce the value to detect smaller motion  	double minArea = 100;  	storage.Clear ();  	//clear the storage  	Seq<MCvConnectedComp> motionComponents = _motionHistory.GetMotionComponents (storage);  	//iterate through each of the motion component  	foreach (MCvConnectedComp comp in motionComponents) {  		//reject the components that have small area;  		if (comp.area < minArea)  			continue;  		// find the angle and motion pixel count of the specific area  		double angle' motionPixelCount;  		_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  		//reject the area that contains too few motion  		if (motionPixelCount < comp.area * 0.05)  			continue;  		//Draw each individual motion in red  		DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  	}  	// find and draw the overall motion angle  	double overallAngle' overallMotionPixelCount;  	_motionHistory.MotionInfo (motionMask.ROI' out overallAngle' out overallMotionPixelCount);  	DrawMotion (motionImage' motionMask.ROI' overallAngle' new Bgr (Color.Green));  	//Display the amount of motions found on the current image  	UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount));  	//Display the image of the motion  	motionImageBox.Image = motionImage;  }  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: using (MemStorage storage = new MemStorage ())//create storage for motion components   {  	if (_forgroundDetector == null) {  		//_forgroundDetector = new BGCodeBookModel<Bgr>();  		//_forgroundDetector = new FGDetector<Bgr>(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD);  		_forgroundDetector = new BGStatModel<Bgr> (image' Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL);  	}  	_forgroundDetector.Update (image);  	capturedImageBox.Image = image;  	//update the motion history  	_motionHistory.Update (_forgroundDetector.ForgroundMask);  	#region get a copy of the motion mask and enhance its color  	double[] minValues' maxValues;  	Point[] minLoc' maxLoc;  	_motionHistory.Mask.MinMax (out minValues' out maxValues' out minLoc' out maxLoc);  	Image<Gray' Byte> motionMask = _motionHistory.Mask.Mul (255.0 / maxValues [0]);  	#endregion  	//create the motion image   	Image<Bgr' Byte> motionImage = new Image<Bgr' byte> (motionMask.Size);  	//display the motion pixels in blue (first channel)  	motionImage [0] = motionMask;  	//Threshold to define a motion area' reduce the value to detect smaller motion  	double minArea = 100;  	storage.Clear ();  	//clear the storage  	Seq<MCvConnectedComp> motionComponents = _motionHistory.GetMotionComponents (storage);  	//iterate through each of the motion component  	foreach (MCvConnectedComp comp in motionComponents) {  		//reject the components that have small area;  		if (comp.area < minArea)  			continue;  		// find the angle and motion pixel count of the specific area  		double angle' motionPixelCount;  		_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  		//reject the area that contains too few motion  		if (motionPixelCount < comp.area * 0.05)  			continue;  		//Draw each individual motion in red  		DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  	}  	// find and draw the overall motion angle  	double overallAngle' overallMotionPixelCount;  	_motionHistory.MotionInfo (motionMask.ROI' out overallAngle' out overallMotionPixelCount);  	DrawMotion (motionImage' motionMask.ROI' overallAngle' new Bgr (Color.Green));  	//Display the amount of motions found on the current image  	UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount));  	//Display the image of the motion  	motionImageBox.Image = motionImage;  }  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: using (MemStorage storage = new MemStorage ())//create storage for motion components   {  	if (_forgroundDetector == null) {  		//_forgroundDetector = new BGCodeBookModel<Bgr>();  		//_forgroundDetector = new FGDetector<Bgr>(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD);  		_forgroundDetector = new BGStatModel<Bgr> (image' Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL);  	}  	_forgroundDetector.Update (image);  	capturedImageBox.Image = image;  	//update the motion history  	_motionHistory.Update (_forgroundDetector.ForgroundMask);  	#region get a copy of the motion mask and enhance its color  	double[] minValues' maxValues;  	Point[] minLoc' maxLoc;  	_motionHistory.Mask.MinMax (out minValues' out maxValues' out minLoc' out maxLoc);  	Image<Gray' Byte> motionMask = _motionHistory.Mask.Mul (255.0 / maxValues [0]);  	#endregion  	//create the motion image   	Image<Bgr' Byte> motionImage = new Image<Bgr' byte> (motionMask.Size);  	//display the motion pixels in blue (first channel)  	motionImage [0] = motionMask;  	//Threshold to define a motion area' reduce the value to detect smaller motion  	double minArea = 100;  	storage.Clear ();  	//clear the storage  	Seq<MCvConnectedComp> motionComponents = _motionHistory.GetMotionComponents (storage);  	//iterate through each of the motion component  	foreach (MCvConnectedComp comp in motionComponents) {  		//reject the components that have small area;  		if (comp.area < minArea)  			continue;  		// find the angle and motion pixel count of the specific area  		double angle' motionPixelCount;  		_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  		//reject the area that contains too few motion  		if (motionPixelCount < comp.area * 0.05)  			continue;  		//Draw each individual motion in red  		DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  	}  	// find and draw the overall motion angle  	double overallAngle' overallMotionPixelCount;  	_motionHistory.MotionInfo (motionMask.ROI' out overallAngle' out overallMotionPixelCount);  	DrawMotion (motionImage' motionMask.ROI' overallAngle' new Bgr (Color.Green));  	//Display the amount of motions found on the current image  	UpdateText (String.Format ("Total Motions found: {0}; Motion Pixel count: {1}"' motionComponents.Total' overallMotionPixelCount));  	//Display the image of the motion  	motionImageBox.Image = motionImage;  }  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: foreach (MCvConnectedComp comp in motionComponents) {  	//reject the components that have small area;  	if (comp.area < minArea)  		continue;  	// find the angle and motion pixel count of the specific area  	double angle' motionPixelCount;  	_motionHistory.MotionInfo (comp.rect' out angle' out motionPixelCount);  	//reject the area that contains too few motion  	if (motionPixelCount < comp.area * 0.05)  		continue;  	//Draw each individual motion in red  	DrawMotion (motionImage' comp.rect' angle' new Bgr (Color.Red));  }  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,ProcessFrame,The following statement contains a magic number: if (motionPixelCount < comp.area * 0.05)  	continue;  
Magic Number,MotionDetection,Form1,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\MotionDetection\Form1.cs,DrawMotion,The following statement contains a magic number: image.Draw (line' color' 2);  
