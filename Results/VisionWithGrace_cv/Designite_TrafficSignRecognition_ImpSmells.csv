Implementation smell,Namespace,Class,File,Method,Description
Complex Method,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,Cyclomatic complexity of the method is 12
Long Statement,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The length of the statement  "		AddLabelAndImage (ref startPoint' String.Format ("Stop Sign [{0}'{1}]:"' rect.Location.Y + rect.Width / 2' rect.Location.Y + rect.Height / 2)' stopSignList [i]); " is 161.
Long Statement,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,DetectStopSign,The length of the statement  "			Contour<Point> contours = canny.FindContours (Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE' Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE' stor); " is 150.
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The following statement contains a magic number: for (int i = 0; i < stopSignList.Count; i++) {  	Rectangle rect = stopSignBoxList [i];  	AddLabelAndImage (ref startPoint' String.Format ("Stop Sign [{0}'{1}]:"' rect.Location.Y + rect.Width / 2' rect.Location.Y + rect.Height / 2)' stopSignList [i]);  	image.Draw (rect' new Bgr (Color.Aquamarine)' 2);  }  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The following statement contains a magic number: for (int i = 0; i < stopSignList.Count; i++) {  	Rectangle rect = stopSignBoxList [i];  	AddLabelAndImage (ref startPoint' String.Format ("Stop Sign [{0}'{1}]:"' rect.Location.Y + rect.Width / 2' rect.Location.Y + rect.Height / 2)' stopSignList [i]);  	image.Draw (rect' new Bgr (Color.Aquamarine)' 2);  }  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The following statement contains a magic number: for (int i = 0; i < stopSignList.Count; i++) {  	Rectangle rect = stopSignBoxList [i];  	AddLabelAndImage (ref startPoint' String.Format ("Stop Sign [{0}'{1}]:"' rect.Location.Y + rect.Width / 2' rect.Location.Y + rect.Height / 2)' stopSignList [i]);  	image.Draw (rect' new Bgr (Color.Aquamarine)' 2);  }  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The following statement contains a magic number: AddLabelAndImage (ref startPoint' String.Format ("Stop Sign [{0}'{1}]:"' rect.Location.Y + rect.Width / 2' rect.Location.Y + rect.Height / 2)' stopSignList [i]);  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The following statement contains a magic number: AddLabelAndImage (ref startPoint' String.Format ("Stop Sign [{0}'{1}]:"' rect.Location.Y + rect.Width / 2' rect.Location.Y + rect.Height / 2)' stopSignList [i]);  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,ProcessImage,The following statement contains a magic number: image.Draw (rect' new Bgr (Color.Aquamarine)' 2);  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,AddLabelAndImage,The following statement contains a magic number: label.Width = 100;  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,AddLabelAndImage,The following statement contains a magic number: label.Height = 30;  
Magic Number,TrafficSignRecognition,TrafficSignRecognitionForm,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\TrafficSignRecognitionForm.cs,AddLabelAndImage,The following statement contains a magic number: startPoint.Y += box.Height + 10;  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _detector = new SURFDetector (500' false);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,StopSignDetector,The following statement contains a magic number: _octagon.PushMulti (new Point[] {  	new Point (1' 0)'  	new Point (2' 0)'  	new Point (3' 1)'  	new Point (3' 2)'  	new Point (2' 3)'  	new Point (1' 3)'  	new Point (0' 2)'  	new Point (0' 1)  }' Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: using (Image<Hsv' Byte> hsv = image.Convert<Hsv' Byte> ()) {  	Image<Gray' Byte>[] channels = hsv.Split ();  	//channels[0] is the mask for hue less than 20 or larger than 160  	CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  	channels [0]._Not ();  	//channels[1] is the mask for satuation of at least 10' this is mainly used to filter out white pixels  	channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  	CvInvoke.cvAnd (channels [0]' channels [1]' channels [0]' IntPtr.Zero);  	channels [1].Dispose ();  	channels [2].Dispose ();  	return channels [0];  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: using (Image<Hsv' Byte> hsv = image.Convert<Hsv' Byte> ()) {  	Image<Gray' Byte>[] channels = hsv.Split ();  	//channels[0] is the mask for hue less than 20 or larger than 160  	CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  	channels [0]._Not ();  	//channels[1] is the mask for satuation of at least 10' this is mainly used to filter out white pixels  	channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  	CvInvoke.cvAnd (channels [0]' channels [1]' channels [0]' IntPtr.Zero);  	channels [1].Dispose ();  	channels [2].Dispose ();  	return channels [0];  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: using (Image<Hsv' Byte> hsv = image.Convert<Hsv' Byte> ()) {  	Image<Gray' Byte>[] channels = hsv.Split ();  	//channels[0] is the mask for hue less than 20 or larger than 160  	CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  	channels [0]._Not ();  	//channels[1] is the mask for satuation of at least 10' this is mainly used to filter out white pixels  	channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  	CvInvoke.cvAnd (channels [0]' channels [1]' channels [0]' IntPtr.Zero);  	channels [1].Dispose ();  	channels [2].Dispose ();  	return channels [0];  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: using (Image<Hsv' Byte> hsv = image.Convert<Hsv' Byte> ()) {  	Image<Gray' Byte>[] channels = hsv.Split ();  	//channels[0] is the mask for hue less than 20 or larger than 160  	CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  	channels [0]._Not ();  	//channels[1] is the mask for satuation of at least 10' this is mainly used to filter out white pixels  	channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  	CvInvoke.cvAnd (channels [0]' channels [1]' channels [0]' IntPtr.Zero);  	channels [1].Dispose ();  	channels [2].Dispose ();  	return channels [0];  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: using (Image<Hsv' Byte> hsv = image.Convert<Hsv' Byte> ()) {  	Image<Gray' Byte>[] channels = hsv.Split ();  	//channels[0] is the mask for hue less than 20 or larger than 160  	CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  	channels [0]._Not ();  	//channels[1] is the mask for satuation of at least 10' this is mainly used to filter out white pixels  	channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  	CvInvoke.cvAnd (channels [0]' channels [1]' channels [0]' IntPtr.Zero);  	channels [1].Dispose ();  	channels [2].Dispose ();  	return channels [0];  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: CvInvoke.cvInRangeS (channels [0]' new MCvScalar (20)' new MCvScalar (160)' channels [0]);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: channels [1]._ThresholdBinary (new Gray (10)' new Gray (255.0));  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,GetRedPixelMask,The following statement contains a magic number: channels [2].Dispose ();  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: for (; contours != null; contours = contours.HNext) {  	contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  	if (contours.Area > 200) {  		double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  		if (ratio > 0.1)//not a good match of contour shape  		 {  			Contour<Point> child = contours.VNext;  			if (child != null)  				FindStopSign (img' stopSignList' boxList' child);  			continue;  		}  		Rectangle box = contours.BoundingRectangle;  		Image<Gray' Byte> candidate;  		using (Image<Bgr' Byte> tmp = img.Copy (box))  			candidate = tmp.Convert<Gray' byte> ();  		//set the value of pixels not in the contour region to zero  		using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  			mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  			double mean = CvInvoke.cvAvg (candidate' mask).v0;  			candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  			candidate._Not ();  			mask._Not ();  			candidate.SetValue (0' mask);  		}  		ImageFeature[] features = _detector.DetectFeatures (candidate' null);  		Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  		int goodMatchCount = 0;  		foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  			if (ms.SimilarFeatures [0].Distance < 0.5)  				goodMatchCount++;  		if (goodMatchCount >= 10) {  			boxList.Add (box);  			stopSignList.Add (candidate);  		}  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: contours.ApproxPoly (contours.Perimeter * 0.02' 0' contours.Storage);  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (contours.Area > 200) {  	double ratio = CvInvoke.cvMatchShapes (_octagon' contours' Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3' 0);  	if (ratio > 0.1)//not a good match of contour shape  	 {  		Contour<Point> child = contours.VNext;  		if (child != null)  			FindStopSign (img' stopSignList' boxList' child);  		continue;  	}  	Rectangle box = contours.BoundingRectangle;  	Image<Gray' Byte> candidate;  	using (Image<Bgr' Byte> tmp = img.Copy (box))  		candidate = tmp.Convert<Gray' byte> ();  	//set the value of pixels not in the contour region to zero  	using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  		mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  		double mean = CvInvoke.cvAvg (candidate' mask).v0;  		candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  		candidate._Not ();  		mask._Not ();  		candidate.SetValue (0' mask);  	}  	ImageFeature[] features = _detector.DetectFeatures (candidate' null);  	Features2DTracker.MatchedImageFeature[] matchedFeatures = _tracker.MatchFeature (features' 2' 20);  	int goodMatchCount = 0;  	foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  		if (ms.SimilarFeatures [0].Distance < 0.5)  			goodMatchCount++;  	if (goodMatchCount >= 10) {  		boxList.Add (box);  		stopSignList.Add (candidate);  	}  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (ratio > 0.1)//not a good match of contour shape   {  	Contour<Point> child = contours.VNext;  	if (child != null)  		FindStopSign (img' stopSignList' boxList' child);  	continue;  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  	mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  	double mean = CvInvoke.cvAvg (candidate' mask).v0;  	candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  	candidate._Not ();  	mask._Not ();  	candidate.SetValue (0' mask);  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  	mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  	double mean = CvInvoke.cvAvg (candidate' mask).v0;  	candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  	candidate._Not ();  	mask._Not ();  	candidate.SetValue (0' mask);  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: using (Image<Gray' Byte> mask = new Image<Gray' byte> (box.Size)) {  	mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  	double mean = CvInvoke.cvAvg (candidate' mask).v0;  	candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  	candidate._Not ();  	mask._Not ();  	candidate.SetValue (0' mask);  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: mask.Draw (contours' new Gray (255)' new Gray (255)' 0' -1' new Point (-box.X' -box.Y));  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: candidate._ThresholdBinary (new Gray (mean)' new Gray (255.0));  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: foreach (Features2DTracker.MatchedImageFeature ms in matchedFeatures)  	if (ms.SimilarFeatures [0].Distance < 0.5)  		goodMatchCount++;  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (ms.SimilarFeatures [0].Distance < 0.5)  	goodMatchCount++;  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,FindStopSign,The following statement contains a magic number: if (goodMatchCount >= 10) {  	boxList.Add (box);  	stopSignList.Add (candidate);  }  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,DetectStopSign,The following statement contains a magic number: using (Image<Gray' Byte> canny = smoothedRedMask.Erode (3).Dilate (3).Canny (new Gray (100)' new Gray (50)))  	using (MemStorage stor = new MemStorage ()) {  		Contour<Point> contours = canny.FindContours (Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE' Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE' stor);  		FindStopSign (img' stopSignList' boxList' contours);  	}  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,DetectStopSign,The following statement contains a magic number: using (Image<Gray' Byte> canny = smoothedRedMask.Erode (3).Dilate (3).Canny (new Gray (100)' new Gray (50)))  	using (MemStorage stor = new MemStorage ()) {  		Contour<Point> contours = canny.FindContours (Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE' Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE' stor);  		FindStopSign (img' stopSignList' boxList' contours);  	}  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,DetectStopSign,The following statement contains a magic number: using (Image<Gray' Byte> canny = smoothedRedMask.Erode (3).Dilate (3).Canny (new Gray (100)' new Gray (50)))  	using (MemStorage stor = new MemStorage ()) {  		Contour<Point> contours = canny.FindContours (Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE' Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE' stor);  		FindStopSign (img' stopSignList' boxList' contours);  	}  
Magic Number,TrafficSignRecognition,StopSignDetector,C:\repos\VisionWithGrace_cv\libemgucv-2.2.0.1010-win64\Emgu.CV.Example\TrafficSignRecognition\StopSignDetector.cs,DetectStopSign,The following statement contains a magic number: using (Image<Gray' Byte> canny = smoothedRedMask.Erode (3).Dilate (3).Canny (new Gray (100)' new Gray (50)))  	using (MemStorage stor = new MemStorage ()) {  		Contour<Point> contours = canny.FindContours (Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE' Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE' stor);  		FindStopSign (img' stopSignList' boxList' contours);  	}  
