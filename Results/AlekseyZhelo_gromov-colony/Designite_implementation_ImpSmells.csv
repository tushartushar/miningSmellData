Implementation smell,Namespace,Class,File,Method,Description
Complex Method,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,Cyclomatic complexity of the method is 15
Complex Method,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,compareChain,Cyclomatic complexity of the method is 10
Complex Method,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,compareChainByMinPointwiseDeviation,Cyclomatic complexity of the method is 8
Complex Method,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,Cyclomatic complexity of the method is 13
Long Parameter List,implementation.MultigraphImpl,Multigraph,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Multigraph\Multigraph.cs,Multigraph,The method has 5 parameters.
Long Identifier,implementation.Chains,Chain,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Chains\Chain.cs,addForecastSection,The length of the parameter forecastLinkLengthModifier_question is 35.
Long Statement,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The length of the statement  "							if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) { " is 155.
Long Statement,implementation.MultigraphImpl,Multigraph,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Multigraph\Multigraph.cs,addPheromon,The length of the statement  "		graph [chain [i].discrAreaFrom' chain [i].discrAreaTo] [chain [i].length - minDistance].pheromonLevel += chain.getPheromonLevel (); " is 131.
Long Statement,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,Test,The length of the statement  "	Console.WriteLine ("Step = {0:F5}; x = {1:F8};  y = {2:F8}; z = {3:F8}"' task.n_steps' task.Y [0]' task.Y [1]' task.Y [2]); " is 123.
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: for (int i = 0; i < antsCount; i++) {  	int occurrencesCount = 99999;  	int occurrencesCountLast = 199999;  	Chain chain = new Chain ();  	int startingPoint = startObservation - defaultOffset + rnd.Next (91);  	while ((((double)occurrencesCount) / ((double)occurrencesCountLast) < prognosisSignificance) && occurrencesCount > 1) {  		if (occurrencesCount < 99999)  			occurrencesCountLast = occurrencesCount;  		chain.addNextLink (startingPoint);  		occurrencesCount = graph.incrementalOccurrencesSearch (chain);  		startingPoint += chain [chain.Length - 1].length;  		if (startingPoint > startObservation)  			break;  	}  	if (occurrencesCount > 1 && chain.Length > 2 && startingPoint <= startObservation) {  		chain.addForecastSection (startObservation);  		if (chain.hasForecastSection) {  			chains.Add (chain);  			graph.addPheromon (chain);  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: for (int i = 0; i < antsCount; i++) {  	int occurrencesCount = 99999;  	int occurrencesCountLast = 199999;  	Chain chain = new Chain ();  	int startingPoint = startObservation - defaultOffset + rnd.Next (91);  	while ((((double)occurrencesCount) / ((double)occurrencesCountLast) < prognosisSignificance) && occurrencesCount > 1) {  		if (occurrencesCount < 99999)  			occurrencesCountLast = occurrencesCount;  		chain.addNextLink (startingPoint);  		occurrencesCount = graph.incrementalOccurrencesSearch (chain);  		startingPoint += chain [chain.Length - 1].length;  		if (startingPoint > startObservation)  			break;  	}  	if (occurrencesCount > 1 && chain.Length > 2 && startingPoint <= startObservation) {  		chain.addForecastSection (startObservation);  		if (chain.hasForecastSection) {  			chains.Add (chain);  			graph.addPheromon (chain);  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: for (int i = 0; i < antsCount; i++) {  	int occurrencesCount = 99999;  	int occurrencesCountLast = 199999;  	Chain chain = new Chain ();  	int startingPoint = startObservation - defaultOffset + rnd.Next (91);  	while ((((double)occurrencesCount) / ((double)occurrencesCountLast) < prognosisSignificance) && occurrencesCount > 1) {  		if (occurrencesCount < 99999)  			occurrencesCountLast = occurrencesCount;  		chain.addNextLink (startingPoint);  		occurrencesCount = graph.incrementalOccurrencesSearch (chain);  		startingPoint += chain [chain.Length - 1].length;  		if (startingPoint > startObservation)  			break;  	}  	if (occurrencesCount > 1 && chain.Length > 2 && startingPoint <= startObservation) {  		chain.addForecastSection (startObservation);  		if (chain.hasForecastSection) {  			chains.Add (chain);  			graph.addPheromon (chain);  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: for (int i = 0; i < antsCount; i++) {  	int occurrencesCount = 99999;  	int occurrencesCountLast = 199999;  	Chain chain = new Chain ();  	int startingPoint = startObservation - defaultOffset + rnd.Next (91);  	while ((((double)occurrencesCount) / ((double)occurrencesCountLast) < prognosisSignificance) && occurrencesCount > 1) {  		if (occurrencesCount < 99999)  			occurrencesCountLast = occurrencesCount;  		chain.addNextLink (startingPoint);  		occurrencesCount = graph.incrementalOccurrencesSearch (chain);  		startingPoint += chain [chain.Length - 1].length;  		if (startingPoint > startObservation)  			break;  	}  	if (occurrencesCount > 1 && chain.Length > 2 && startingPoint <= startObservation) {  		chain.addForecastSection (startObservation);  		if (chain.hasForecastSection) {  			chains.Add (chain);  			graph.addPheromon (chain);  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: for (int i = 0; i < antsCount; i++) {  	int occurrencesCount = 99999;  	int occurrencesCountLast = 199999;  	Chain chain = new Chain ();  	int startingPoint = startObservation - defaultOffset + rnd.Next (91);  	while ((((double)occurrencesCount) / ((double)occurrencesCountLast) < prognosisSignificance) && occurrencesCount > 1) {  		if (occurrencesCount < 99999)  			occurrencesCountLast = occurrencesCount;  		chain.addNextLink (startingPoint);  		occurrencesCount = graph.incrementalOccurrencesSearch (chain);  		startingPoint += chain [chain.Length - 1].length;  		if (startingPoint > startObservation)  			break;  	}  	if (occurrencesCount > 1 && chain.Length > 2 && startingPoint <= startObservation) {  		chain.addForecastSection (startObservation);  		if (chain.hasForecastSection) {  			chains.Add (chain);  			graph.addPheromon (chain);  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: while ((((double)occurrencesCount) / ((double)occurrencesCountLast) < prognosisSignificance) && occurrencesCount > 1) {  	if (occurrencesCount < 99999)  		occurrencesCountLast = occurrencesCount;  	chain.addNextLink (startingPoint);  	occurrencesCount = graph.incrementalOccurrencesSearch (chain);  	startingPoint += chain [chain.Length - 1].length;  	if (startingPoint > startObservation)  		break;  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: if (occurrencesCount < 99999)  	occurrencesCountLast = occurrencesCount;  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Epoch,The following statement contains a magic number: if (occurrencesCount > 1 && chain.Length > 2 && startingPoint <= startObservation) {  	chain.addForecastSection (startObservation);  	if (chain.hasForecastSection) {  		chains.Add (chain);  		graph.addPheromon (chain);  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int n = startObservationInitial; n < prognoseToObservation; n++) {  	//disentagle' investigate  	Chain bestChain = null;  	int discrAreaOfBestPrognosisChain = -1;  	int lengthOfSelected = 0;  	double minDeviation = Double.MaxValue;  	int prognoseFrom = (n - 100) > 0 ? n - 100 : 0;  	for (int i = prognoseFrom; i < n; i++) {  		foreach (Chain chain in chains) {  			if (chain.Length < 100) {  				bool overlap = true;  				int currLength = 0;  				for (int link = 0; link < chain.nonForecastLinks; link++) {  					if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  						overlap = false;  						break;  					}  					currLength += chain [link].length;  				}  				if (overlap) {  					int length = 0;  					lengthOfSelected = currLength;  					for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  						if (i + currLength == n) {  							if (compareChain (chain' i) < 6) {  								double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  								if (minDeviation > currDeviation) {  									minDeviation = currDeviation;  									discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  									bestChain = chain;  								}  								for (int s = 0; s < chain.Length; s++) {  									length += chain [s].length;  								}  							}  						}  						if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  							break;  						}  						if (k < chain.Length - 1) {  							currLength += chain [k + 1].length;  						}  					}  				}  			}  		}  	}  	double prognosedValue = (discrAreaOfBestPrognosisChain) / (discrAreas) - 1.0 / discrAreas / 2.0;  	prognosis [n] = prognosedValue;  	regenerateChains ();  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int n = startObservationInitial; n < prognoseToObservation; n++) {  	//disentagle' investigate  	Chain bestChain = null;  	int discrAreaOfBestPrognosisChain = -1;  	int lengthOfSelected = 0;  	double minDeviation = Double.MaxValue;  	int prognoseFrom = (n - 100) > 0 ? n - 100 : 0;  	for (int i = prognoseFrom; i < n; i++) {  		foreach (Chain chain in chains) {  			if (chain.Length < 100) {  				bool overlap = true;  				int currLength = 0;  				for (int link = 0; link < chain.nonForecastLinks; link++) {  					if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  						overlap = false;  						break;  					}  					currLength += chain [link].length;  				}  				if (overlap) {  					int length = 0;  					lengthOfSelected = currLength;  					for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  						if (i + currLength == n) {  							if (compareChain (chain' i) < 6) {  								double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  								if (minDeviation > currDeviation) {  									minDeviation = currDeviation;  									discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  									bestChain = chain;  								}  								for (int s = 0; s < chain.Length; s++) {  									length += chain [s].length;  								}  							}  						}  						if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  							break;  						}  						if (k < chain.Length - 1) {  							currLength += chain [k + 1].length;  						}  					}  				}  			}  		}  	}  	double prognosedValue = (discrAreaOfBestPrognosisChain) / (discrAreas) - 1.0 / discrAreas / 2.0;  	prognosis [n] = prognosedValue;  	regenerateChains ();  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int n = startObservationInitial; n < prognoseToObservation; n++) {  	//disentagle' investigate  	Chain bestChain = null;  	int discrAreaOfBestPrognosisChain = -1;  	int lengthOfSelected = 0;  	double minDeviation = Double.MaxValue;  	int prognoseFrom = (n - 100) > 0 ? n - 100 : 0;  	for (int i = prognoseFrom; i < n; i++) {  		foreach (Chain chain in chains) {  			if (chain.Length < 100) {  				bool overlap = true;  				int currLength = 0;  				for (int link = 0; link < chain.nonForecastLinks; link++) {  					if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  						overlap = false;  						break;  					}  					currLength += chain [link].length;  				}  				if (overlap) {  					int length = 0;  					lengthOfSelected = currLength;  					for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  						if (i + currLength == n) {  							if (compareChain (chain' i) < 6) {  								double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  								if (minDeviation > currDeviation) {  									minDeviation = currDeviation;  									discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  									bestChain = chain;  								}  								for (int s = 0; s < chain.Length; s++) {  									length += chain [s].length;  								}  							}  						}  						if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  							break;  						}  						if (k < chain.Length - 1) {  							currLength += chain [k + 1].length;  						}  					}  				}  			}  		}  	}  	double prognosedValue = (discrAreaOfBestPrognosisChain) / (discrAreas) - 1.0 / discrAreas / 2.0;  	prognosis [n] = prognosedValue;  	regenerateChains ();  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int n = startObservationInitial; n < prognoseToObservation; n++) {  	//disentagle' investigate  	Chain bestChain = null;  	int discrAreaOfBestPrognosisChain = -1;  	int lengthOfSelected = 0;  	double minDeviation = Double.MaxValue;  	int prognoseFrom = (n - 100) > 0 ? n - 100 : 0;  	for (int i = prognoseFrom; i < n; i++) {  		foreach (Chain chain in chains) {  			if (chain.Length < 100) {  				bool overlap = true;  				int currLength = 0;  				for (int link = 0; link < chain.nonForecastLinks; link++) {  					if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  						overlap = false;  						break;  					}  					currLength += chain [link].length;  				}  				if (overlap) {  					int length = 0;  					lengthOfSelected = currLength;  					for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  						if (i + currLength == n) {  							if (compareChain (chain' i) < 6) {  								double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  								if (minDeviation > currDeviation) {  									minDeviation = currDeviation;  									discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  									bestChain = chain;  								}  								for (int s = 0; s < chain.Length; s++) {  									length += chain [s].length;  								}  							}  						}  						if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  							break;  						}  						if (k < chain.Length - 1) {  							currLength += chain [k + 1].length;  						}  					}  				}  			}  		}  	}  	double prognosedValue = (discrAreaOfBestPrognosisChain) / (discrAreas) - 1.0 / discrAreas / 2.0;  	prognosis [n] = prognosedValue;  	regenerateChains ();  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int n = startObservationInitial; n < prognoseToObservation; n++) {  	//disentagle' investigate  	Chain bestChain = null;  	int discrAreaOfBestPrognosisChain = -1;  	int lengthOfSelected = 0;  	double minDeviation = Double.MaxValue;  	int prognoseFrom = (n - 100) > 0 ? n - 100 : 0;  	for (int i = prognoseFrom; i < n; i++) {  		foreach (Chain chain in chains) {  			if (chain.Length < 100) {  				bool overlap = true;  				int currLength = 0;  				for (int link = 0; link < chain.nonForecastLinks; link++) {  					if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  						overlap = false;  						break;  					}  					currLength += chain [link].length;  				}  				if (overlap) {  					int length = 0;  					lengthOfSelected = currLength;  					for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  						if (i + currLength == n) {  							if (compareChain (chain' i) < 6) {  								double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  								if (minDeviation > currDeviation) {  									minDeviation = currDeviation;  									discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  									bestChain = chain;  								}  								for (int s = 0; s < chain.Length; s++) {  									length += chain [s].length;  								}  							}  						}  						if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  							break;  						}  						if (k < chain.Length - 1) {  							currLength += chain [k + 1].length;  						}  					}  				}  			}  		}  	}  	double prognosedValue = (discrAreaOfBestPrognosisChain) / (discrAreas) - 1.0 / discrAreas / 2.0;  	prognosis [n] = prognosedValue;  	regenerateChains ();  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int i = prognoseFrom; i < n; i++) {  	foreach (Chain chain in chains) {  		if (chain.Length < 100) {  			bool overlap = true;  			int currLength = 0;  			for (int link = 0; link < chain.nonForecastLinks; link++) {  				if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  					overlap = false;  					break;  				}  				currLength += chain [link].length;  			}  			if (overlap) {  				int length = 0;  				lengthOfSelected = currLength;  				for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  					if (i + currLength == n) {  						if (compareChain (chain' i) < 6) {  							double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  							if (minDeviation > currDeviation) {  								minDeviation = currDeviation;  								discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  								bestChain = chain;  							}  							for (int s = 0; s < chain.Length; s++) {  								length += chain [s].length;  							}  						}  					}  					if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  						break;  					}  					if (k < chain.Length - 1) {  						currLength += chain [k + 1].length;  					}  				}  			}  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int i = prognoseFrom; i < n; i++) {  	foreach (Chain chain in chains) {  		if (chain.Length < 100) {  			bool overlap = true;  			int currLength = 0;  			for (int link = 0; link < chain.nonForecastLinks; link++) {  				if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  					overlap = false;  					break;  				}  				currLength += chain [link].length;  			}  			if (overlap) {  				int length = 0;  				lengthOfSelected = currLength;  				for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  					if (i + currLength == n) {  						if (compareChain (chain' i) < 6) {  							double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  							if (minDeviation > currDeviation) {  								minDeviation = currDeviation;  								discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  								bestChain = chain;  							}  							for (int s = 0; s < chain.Length; s++) {  								length += chain [s].length;  							}  						}  					}  					if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  						break;  					}  					if (k < chain.Length - 1) {  						currLength += chain [k + 1].length;  					}  				}  			}  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: foreach (Chain chain in chains) {  	if (chain.Length < 100) {  		bool overlap = true;  		int currLength = 0;  		for (int link = 0; link < chain.nonForecastLinks; link++) {  			if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  				overlap = false;  				break;  			}  			currLength += chain [link].length;  		}  		if (overlap) {  			int length = 0;  			lengthOfSelected = currLength;  			for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  				if (i + currLength == n) {  					if (compareChain (chain' i) < 6) {  						double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  						if (minDeviation > currDeviation) {  							minDeviation = currDeviation;  							discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  							bestChain = chain;  						}  						for (int s = 0; s < chain.Length; s++) {  							length += chain [s].length;  						}  					}  				}  				if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  					break;  				}  				if (k < chain.Length - 1) {  					currLength += chain [k + 1].length;  				}  			}  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: foreach (Chain chain in chains) {  	if (chain.Length < 100) {  		bool overlap = true;  		int currLength = 0;  		for (int link = 0; link < chain.nonForecastLinks; link++) {  			if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  				overlap = false;  				break;  			}  			currLength += chain [link].length;  		}  		if (overlap) {  			int length = 0;  			lengthOfSelected = currLength;  			for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  				if (i + currLength == n) {  					if (compareChain (chain' i) < 6) {  						double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  						if (minDeviation > currDeviation) {  							minDeviation = currDeviation;  							discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  							bestChain = chain;  						}  						for (int s = 0; s < chain.Length; s++) {  							length += chain [s].length;  						}  					}  				}  				if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  					break;  				}  				if (k < chain.Length - 1) {  					currLength += chain [k + 1].length;  				}  			}  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: if (chain.Length < 100) {  	bool overlap = true;  	int currLength = 0;  	for (int link = 0; link < chain.nonForecastLinks; link++) {  		if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  			overlap = false;  			break;  		}  		currLength += chain [link].length;  	}  	if (overlap) {  		int length = 0;  		lengthOfSelected = currLength;  		for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  			if (i + currLength == n) {  				if (compareChain (chain' i) < 6) {  					double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  					if (minDeviation > currDeviation) {  						minDeviation = currDeviation;  						discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  						bestChain = chain;  					}  					for (int s = 0; s < chain.Length; s++) {  						length += chain [s].length;  					}  				}  			}  			if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  				break;  			}  			if (k < chain.Length - 1) {  				currLength += chain [k + 1].length;  			}  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: if (chain.Length < 100) {  	bool overlap = true;  	int currLength = 0;  	for (int link = 0; link < chain.nonForecastLinks; link++) {  		if (areas.gerAreaForPrognosed (i + currLength) != chain [link].discrAreaFrom) {  			overlap = false;  			break;  		}  		currLength += chain [link].length;  	}  	if (overlap) {  		int length = 0;  		lengthOfSelected = currLength;  		for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  			if (i + currLength == n) {  				if (compareChain (chain' i) < 6) {  					double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  					if (minDeviation > currDeviation) {  						minDeviation = currDeviation;  						discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  						bestChain = chain;  					}  					for (int s = 0; s < chain.Length; s++) {  						length += chain [s].length;  					}  				}  			}  			if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  				break;  			}  			if (k < chain.Length - 1) {  				currLength += chain [k + 1].length;  			}  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: if (overlap) {  	int length = 0;  	lengthOfSelected = currLength;  	for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  		if (i + currLength == n) {  			if (compareChain (chain' i) < 6) {  				double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  				if (minDeviation > currDeviation) {  					minDeviation = currDeviation;  					discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  					bestChain = chain;  				}  				for (int s = 0; s < chain.Length; s++) {  					length += chain [s].length;  				}  			}  		}  		if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  			break;  		}  		if (k < chain.Length - 1) {  			currLength += chain [k + 1].length;  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: for (int k = chain.nonForecastLinks; k < chain.Length; k++) {  	if (i + currLength == n) {  		if (compareChain (chain' i) < 6) {  			double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  			if (minDeviation > currDeviation) {  				minDeviation = currDeviation;  				discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  				bestChain = chain;  			}  			for (int s = 0; s < chain.Length; s++) {  				length += chain [s].length;  			}  		}  	}  	if ((areas.gerAreaForPrognosed (i + currLength) + 1 < chain [k].discrAreaTo) || (areas.gerAreaForPrognosed (i + currLength) - 1 > chain [k].discrAreaTo)) {  		break;  	}  	if (k < chain.Length - 1) {  		currLength += chain [k + 1].length;  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: if (i + currLength == n) {  	if (compareChain (chain' i) < 6) {  		double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  		if (minDeviation > currDeviation) {  			minDeviation = currDeviation;  			discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  			bestChain = chain;  		}  		for (int s = 0; s < chain.Length; s++) {  			length += chain [s].length;  		}  	}  }  
Magic Number,implementation.Ants,AntColony,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Ants\AntColony.cs,Prognose,The following statement contains a magic number: if (compareChain (chain' i) < 6) {  	double currDeviation = compareChainByMinPointwiseDeviation (chain' i);  	if (minDeviation > currDeviation) {  		minDeviation = currDeviation;  		discrAreaOfBestPrognosisChain = chain [k].discrAreaTo;  		bestChain = chain;  	}  	for (int s = 0; s < chain.Length; s++) {  		length += chain [s].length;  	}  }  
Magic Number,implementation.Chains,Chain,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Chains\Chain.cs,addForecastSection,The following statement contains a magic number: for (int i = 0; i < 20; i++) {  	//поиск на след. 20 наблюдениях //XXX was 1 to <= 20  	bool forecastValid = true;  	int forecastToArea = areas.mapping [observation_question + i];  	foreach (Occurrence oc in occurrences) {  		if (areas.mapping [oc.atObservation + i] != forecastToArea) {  			forecastValid = false;  			break;  		}  	}  	if (forecastValid) {  		// если для всех вхождений области дискретизации совпадают' добавляется новое звено  		Link link = new Link (forecastFromArea' forecastToArea' i - forecastLinkLengthModifier_question);  		forecastFromArea = forecastToArea;  		forecastLinkLengthModifier_question = i;  		links.Add (link);  		forecastLinks++;  	}  }  
Magic Number,implementation.Chains,Chain,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Chains\Chain.cs,addForecastSection,The following statement contains a magic number: if (forecastLinks >= 4) {  	//XXX was 4  	hasForecastSection = true;  	lp_question = finalChainObservation + forecastLinkLengthModifier_question;  }  else {  	hasForecastSection = false;  }  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: foreach (Edge e in edges) {  	if (Math.Abs (i - j) > discretizationAreas / 3.0)  		e.pheromonLevel = 300;  	else  		e.pheromonLevel = 100;  }  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: foreach (Edge e in edges) {  	if (Math.Abs (i - j) > discretizationAreas / 3.0)  		e.pheromonLevel = 300;  	else  		e.pheromonLevel = 100;  }  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: foreach (Edge e in edges) {  	if (Math.Abs (i - j) > discretizationAreas / 3.0)  		e.pheromonLevel = 300;  	else  		e.pheromonLevel = 100;  }  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: if (Math.Abs (i - j) > discretizationAreas / 3.0)  	e.pheromonLevel = 300;  else  	e.pheromonLevel = 100;  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: if (Math.Abs (i - j) > discretizationAreas / 3.0)  	e.pheromonLevel = 300;  else  	e.pheromonLevel = 100;  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: if (Math.Abs (i - j) > discretizationAreas / 3.0)  	e.pheromonLevel = 300;  else  	e.pheromonLevel = 100;  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: e.pheromonLevel = 300;  
Magic Number,implementation.Misc,Utils,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\Misc\Utils.cs,ResetPheromon,The following statement contains a magic number: e.pheromonLevel = 100;  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupSystem,The following statement contains a magic number: if (system is LorenzSystem) {  	double[] Y0 = new double[] {  		0.5'  		-0.5'  		-1.5  	};  	system.SetInitialValues (Y0);  }  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupSystem,The following statement contains a magic number: if (system is LorenzSystem) {  	double[] Y0 = new double[] {  		0.5'  		-0.5'  		-1.5  	};  	system.SetInitialValues (Y0);  }  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupSystem,The following statement contains a magic number: if (system is LorenzSystem) {  	double[] Y0 = new double[] {  		0.5'  		-0.5'  		-1.5  	};  	system.SetInitialValues (Y0);  }  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupGraphs,The following statement contains a magic number: if (timeSeries != null && systemResult != null) {  	for (int i = startObs - 10; i < prognoseToObs; i++) {  		try {  			data.Add (new System.Windows.Point (systemResult.Item1 [i]' timeSeries [i]));  		}  		catch (ArgumentOutOfRangeException e) {  			break;  		}  	}  	knownSeriesChart = new ObservableDataSource<System.Windows.Point> (data);  }  else {  	return;  }  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupGraphs,The following statement contains a magic number: for (int i = startObs - 10; i < prognoseToObs; i++) {  	try {  		data.Add (new System.Windows.Point (systemResult.Item1 [i]' timeSeries [i]));  	}  	catch (ArgumentOutOfRangeException e) {  		break;  	}  }  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupGraphs,The following statement contains a magic number: plotter.AddLineGraph (knownSeriesChart' System.Windows.Media.Color.FromRgb (255' 0' 0)' 1' "Lorenz x coord");  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupMultigraph,The following statement contains a magic number: multigraph = new Multigraph (areasCount' 2' 15' startObs' timeSeries);  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,SetupMultigraph,The following statement contains a magic number: multigraph = new Multigraph (areasCount' 2' 15' startObs' timeSeries);  
Magic Number,implementation,MainForm,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\UI\MainForm.cs,drawPrognosis,The following statement contains a magic number: plotter.AddLineGraph (prognosedSeriesChart' System.Windows.Media.Color.FromRgb (0' 0' 255)' 1' "Prognosis");  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,LorenzSystem,The following statement contains a magic number: Init (3);  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,LorenzSystem,The following statement contains a magic number: Init (3);  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,F,The following statement contains a magic number: FY [1] = (r - Y [2]) * Y [0] - Y [1];  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,F,The following statement contains a magic number: FY [2] = Y [0] * Y [1] - beta * Y [2];  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,F,The following statement contains a magic number: FY [2] = Y [0] * Y [1] - beta * Y [2];  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,Test,The following statement contains a magic number: task.Solve (h' 1000);  
Magic Number,implementation.ODE_Solver,LorenzSystem,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\LorenzSystem.cs,Test,The following statement contains a magic number: Console.WriteLine ("Step = {0:F5}; x = {1:F8};  y = {2:F8}; z = {3:F8}"' task.n_steps' task.Y [0]' task.Y [1]' task.Y [2]);  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: for (int i = 0; i < Y.Length; i++)  	YY [i] = Y [i] + h * Y1 [i] * 0.5;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: YY [i] = Y [i] + h * Y1 [i] * 0.5;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: for (int i = 0; i < Y.Length; i++)  	YY [i] = Y [i] + h * Y2 [i] * 0.5;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: YY [i] = Y [i] + h * Y2 [i] * 0.5;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: for (int i = 0; i < Y.Length; i++)  	Y [i] = Y [i] + h * (Y1 [i] + 2.0 * Y2 [i] + 2.0 * Y3 [i] + Y4 [i]) / 6.0;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: for (int i = 0; i < Y.Length; i++)  	Y [i] = Y [i] + h * (Y1 [i] + 2.0 * Y2 [i] + 2.0 * Y3 [i] + Y4 [i]) / 6.0;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: for (int i = 0; i < Y.Length; i++)  	Y [i] = Y [i] + h * (Y1 [i] + 2.0 * Y2 [i] + 2.0 * Y3 [i] + Y4 [i]) / 6.0;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: Y [i] = Y [i] + h * (Y1 [i] + 2.0 * Y2 [i] + 2.0 * Y3 [i] + Y4 [i]) / 6.0;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: Y [i] = Y [i] + h * (Y1 [i] + 2.0 * Y2 [i] + 2.0 * Y3 [i] + Y4 [i]) / 6.0;  
Magic Number,implementation.ODE_Solver,RungeKutta,C:\repos\AlekseyZhelo_gromov-colony\implementation\implementation\ODE Solver\runge-kutta.cs,NextStep,The following statement contains a magic number: Y [i] = Y [i] + h * (Y1 [i] + 2.0 * Y2 [i] + 2.0 * Y3 [i] + Y4 [i]) / 6.0;  
