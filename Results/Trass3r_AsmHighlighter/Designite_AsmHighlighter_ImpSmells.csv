Implementation smell,Namespace,Class,File,Method,Description
Long Method,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ConvertToFasm,The method has 100 lines of code.
Long Method,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The method has 157 lines of code.
Complex Method,AsmHighlighter,AsmHighlighterLanguageService,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,ComputeDataTipOnContext,Cyclomatic complexity of the method is 11
Complex Method,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,Cyclomatic complexity of the method is 8
Long Parameter List,AsmHighlighter,AsmDebugParsedExpression,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmDebugParsedExpression.cs,EvaluateSync,The method has 7 parameters. Parameters: dwEvalFlags' dwTimeout' pSymbolProvider' pAddress' pBinder' bstrResultType' ppResult
Long Parameter List,AsmHighlighter,AsmDebugProperty,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmDebugParsedExpression.cs,GetPropertyInfo,The method has 6 parameters. Parameters: dwFields' dwRadix' dwTimeout' rgpArgs' dwArgCount' pPropertyInfo
Long Parameter List,AsmHighlighter,AsmDebugProperty,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmDebugParsedExpression.cs,EnumChildren,The method has 7 parameters. Parameters: dwFields' dwRadix' guidFilter' dwAttribFilter' pszNameFilter' dwTimeout' ppEnum
Long Parameter List,AsmHighlighter,AsmExpressionEvaluator,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmExpressionEvaluator.cs,GetMethodLocationProperty,The method has 5 parameters. Parameters: upstrFullyQualifiedMethodPlusOffset' pSymbolProvider' pAddress' pBinder' ppProperty
Long Parameter List,AsmHighlighter,AsmExpressionEvaluator,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmExpressionEvaluator.cs,GetMethodProperty,The method has 5 parameters. Parameters: pSymbolProvider' pAddress' pBinder' fIncludeHiddenLocals' ppProperty
Long Parameter List,AsmHighlighter,AsmExpressionEvaluator,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmExpressionEvaluator.cs,Parse,The method has 6 parameters. Parameters: upstrExpression' dwFlags' nRadix' pbstrError' pichError' ppParsedExpression
Long Parameter List,AsmHighlighter,AsmHighlighterColorableItem,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterColorableItem.cs,AsmHighlighterColorableItem,The method has 5 parameters. Parameters: name' displayName' foreColor' backColor' fontFlags
Long Parameter List,AsmHighlighter,AsmHighlighterColorableItem,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterColorableItem.cs,AsmHighlighterColorableItem,The method has 7 parameters. Parameters: name' displayName' foreColor' backColor' hiForeColor' hiBackColor' fontFlags
Long Parameter List,AsmHighlighter,AsmHighlighterLanguageService,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,ComputeDataTipOnContext,The method has 5 parameters. Parameters: textLines' line' col' span' tipText
Long Parameter List,AsmHighlighter,TestAuthoringScope,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,GetDeclarations,The method has 5 parameters. Parameters: view' line' col' info' reason
Long Parameter List,AsmHighlighter,TestAuthoringScope,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,Goto,The method has 5 parameters. Parameters: cmd' textView' line' col' span
Long Identifier,AsmHighlighter,AsmExpressionEvaluator,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmExpressionEvaluator.cs,GetMethodLocationProperty,The length of the parameter upstrFullyQualifiedMethodPlusOffset is 35.
Long Identifier,AsmHighlighter,GuidList,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\Guids.cs,,The length of the parameter guidAsmHighlighterCmdSetString is 30.
Long Identifier,AsmHighlighter,GuidList,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\Guids.cs,,The length of the parameter guidAsmHighlighterLanguageServiceString is 39.
Long Statement,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ConvertToFasm,The length of the statement  "                            if (!restOfLine.StartsWith("dword") && !restOfLine.StartsWith("short") && !restOfLine.StartsWith("near") && !restOfLine.StartsWith("far")) " is 138.
Long Statement,AsmHighlighter,AsmHighlighterLanguageService,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,ComputeDataTipOnContext,The length of the statement  "			if ((token & (AsmHighlighterToken.IS_INSTRUCTION | AsmHighlighterToken.IS_REGISTER | AsmHighlighterToken.IS_NUMBER)) == 0 && " is 124.
Long Statement,AsmHighlighter,AsmHighlighterSource,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterSource.cs,DoFormatting,The length of the statement  "                List<EditSpan> changeList = AsmHighlighterFormatHelper.ReformatCode(pBuffer' span' LanguageService.GetLanguagePreferences().TabSize); " is 133.
Complex Conditional,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ConvertToFasm,The conditional expression  "!restOfLine.StartsWith("dword") && !restOfLine.StartsWith("short") && !restOfLine.StartsWith("near") && !restOfLine.StartsWith("far")"  is complex.
Empty Catch Block,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ReformatCode,The method has an empty catch block.
Empty Catch Block,AsmHighlighter,AsmHighlighterLanguageService,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,ComputeDataTipOnContext,The method has an empty catch block.
Magic Number,AsmHighlighter,AsmDebugProperty,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmDebugParsedExpression.cs,GetPropertyInfo,The following statement contains a magic number: if (pPropertyInfo.Length > 0)              {                  Expression debugExpr = vs.Debugger.GetExpression(_expression' true' 1000);                    pPropertyInfo[0].dwAttrib = (long)Constants.DBG_ATTRIB_ACCESS_ALL;                  pPropertyInfo[0].dwAttrib |= (long)Constants.DBG_ATTRIB_TYPE_VOLATILE;                  pPropertyInfo[0].dwAttrib |= (long) Constants.DBG_ATTRIB_STORAGE_REGISTER;                    pPropertyInfo[0].dwFields = dwFields;                    if ((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME) != 0)                  {                      pPropertyInfo[0].bstrFullName = _expression;                  }                    if ((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME) != 0)                  {                      pPropertyInfo[0].bstrName = debugExpr.Name;                  }                    if ((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE) != 0)                  {                      pPropertyInfo[0].bstrType = debugExpr.Type;                  }                    if ((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE) != 0                      || (dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE_RAW) != 0)                  {                      pPropertyInfo[0].bstrValue = debugExpr.Value;                  }              }
Magic Number,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ParseDefineLine,The following statement contains a magic number: if ( line.StartsWith(";!") )              {                  line = line.Substring(2' line.Length - 2);                  string[] values = Regex.Split(line' @"\s*;\s*");                  foreach (string keyValue in values)                  {                      string[] keyValueParsed = Regex.Split(keyValue' @"\s*=\s*");                      if ( keyValueParsed.Length == 2 )                      {                          string key = keyValueParsed[0].ToLower();                          string value = keyValueParsed[1].ToLower();                          if (!map.ContainsKey(key))                          {                              map.Add(key' value);                          }                      }                  }              }
Magic Number,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ParseDefineLine,The following statement contains a magic number: if ( line.StartsWith(";!") )              {                  line = line.Substring(2' line.Length - 2);                  string[] values = Regex.Split(line' @"\s*;\s*");                  foreach (string keyValue in values)                  {                      string[] keyValueParsed = Regex.Split(keyValue' @"\s*=\s*");                      if ( keyValueParsed.Length == 2 )                      {                          string key = keyValueParsed[0].ToLower();                          string value = keyValueParsed[1].ToLower();                          if (!map.ContainsKey(key))                          {                              map.Add(key' value);                          }                      }                  }              }
Magic Number,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ParseDefineLine,The following statement contains a magic number: if ( line.StartsWith(";!") )              {                  line = line.Substring(2' line.Length - 2);                  string[] values = Regex.Split(line' @"\s*;\s*");                  foreach (string keyValue in values)                  {                      string[] keyValueParsed = Regex.Split(keyValue' @"\s*=\s*");                      if ( keyValueParsed.Length == 2 )                      {                          string key = keyValueParsed[0].ToLower();                          string value = keyValueParsed[1].ToLower();                          if (!map.ContainsKey(key))                          {                              map.Add(key' value);                          }                      }                  }              }
Magic Number,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ReformatCode,The following statement contains a magic number: for (int line = span.iStartLine; line <= span.iEndLine; line++)              {                  int lineLength;                  pBuffer.GetLengthOfLine(line' out lineLength);                  pBuffer.GetLineText(line' 0' line' lineLength' out codeToFormat);                    string codeToAssemble =  ConvertToFasm(lexer' codeToFormat' defines);                    lexer.SetSource(codeToFormat' 0);                  int state = 0;                  int start' end;                    bool instructionFound = false' commentFound = false;                  int commentStart = 0;                  AsmHighlighterToken token = (AsmHighlighterToken)lexer.GetNext(ref state' out start' out end);                  while (token != AsmHighlighterToken.EOF )                  {                      if ((token & AsmHighlighterToken.IS_INSTRUCTION) != 0)                          instructionFound = true;                      else if (token == AsmHighlighterToken.COMMENT_LINE)                      {                          if (!commentFound)                          {                              commentFound = true;                              commentStart = start;                          }                      }                        if ( instructionFound && commentFound )                      {                          byte[] buffer = null;                            try                          {                              buffer = ManagedFasm.Assemble(codeToAssemble);                          }                          catch (Exception)                          {                              // Unable to parse instruction... skip                          }                            TextSpan editTextSpan = new TextSpan();                          editTextSpan.iStartLine = line;                          editTextSpan.iEndLine = line;                          editTextSpan.iStartIndex = commentStart;                          editTextSpan.iEndIndex = commentStart+1;                          if ((codeToFormat.Length - commentStart) > 2 && codeToFormat.Substring(commentStart' 2) == ";#")                          {                              editTextSpan.iEndIndex = editTextSpan.iEndIndex + 2;                          }                            string text = ";#" + ((buffer == null) ? "?" : string.Format("{0:X}"'buffer.Length));                          changeList.Add(new EditSpan(editTextSpan' text));                          break;                      }                      token = (AsmHighlighterToken)lexer.GetNext(ref state' out start' out end);                  }              }
Magic Number,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ReformatCode,The following statement contains a magic number: for (int line = span.iStartLine; line <= span.iEndLine; line++)              {                  int lineLength;                  pBuffer.GetLengthOfLine(line' out lineLength);                  pBuffer.GetLineText(line' 0' line' lineLength' out codeToFormat);                    string codeToAssemble =  ConvertToFasm(lexer' codeToFormat' defines);                    lexer.SetSource(codeToFormat' 0);                  int state = 0;                  int start' end;                    bool instructionFound = false' commentFound = false;                  int commentStart = 0;                  AsmHighlighterToken token = (AsmHighlighterToken)lexer.GetNext(ref state' out start' out end);                  while (token != AsmHighlighterToken.EOF )                  {                      if ((token & AsmHighlighterToken.IS_INSTRUCTION) != 0)                          instructionFound = true;                      else if (token == AsmHighlighterToken.COMMENT_LINE)                      {                          if (!commentFound)                          {                              commentFound = true;                              commentStart = start;                          }                      }                        if ( instructionFound && commentFound )                      {                          byte[] buffer = null;                            try                          {                              buffer = ManagedFasm.Assemble(codeToAssemble);                          }                          catch (Exception)                          {                              // Unable to parse instruction... skip                          }                            TextSpan editTextSpan = new TextSpan();                          editTextSpan.iStartLine = line;                          editTextSpan.iEndLine = line;                          editTextSpan.iStartIndex = commentStart;                          editTextSpan.iEndIndex = commentStart+1;                          if ((codeToFormat.Length - commentStart) > 2 && codeToFormat.Substring(commentStart' 2) == ";#")                          {                              editTextSpan.iEndIndex = editTextSpan.iEndIndex + 2;                          }                            string text = ";#" + ((buffer == null) ? "?" : string.Format("{0:X}"'buffer.Length));                          changeList.Add(new EditSpan(editTextSpan' text));                          break;                      }                      token = (AsmHighlighterToken)lexer.GetNext(ref state' out start' out end);                  }              }
Magic Number,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ReformatCode,The following statement contains a magic number: for (int line = span.iStartLine; line <= span.iEndLine; line++)              {                  int lineLength;                  pBuffer.GetLengthOfLine(line' out lineLength);                  pBuffer.GetLineText(line' 0' line' lineLength' out codeToFormat);                    string codeToAssemble =  ConvertToFasm(lexer' codeToFormat' defines);                    lexer.SetSource(codeToFormat' 0);                  int state = 0;                  int start' end;                    bool instructionFound = false' commentFound = false;                  int commentStart = 0;                  AsmHighlighterToken token = (AsmHighlighterToken)lexer.GetNext(ref state' out start' out end);                  while (token != AsmHighlighterToken.EOF )                  {                      if ((token & AsmHighlighterToken.IS_INSTRUCTION) != 0)                          instructionFound = true;                      else if (token == AsmHighlighterToken.COMMENT_LINE)                      {                          if (!commentFound)                          {                              commentFound = true;                              commentStart = start;                          }                      }                        if ( instructionFound && commentFound )                      {                          byte[] buffer = null;                            try                          {                              buffer = ManagedFasm.Assemble(codeToAssemble);                          }                          catch (Exception)                          {                              // Unable to parse instruction... skip                          }                            TextSpan editTextSpan = new TextSpan();                          editTextSpan.iStartLine = line;                          editTextSpan.iEndLine = line;                          editTextSpan.iStartIndex = commentStart;                          editTextSpan.iEndIndex = commentStart+1;                          if ((codeToFormat.Length - commentStart) > 2 && codeToFormat.Substring(commentStart' 2) == ";#")                          {                              editTextSpan.iEndIndex = editTextSpan.iEndIndex + 2;                          }                            string text = ";#" + ((buffer == null) ? "?" : string.Format("{0:X}"'buffer.Length));                          changeList.Add(new EditSpan(editTextSpan' text));                          break;                      }                      token = (AsmHighlighterToken)lexer.GetNext(ref state' out start' out end);                  }              }
Magic Number,AsmHighlighter,AsmHighlighterLanguageService,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLanguageService.cs,ComputeDataTipOnContext,The following statement contains a magic number: Expression expression = vs.Debugger.GetExpression(tipText' true' 1000);
Magic Number,AsmHighlighter,AsmHighlighter,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighter.cs,IdIcoLogoForAboutbox,The following statement contains a magic number: pIdIco = 400;
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,MapC,The following statement contains a magic number: if (code < 125) // '\0' <= code <= '|'          return mapC0[code - 0];        else // '}' <= code <= '\U0010FFFF'          return (sbyte)2;
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,MapC,The following statement contains a magic number: if (code < 125) // '\0' <= code <= '|'          return mapC0[code - 0];        else // '}' <= code <= '\U0010FFFF'          return (sbyte)2;
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,NextState,The following statement contains a magic number: if (code == ScanBuff.EndOfFile)          return eofNum;      else          unchecked {              int rslt;              int idx = MapC(code) - NxS[state].min;              if (idx < 0) idx += 36;              if ((uint)idx >= (uint)NxS[state].rng) rslt = NxS[state].dflt;              else rslt = NxS[state].nxt[idx];              return rslt;          }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,GetCode,The following statement contains a magic number: if (code > ScanBuff.EndOfFile)              {  #if (!BYTEMODE)                  if (code >= 0xD800 && code <= 0xDBFF)                  {                      int next = buffer.Read();                      if (next < 0xDC00 || next > 0xDFFF)                          code = ScanBuff.UnicodeReplacementChar;                      else                          code = (0x10000 + ((code & 0x3FF) << 10) + (next & 0x3FF));                  }  #endif                  cCol++;              }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,Scanner,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }    #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                          // the "no-match" char.   In traditional LEX such                          // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                      // At last' a valid transition ...                      MarkToken();                      state = next;                      GetCode();  #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '{white_space}''	Shortest string "\t"  /* Ignore */              break;          case 2: // Recognized '";"(.)*''	Shortest string ";"  return (int)AsmHighlighterToken.COMMENT_LINE;              break;          case 3: // Recognized '.''	Shortest string "\0"          case 17: // Recognized '.''	Shortest string "\""          case 18: // Recognized '.''	Shortest string "'"  return (int)AsmHighlighterToken.UNDEFINED;              break;          case 4: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "s"          case 5: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "t"          case 39: // Recognized '({alpha}|[$?])({alpha}|{manglingchars}|{digit})*''	Shortest string "st"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 6: // Recognized '"("''	Shortest string "("  return (int)AsmHighlighterToken.LEFT_PARENTHESIS;              break;          case 7: // Recognized '{digit}+''	Shortest string "8"          case 12: // Recognized '{digit}+''	Shortest string "0"          case 13: // Recognized '{digit}+''	Shortest string "1"          case 14: // Recognized '{digit}+''	Shortest string "2"  return (int)AsmHighlighterToken.NUMBER;              break;          case 8: // Recognized '")"''	Shortest string ")"  return (int)AsmHighlighterToken.RIGHT_PARENTHESIS;              break;          case 9: // Recognized '"."({alpha}|{digit})*''	Shortest string "."  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 10: // Recognized '"@"({alpha}|{digit})*''	Shortest string "@"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 11: // Recognized '"%"({alpha}|{digit})*''	Shortest string "%"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 15: // Recognized '"+"''	Shortest string "+"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 16: // Recognized '"-"''	Shortest string "-"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 19: // Recognized '"'"''	Shortest string "'"  return (int)AsmHighlighterToken.DELIMITER;              break;          case 20: // Recognized '"["''	Shortest string "["  return (int)AsmHighlighterToken.LEFT_SQUARE_BRACKET;              break;          case 21: // Recognized '"]"''	Shortest string "]"  return (int)AsmHighlighterToken.RIGHT_SQUARE_BRACKET;              break;          case 22: // Recognized '"&"''	Shortest string "&"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 23: // Recognized '"|"''	Shortest string "|"  return (int)AsmHighlighterToken.OPERATOR;              break;          case 24: // Recognized '\'(\\.|[^\\'])*\'''	Shortest string "''"  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 25: // Recognized '\"(\\.|[^\\"])*\"''	Shortest string "\"\""  return (int)AsmHighlighterToken.STRING_LITERAL;              break;          case 26: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8."          case 32: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.H"          case 33: // Recognized '{digit}+"."{digit}*({exponent})?({floatsuffix})?''	Shortest string "8.E8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 27: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "1O"          case 36: // Recognized '(0[oO]{octal}+|{octal}+[oO])''	Shortest string "0O"  return (int)AsmHighlighterToken.NUMBER;              break;          case 28: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "8D"          case 37: // Recognized '(0[dD]{digit}+|{digit}+[dD])''	Shortest string "0D"  return (int)AsmHighlighterToken.NUMBER;              break;          case 29: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "8H"          case 38: // Recognized '(0[xX]{hexdigit}+|{hexdigit}+[hH])''	Shortest string "0X8"  return (int)AsmHighlighterToken.NUMBER;              break;          case 30: // Recognized '{digit}+{exponent}''	Shortest string "8E8"          case 31: // Recognized '{digit}+{exponent}''	Shortest string "8E+8"  return (int)AsmHighlighterToken.FLOAT;              break;          case 34: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "1B"          case 35: // Recognized '(0[bB]{binary}+|{binary}+[bB])''	Shortest string "0B"  return (int)AsmHighlighterToken.NUMBER;              break;          case 40: // Recognized '"st"{digit}''	Shortest string "st8"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          case 41: // Recognized '"st("{digit}")"''	Shortest string "st(8)"  return (int)AsmHighlighterTokenProvider.GetTokenFromIdentifier(yytext);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,AsmHighlighter.Lexer,BuildBuffer,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Mark,The following statement contains a magic number: data.Mark(bPos - 2);
Magic Number,AsmHighlighter.Lexer,BuildBuffer,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Read,The following statement contains a magic number: if (bPos < data.MaxIndex)              {                  // ch0 cannot be EOF                  return (int)data[bPos++];              }              else // Read from underlying stream              {                  // Experimental code' blocks of page size                  char[] chrs = new char[4096];                  int count = NextBlk(chrs' 0' 4096);                  if (count == 0)                      return EndOfFile;                  else                  {                      data.Append(chrs' count);                      return (int)data[bPos++];                  }              }
Magic Number,AsmHighlighter.Lexer,BuildBuffer,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Read,The following statement contains a magic number: if (bPos < data.MaxIndex)              {                  // ch0 cannot be EOF                  return (int)data[bPos++];              }              else // Read from underlying stream              {                  // Experimental code' blocks of page size                  char[] chrs = new char[4096];                  int count = NextBlk(chrs' 0' 4096);                  if (count == 0)                      return EndOfFile;                  else                  {                      data.Append(chrs' count);                      return (int)data[bPos++];                  }              }
Magic Number,AsmHighlighter.Lexer,BufferElement,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Mark,The following statement contains a magic number: if (limit > brkIx + 16) // Rotate blocks                  {                      StringBuilder temp = bldr;                      bldr = next;                      next = temp;                      next.Length = 0;                      minIx = brkIx;                      brkIx = maxIx;                  }
Magic Number,AsmHighlighter.Lexer,BlockReaderFactory,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Get,The following statement contains a magic number: if (preamble != 0)  // There is a valid BOM here!                  encoding = Encoding.GetEncoding(preamble);              else if (fallbackCodePage == -1) // Fallback is "raw" bytes                  return Raw(stream);              else if (fallbackCodePage != -2) // Anything but "guess"                  encoding = Encoding.GetEncoding(fallbackCodePage);              else // This is the "guess" option              {                  int guess = new Guesser(stream).GuessCodePage();                  stream.Seek(0' SeekOrigin.Begin);                  if (guess == -1) // ==> this is a 7-bit file                      encoding = Encoding.ASCII;                  else if (guess == 65001)                      encoding = Encoding.UTF8;                  else             // ==> use the machine default                      encoding = Encoding.Default;              }
Magic Number,AsmHighlighter.Lexer,BlockReaderFactory,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Get,The following statement contains a magic number: if (preamble != 0)  // There is a valid BOM here!                  encoding = Encoding.GetEncoding(preamble);              else if (fallbackCodePage == -1) // Fallback is "raw" bytes                  return Raw(stream);              else if (fallbackCodePage != -2) // Anything but "guess"                  encoding = Encoding.GetEncoding(fallbackCodePage);              else // This is the "guess" option              {                  int guess = new Guesser(stream).GuessCodePage();                  stream.Seek(0' SeekOrigin.Begin);                  if (guess == -1) // ==> this is a 7-bit file                      encoding = Encoding.ASCII;                  else if (guess == 65001)                      encoding = Encoding.UTF8;                  else             // ==> use the machine default                      encoding = Encoding.Default;              }
Magic Number,AsmHighlighter.Lexer,BlockReaderFactory,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Preamble,The following statement contains a magic number: if (b0 == 0xfe && b1 == 0xff)                  return 1201;
Magic Number,AsmHighlighter.Lexer,BlockReaderFactory,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Preamble,The following statement contains a magic number: if (b0 == 0xff && b1 == 0xfe)                  return 1200;
Magic Number,AsmHighlighter.Lexer,BlockReaderFactory,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Preamble,The following statement contains a magic number: if (b0 == 0xef && b1 == 0xbb && b2 == 0xbf)                  return 65001;
Magic Number,AsmHighlighter.Lexer,CodePageHandling,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,GetCodePage,The following statement contains a magic number: if (command.StartsWith("CodePage:"' StringComparison.OrdinalIgnoreCase))                  command = command.Substring(9);
Magic Number,AsmHighlighter.Lexer,CodePageHandling,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,GetCodePage,The following statement contains a magic number: try              {                  if (command.Equals("RAW"))                      return -1;                  else if (command.Equals("GUESS"))                      return -2;                  else if (command.Equals("DEFAULT"))                      return 0;                  else if (char.IsDigit(command[0]))                      return int.Parse(command' CultureInfo.InvariantCulture);                  else                  {                      Encoding enc = Encoding.GetEncoding(command);                      return enc.CodePage;                  }              }              catch (FormatException)              {                  Console.Error.WriteLine(                      "Invalid format \"{0}\"' using machine default"' option);              }              catch (ArgumentException)              {                  Console.Error.WriteLine(                      "Unknown code page \"{0}\"' using machine default"' option);              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Guesser,The following statement contains a magic number: nextState[7] = nextState[2];
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Guesser,The following statement contains a magic number: nextState[7] = nextState[2];
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Guesser,The following statement contains a magic number: nextState[9] = nextState[2];
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Guesser,The following statement contains a magic number: nextState[9] = nextState[2];
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Guesser,The following statement contains a magic number: nextState[10] = nextState[2];
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Guesser,The following statement contains a magic number: nextState[10] = nextState[2];
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Missing Default,AsmHighlighter,AsmHighlighterFormatHelper,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterFormatHelper.cs,ConvertToFasm,The following switch statement is missing a default case: switch (token)                  {                      case AsmHighlighterToken.INSTRUCTION:                          if ( tokenStr == "call" || tokenStr.StartsWith("j"))                          {                              string restOfLine = codeToFormat.Substring(end + 1' codeToFormat.Length - (end + 1)).Trim();                              // Set default call|jxx to dword                              if (!restOfLine.StartsWith("dword") && !restOfLine.StartsWith("short") && !restOfLine.StartsWith("near") && !restOfLine.StartsWith("far"))                              {                                  isToStrip = true;                                  stripReplace = tokenStr + " dword";                              }                          }                          break;                      case AsmHighlighterToken.LEFT_SQUARE_BRACKET:                          isInBracket = true;                          break;                      case AsmHighlighterToken.RIGHT_SQUARE_BRACKET:                          isInBracket = false;                          countRegisterInBracket = 0;                          break;                      case AsmHighlighterToken.REGISTER:                      case AsmHighlighterToken.REGISTER_FPU:                      case AsmHighlighterToken.REGISTER_MMXSSE:                          if (isInBracket)                          {                              countRegisterInBracket++;                          }                          // Convert st(#) register to st#                          if (token == AsmHighlighterToken.REGISTER_FPU)                          {                              tokenStr = tokenStr.Replace("("' "");                              tokenStr = tokenStr.Replace(")"' "");                              isToStrip = true;                              stripReplace = tokenStr;                          }                          break;                      case AsmHighlighterToken.DIRECTIVE:                          // strip register                          if (tokenStr == "ptr")                          {                              isToStrip = true;                              stripReplace = "";                          }                          break;                        case AsmHighlighterToken.IDENTIFIER:                          isToStrip = true;                          stripReplace  = (defines.ContainsKey(tokenStr)) ? defines[tokenStr] : "4";                          if (isInBracket)                          {                              if ( (lexer.AsmHighlighterTokenProvider.GetTokenFromIdentifier(stripReplace) & AsmHighlighterToken.IS_REGISTER) != 0 )                              {                                  countRegisterInBracket++;                              }                              else if (stripReplace == "4")                              {                                  // No register before 1st identifier                                  if ( countRegisterInBracket == 0)                                  {                                      // Fake dword adress if we have mov [IDENTIFIER + ....]                                      stripReplace = "123123";                                  }                              }                          }                          break;                  }
Missing Default,AsmHighlighter.Lexer,Guesser,C:\repos\Trass3r_AsmHighlighter\AsmHighlighter\AsmHighlighterLexer.cs,Scan,The following switch statement is missing a default case: switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }
