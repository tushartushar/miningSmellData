Implementation smell,Namespace,Class,File,Method,Description
Long Method,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The method has 267 lines of code.
Long Method,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The method has 165 lines of code.
Long Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The method has 103 lines of code.
Long Method,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The method has 214 lines of code.
Long Method,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The method has 101 lines of code.
Complex Method,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,Cyclomatic complexity of the method is 77
Complex Method,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,Cyclomatic complexity of the method is 30
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,treeViewNodeProperties_AfterSelect,Cyclomatic complexity of the method is 13
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,setCombosFromMCS,Cyclomatic complexity of the method is 18
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,Cyclomatic complexity of the method is 20
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,Cyclomatic complexity of the method is 12
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,Cyclomatic complexity of the method is 44
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,Cyclomatic complexity of the method is 44
Complex Method,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,Cyclomatic complexity of the method is 14
Complex Method,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,Cyclomatic complexity of the method is 24
Complex Method,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,Cyclomatic complexity of the method is 20
Complex Method,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,MessageReplyListenerCallback,Cyclomatic complexity of the method is 8
Complex Method,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,Cyclomatic complexity of the method is 11
Complex Method,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkConstellation_RunWorkerCompleted,Cyclomatic complexity of the method is 17
Complex Method,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,Cyclomatic complexity of the method is 27
Complex Method,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,Cyclomatic complexity of the method is 9
Complex Method,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,Cyclomatic complexity of the method is 9
Complex Method,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,AddValues,Cyclomatic complexity of the method is 12
Complex Method,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,ChartAppendFromQueue,Cyclomatic complexity of the method is 9
Complex Method,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,Cyclomatic complexity of the method is 10
Complex Method,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,Cyclomatic complexity of the method is 10
Long Parameter List,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The method has 6 parameters.
Long Parameter List,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,MCS,The method has 5 parameters.
Long Parameter List,WindowsFormsApplication1,PhyProfile,C:\repos\dan-sw_PTP_GUI\PhyProfile.cs,PhyProfile,The method has 5 parameters.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2); " is 120.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue); " is 123.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue); " is 121.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle); " is 215.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle); " is 215.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle); " is 258.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep); " is 205.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))); " is 434.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "						gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "						gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "						ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))); " is 694.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "						gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "						gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius)); " is 185.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "						ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))); " is 694.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append); " is 369.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic); " is 180.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "				ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic); " is 169.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "	Single brushAngle = (Int32)(m_BaseArcStart + (m_value - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue)) % 360; " is 120.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 156.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 134.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 133.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 135.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 134.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 137.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 136.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "			pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 136.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2)); " is 139.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle))); " is 160.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle))); " is 150.
Long Statement,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The length of the statement  "		pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6); " is 156.
Long Statement,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The length of the statement  "		//System.Console.WriteLine("flushToTempFile {0} complete (elapsed ms={1})"' constellation.fileName' st.ElapsedMilliseconds); " is 124.
Long Statement,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The length of the statement  "		args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' ChannelsGain [0].filePath' ChannelsGain [1].filePath' constellationMode' FFTsizes [selectedFFT]); " is 211.
Long Statement,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The length of the statement  "		args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' constellations [2].filePath' constellations [3].filePath' constellationMode' FFTsizes [selectedFFT]); " is 215.
Long Statement,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The length of the statement  "			tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + ChannelsGain [0].filePath + "\n" + ChannelsGain [1].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable); " is 307.
Long Statement,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The length of the statement  "			tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable); " is 311.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The length of the statement  "		CalcRateResults [i] = MCS.CalcTput (phyProfile.Bandwidth' antenna' mcs.modulation' mcs.upDownRatio' phyProfile.Range.ToString ()' phyProfile.DuplexMode == "FDD"); " is 162.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryRead_Click,The length of the statement  "		MessageBox.Show ("Please enter a hexadecimal number"' "Invalid Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 123.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryWrite_Click,The length of the statement  "		MessageBox.Show ("Please enter a hexadecimal number"' "Invalid Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 123.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryWrite_Click,The length of the statement  "		MessageBox.Show ("Please enter a hexadecimal number"' "Invalid Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 123.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,updateAMCThroughPut,The length of the statement  "	double max = MCS.CalcTput (bandwidth' antenna' mcsSelection.modulation' mcsSelection.upDownRatio' range' (isFDD == "FDD")); " is 123.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkBox_BER_COUNTER_ENABLE_CheckedChanged,The length of the statement  "		MessageBox.Show ("Need to remove the data cable from GMAC1"' "DAN PTP - Information"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 136.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkBox_Uncoded_BER_COUNTER_ENABLE_CheckedChanged,The length of the statement  "		MessageBox.Show (@"Need to upload ptp_init_param file with ""struct PARAMS.init_params.K0Value=0"" "' "DAN PTP - Information"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 177.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkBox_Uncoded_BER_COUNTER_ENABLE_CheckedChanged,The length of the statement  "		MessageBox.Show (@"Need to upload ptp_init_param file with ""struct PARAMS.init_params.K0Value=1"" "' "DAN PTP - Information"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 177.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initGMACCountersTab,The length of the statement  "		dataGridViewGMAC0.Rows.Add (GMAC.gmac0.registerNames0 [i]' String.Format ("{0:0'0.0} f/s"' GMAC.gmac0.RateCounters_GMAC0 [i])' GMAC.gmac0.CurrentCounters_GMAC0 [i]); " is 165.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initGMACCountersTab,The length of the statement  "		dataGridViewGMAC1.Rows.Add (GMAC.gmac1.registerNames1 [i]' String.Format ("{0:0'0.0} f/s"' GMAC.gmac1.RateCounters_GMAC1 [i])' GMAC.gmac1.CurrentCounters_GMAC1 [i]); " is 165.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonWriteCinrValues_Click,The length of the statement  "		MessageBox.Show ("Please enter a number' or press Cancel"' "Invalid Value"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 126.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonWriteCinrValues_Click,The length of the statement  "		MessageBox.Show ("Please enter a number' or press Cancel"' "Invalid Value"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 126.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("Please select a folder for Matlab data files"' "Invalid Data Folder"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 138.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("The selected folder does not exist"' "Invalid Data Folder"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 128.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("Please select the Matlab executable"' "Invalid File Name"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 127.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("The selected file does not exist"' "Invalid File Name"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 124.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("Please enter an interval' in seconds (1..20)"' "Invalid Interval"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 135.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("Please enter an interval' in seconds (1..20)"' "Invalid Interval"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 135.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The length of the statement  "		MessageBox.Show ("Please enter a number' between 0 and 21' for Matlab update"' "Invalid Interval"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 149.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDownloadMemory_Click_1,The length of the statement  "	//       uint memory_Address = uint.Parse(comboBoxMemoryDumpDownloadAddress.Text' System.Globalization.NumberStyles.HexNumber); " is 127.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDownloadMemory_Click,The length of the statement  "	////       uint memory_Address = uint.Parse(comboBoxMemoryDumpDownloadAddress.Text' System.Globalization.NumberStyles.HexNumber); " is 129.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The length of the statement  "				PHYCDataToSave = PHYCDataToSave + " ' Ant0 Bit Counter ' Ant0 Bit CRC Counter" + " ' Ant1 Bit Counter ' Ant1 Bit CRC Counter"; " is 126.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The length of the statement  "			string GMACDataToSave = "Time' Rx MMC ethernet packet count ' Rx Good broadcast frames ' Rx Good multicast frames ' " + "Rx CRC error frames ' Rx Good unicast frames ' Rx Missed due to FIFO overflow '  Rx VLAN frames ' " + "Tx MMC ethernet packet count ' Tx Good broadcast frames ' Tx - Good multicast frames ' Tx - Good and bad unicast frames ' " + "Tx Good and bad multicast frames ' Tx - Good and bad broadcast frames" + " ' Rx Good broadcast frames ' Rx Good multicast frames ' " + "Rx CRC error frames ' Rx Good unicast frames ' Rx Missed due to FIFO overflow '  Rx VLAN frames ' " + "Tx Good broadcast frames ' Tx - Good multicast frames ' Tx - Good and bad unicast frames ' " + "Tx Good and bad multicast frames ' Tx - Good and bad broadcast frames"; " is 757.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The length of the statement  "			string PHYSDataToSave = "Time' STO0 ' CFO0 ' XPIC0 ' RSSI0 ' CINR0' " + "STO1 ' CFO1 ' XPIC1 ' RSSI1 ' CINR1' MCS RX ' MCS TX ' " + "ISYNC achived ' ISYNC Peak Level ' ISYNC frequency offset ' RLM Link State"; " is 209.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The length of the statement  "	string PHYCDataToSave = Timer + " ' " + Convert.ToString ((decimal)PHY.phy.NACK0) + " ' " + Convert.ToString ((decimal)PHY.phy.ACK0) + " ' " + Convert.ToString ((decimal)PHY.phy.NACK1) + " ' " + Convert.ToString ((decimal)PHY.phy.ACK1) + " ' "; " is 244.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The length of the statement  "		PHYCDataToSave += Convert.ToString ((PHY.phy.BER_Good_bits_Ant0 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.BER_Good_bits_Ant1 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant1)) + " ' "; " is 260.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The length of the statement  "		PHYCDataToSave += Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Good_bits * 8 * 4)); " is 211.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYSToFile,The length of the statement  "	string PHYSDataToSave = Timer + " ' " + Convert.ToString ((decimal)PHY.phy.STO1) + " ' " + Convert.ToString ((decimal)PHY.phy.CFO1) + " ' " + Convert.ToString ((decimal)PHY.phy.XPI1) + " ' " + Convert.ToString ((decimal)PHY.phy.RSSI1) + " ' " + Convert.ToString ((decimal)PHY.phy.CINR1avg) + " ' " + Convert.ToString ((decimal)PHY.phy.STO2) + " ' " + Convert.ToString ((decimal)PHY.phy.CFO2) + " ' " + Convert.ToString ((decimal)PHY.phy.XPI2) + " ' " + Convert.ToString ((decimal)PHY.phy.RSSI2) + " ' " + Convert.ToString ((decimal)PHY.phy.CINR2avg) + " ' " + Convert.ToString (PHY.phy.controlChannelRx.txAnnounced1) + "'" + Convert.ToString (PHY.phy.controlChannelTx.txAnnounced2) + "'" + Convert.ToString (LinkIndicator.links.SyncAchieved) + "'" + Convert.ToString ((decimal)PHY.phy.IsyncPeak) + "'" + Convert.ToString ((decimal)PHY.phy.IsyncFreq) + "'" + Convert.ToString ((decimal)PHY.phy.LinkStatus) + "'"; " is 911.
Long Statement,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogsUnitInfoToFile,The length of the statement  "	string UnitInfoDataToSave = Convert.ToString (UnitType) + " ' " + Convert.ToString (RunningProfile) + " ' " + Convert.ToString (SisoMimoMode) + " ' " + Convert.ToString (SW_Version); " is 182.
Long Statement,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The length of the statement  "	RFTypeReg = (msg.data [rf_Type_str + 3].ToString ("X") + msg.data [rf_Type_str + 2].ToString ("X") + msg.data [rf_Type_str + 1].ToString ("X") + msg.data [rf_Type_str].ToString ("X")); " is 184.
Long Statement,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The length of the statement  "		tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString (); " is 125.
Long Statement,WindowsFormsApplication1,FormDiscover,C:\repos\dan-sw_PTP_GUI\FormDiscover.cs,buttonConnect_Click,The length of the statement  "			MessageBox.Show ("Please select a network adapter."' "Multiple Adapters Present"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 132.
Long Statement,WindowsFormsApplication1,FormDiscover,C:\repos\dan-sw_PTP_GUI\FormDiscover.cs,buttonConnect_Click,The length of the statement  "		MessageBox.Show ("Please select the target's MAC address."' "MAC Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 125.
Long Statement,WindowsFormsApplication1,FormDiscover,C:\repos\dan-sw_PTP_GUI\FormDiscover.cs,buttonConnect_Click,The length of the statement  "		MessageBox.Show ("The DAN PTP device at " + selectedMAC + " did not respond on adapter " + selectedAdapter' "DAN PTP - Communication Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 185.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,updateGroupboxLabels,The length of the statement  "	this.groupBoxGMAC0.Text = String.Format ("{0}     {1} sec "' comboBoxGraph0a.SelectedItem.ToString ()' numberOfSecondsDisplayed); " is 129.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,updateGroupboxLabels,The length of the statement  "	this.groupBoxGMAC1.Text = String.Format ("{0}     {1} sec "' comboBoxGraph1a.SelectedItem.ToString ()' numberOfSecondsDisplayed); " is 129.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,buttonConstellation_Click,The length of the statement  "					MessageBox.Show ("The Matlab program is not present' at: " + Constellation.constellationExecutable + "\n\nUse Properties / Constellation page to select a different Matlab executable or location."' "DAN PTP - Installation Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 279.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkConstellation_RunWorkerCompleted,The length of the statement  "		MessageBox.Show ("Timeout fetching constellation data - the EVB has stopped responding."' "DAN PTP - Communication Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 173.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkConstellation_RunWorkerCompleted,The length of the statement  "		MessageBox.Show ("The Matlab process failed to start"' "DAN PTP - Process Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 132.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkConstellation_RunWorkerCompleted,The length of the statement  "		MessageBox.Show ("Error writing constellation files for the Matlab process"' "DAN PTP - File Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 151.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "			//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow); " is 136.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "			this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow); " is 136.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "			this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow); " is 122.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "				this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow); " is 132.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "				this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow); " is 168.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "				//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2); " is 129.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "				uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2; " is 134.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "				//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation); " is 136.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The length of the statement  "				//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation); " is 136.
Long Statement,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,buttonResetSOC_Click,The length of the statement  "	DialogResult dialogResult = MessageBox.Show ("This action will reset the unit.\n Do you want to continue?\n"' "Reset SoC"' MessageBoxButtons.YesNo); " is 148.
Long Statement,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,print,The length of the statement  "	Console.WriteLine (" MsgType 0x{0}   size {1}  seq {2}   address 0x{3}"' msgType.ToString ("X2")' size' seq' address.ToString ("X2")); " is 134.
Long Statement,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The length of the statement  "						Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]); " is 151.
Long Statement,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parsePacket,The length of the statement  "	if (packet.Data [12] == 8 && packet.Data [13] == 0 && packet.Data [14] == 0x15 && (packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET] >= (byte)DAN_gui_msg.MSG_TYPE.RSP_READ)) { " is 188.
Long Statement,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The length of the statement  "	if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH " is 185.
Long Statement,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The length of the statement  "		ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength); " is 129.
Long Statement,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The length of the statement  "				System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ()); " is 131.
Long Statement,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The length of the statement  "				System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ()); " is 142.
Long Statement,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,device_OnPacketArrival,The length of the statement  "	if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 1) { " is 129.
Long Statement,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,device_OnPacketArrival,The length of the statement  "		Console.WriteLine ("{0}:{1}:{2}'{3} Len={4}  type = {5}"' time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType); " is 127.
Long Statement,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendPacket,The length of the statement  "	System.Net.NetworkInformation.PhysicalAddress ethSrcAddr = System.Net.NetworkInformation.PhysicalAddress.Parse ("02-1E-EC-8F-7F-E1"); " is 133.
Long Statement,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendPacket,The length of the statement  "	System.Net.NetworkInformation.PhysicalAddress ethDstAddr = System.Net.NetworkInformation.PhysicalAddress.Parse ("48-5B-39-ED-96-36"); " is 133.
Long Statement,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendPacket,The length of the statement  "	// I thought "None" for type would fill in type automatically; but it remained zero on the wire and was flagged "Malformed" " is 123.
Long Statement,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendPacket,The length of the statement  "	//Console.WriteLine("After updating calculated values' ValidUDPChecksum = " + udpPacket.ValidUDPChecksum + " ValidChecksum = " + udpPacket.ValidChecksum); " is 154.
Long Statement,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,AddValue,The length of the statement  "		throw new InvalidOperationException ("A DualGraph chart requires two data points. Use method AddValues(a' b) instead of AddValue(a)"); " is 134.
Long Statement,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawAverageLine,The length of the statement  "	g.DrawLine (perfChartStyle.AvgLinePen.Pen' surfaceRectangle.Left' verticalPosition' surfaceRectangle.Width' verticalPosition); " is 126.
Long Statement,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawBackgroundAndGrid,The length of the statement  "	using (Brush gradientBrush = new LinearGradientBrush (surfaceRectangle' perfChartStyle.BackgroundColorTop' perfChartStyle.BackgroundColorBottom' LinearGradientMode.Vertical)) { " is 176.
Long Statement,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawBackgroundAndGrid,The length of the statement  "		//                for (int i = surfaceRectangle.Top; i <= surfaceRectangle.Bottom; i += Convert.ToInt32(Math.Round(Grid_Y_spacing)) ) " is 133.
Complex Conditional,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parsePacket,The conditional expression  "packet.Data [12] == 8 && packet.Data [13] == 0 && packet.Data [14] == 0x15 && (packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET] >= (byte)DAN_gui_msg.MSG_TYPE.RSP_READ)"  is complex.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlehypothesisReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleSpectralInvAnt0ReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleSpectralInvAnt1ReadReply,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkBox_BER_COUNTER_ENABLE_if_Spectral_inv_On,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,StartLogRecording,The method has an empty catch block.
Empty Catch Block,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,stopDevice,The method has an empty catch block.
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,FindFontBounds,The following statement contains a magic number: b = new Bitmap (5' 5);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,FindFontBounds,The following statement contains a magic number: b = new Bitmap (5' 5);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if ((Width < 10) || (Height < 10)) {  	return;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if ((Width < 10) || (Height < 10)) {  	return;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (drawGaugeBackground) {  	drawGaugeBackground = false;  	FindFontBounds ();  	gaugeBitmap = new Bitmap (Width' Height' pe.Graphics);  	Graphics ggr = Graphics.FromImage (gaugeBitmap);  	ggr.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	if (BackgroundImage != null) {  		switch (BackgroundImageLayout) {  		case ImageLayout.Center:  			ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  			break;  		case ImageLayout.None:  			ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  			break;  		case ImageLayout.Stretch:  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  			break;  		case ImageLayout.Tile:  			Int32 pixelOffsetX = 0;  			Int32 pixelOffsetY = 0;  			while (pixelOffsetX < Width) {  				pixelOffsetY = 0;  				while (pixelOffsetY < Height) {  					ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  					pixelOffsetY += BackgroundImage.Height;  				}  				pixelOffsetX += BackgroundImage.Width;  			}  			break;  		case ImageLayout.Zoom:  			if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  				ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  			}  			else {  				ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  			}  			break;  		}  	}  	ggr.SmoothingMode = SmoothingMode.HighQuality;  	ggr.PixelOffsetMode = PixelOffsetMode.HighQuality;  	GraphicsPath gp = new GraphicsPath ();  	Single rangeStartAngle;  	Single rangeSweepAngle;  	for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  		if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  			rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  			gp.Reset ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_BaseArcRadius > 0) {  		ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  	}  	String valueText = "";  	SizeF boundingBox;  	Single countValue = 0;  	Int32 counter1 = 0;  	while (countValue <= (m_MaxValue - m_MinValue)) {  		valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  		ggr.ResetTransform ();  		boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		if (countValue < (m_MaxValue - m_MinValue)) {  			for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  				if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  					ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  					gp.Reset ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  					gp.Reverse ();  					gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  					gp.Reverse ();  					ggr.SetClip (gp);  				}  				else {  					ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				}  			}  		}  		ggr.SetClip (ClientRectangle);  		if (m_ScaleNumbersRotation != 0) {  			ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  			ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  		}  		ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  		if (counter1 >= ScaleNumbersStartScaleLine - 1) {  			ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  		}  		countValue += m_ScaleLinesMajorStepValue;  		counter1++;  	}  	ggr.ResetTransform ();  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;  	}  	for (Int32 counter = 0; counter < NUMOFCAPS; counter++) {  		if (m_CapText [counter] != "") {  			ggr.DrawString (m_CapText [counter]' Font' new SolidBrush (m_CapColor [counter])' m_CapPosition [counter].X' m_CapPosition [counter].Y' StringFormat.GenericTypographic);  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (BackgroundImage != null) {  	switch (BackgroundImageLayout) {  	case ImageLayout.Center:  		ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  		break;  	case ImageLayout.None:  		ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  		break;  	case ImageLayout.Stretch:  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  		break;  	case ImageLayout.Tile:  		Int32 pixelOffsetX = 0;  		Int32 pixelOffsetY = 0;  		while (pixelOffsetX < Width) {  			pixelOffsetY = 0;  			while (pixelOffsetY < Height) {  				ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  				pixelOffsetY += BackgroundImage.Height;  			}  			pixelOffsetX += BackgroundImage.Width;  		}  		break;  	case ImageLayout.Zoom:  		if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  			ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  		}  		else {  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  		}  		break;  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (BackgroundImage != null) {  	switch (BackgroundImageLayout) {  	case ImageLayout.Center:  		ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  		break;  	case ImageLayout.None:  		ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  		break;  	case ImageLayout.Stretch:  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  		break;  	case ImageLayout.Tile:  		Int32 pixelOffsetX = 0;  		Int32 pixelOffsetY = 0;  		while (pixelOffsetX < Width) {  			pixelOffsetY = 0;  			while (pixelOffsetY < Height) {  				ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  				pixelOffsetY += BackgroundImage.Height;  			}  			pixelOffsetX += BackgroundImage.Width;  		}  		break;  	case ImageLayout.Zoom:  		if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  			ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  		}  		else {  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  		}  		break;  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (BackgroundImage != null) {  	switch (BackgroundImageLayout) {  	case ImageLayout.Center:  		ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  		break;  	case ImageLayout.None:  		ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  		break;  	case ImageLayout.Stretch:  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  		break;  	case ImageLayout.Tile:  		Int32 pixelOffsetX = 0;  		Int32 pixelOffsetY = 0;  		while (pixelOffsetX < Width) {  			pixelOffsetY = 0;  			while (pixelOffsetY < Height) {  				ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  				pixelOffsetY += BackgroundImage.Height;  			}  			pixelOffsetX += BackgroundImage.Width;  		}  		break;  	case ImageLayout.Zoom:  		if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  			ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  		}  		else {  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  		}  		break;  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (BackgroundImage != null) {  	switch (BackgroundImageLayout) {  	case ImageLayout.Center:  		ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  		break;  	case ImageLayout.None:  		ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  		break;  	case ImageLayout.Stretch:  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  		break;  	case ImageLayout.Tile:  		Int32 pixelOffsetX = 0;  		Int32 pixelOffsetY = 0;  		while (pixelOffsetX < Width) {  			pixelOffsetY = 0;  			while (pixelOffsetY < Height) {  				ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  				pixelOffsetY += BackgroundImage.Height;  			}  			pixelOffsetX += BackgroundImage.Width;  		}  		break;  	case ImageLayout.Zoom:  		if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  			ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  		}  		else {  			ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  		}  		break;  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout) {  case ImageLayout.Center:  	ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  	break;  case ImageLayout.None:  	ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  	break;  case ImageLayout.Stretch:  	ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  	break;  case ImageLayout.Tile:  	Int32 pixelOffsetX = 0;  	Int32 pixelOffsetY = 0;  	while (pixelOffsetX < Width) {  		pixelOffsetY = 0;  		while (pixelOffsetY < Height) {  			ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  			pixelOffsetY += BackgroundImage.Height;  		}  		pixelOffsetX += BackgroundImage.Width;  	}  	break;  case ImageLayout.Zoom:  	if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  		ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  	}  	else {  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout) {  case ImageLayout.Center:  	ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  	break;  case ImageLayout.None:  	ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  	break;  case ImageLayout.Stretch:  	ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  	break;  case ImageLayout.Tile:  	Int32 pixelOffsetX = 0;  	Int32 pixelOffsetY = 0;  	while (pixelOffsetX < Width) {  		pixelOffsetY = 0;  		while (pixelOffsetY < Height) {  			ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  			pixelOffsetY += BackgroundImage.Height;  		}  		pixelOffsetX += BackgroundImage.Width;  	}  	break;  case ImageLayout.Zoom:  	if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  		ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  	}  	else {  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout) {  case ImageLayout.Center:  	ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  	break;  case ImageLayout.None:  	ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  	break;  case ImageLayout.Stretch:  	ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  	break;  case ImageLayout.Tile:  	Int32 pixelOffsetX = 0;  	Int32 pixelOffsetY = 0;  	while (pixelOffsetX < Width) {  		pixelOffsetY = 0;  		while (pixelOffsetY < Height) {  			ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  			pixelOffsetY += BackgroundImage.Height;  		}  		pixelOffsetX += BackgroundImage.Width;  	}  	break;  case ImageLayout.Zoom:  	if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  		ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  	}  	else {  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout) {  case ImageLayout.Center:  	ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  	break;  case ImageLayout.None:  	ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  	break;  case ImageLayout.Stretch:  	ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  	break;  case ImageLayout.Tile:  	Int32 pixelOffsetX = 0;  	Int32 pixelOffsetY = 0;  	while (pixelOffsetX < Width) {  		pixelOffsetY = 0;  		while (pixelOffsetY < Height) {  			ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  			pixelOffsetY += BackgroundImage.Height;  		}  		pixelOffsetX += BackgroundImage.Width;  	}  	break;  case ImageLayout.Zoom:  	if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  		ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  	}  	else {  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  	if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  		rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		gp.Reset ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  	if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  		rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		gp.Reset ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  	if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  		rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		gp.Reset ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  	if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  		rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		gp.Reset ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  	if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  		rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		gp.Reset ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter = 0; counter < NUMOFRANGES; counter++) {  	if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  		rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  		gp.Reset ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  	rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	gp.Reset ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  	rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	gp.Reset ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  	rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	gp.Reset ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  	rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	gp.Reset ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  	rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	gp.Reset ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_RangeEndValue [counter] > m_RangeStartValue [counter] && m_RangeEnabled [counter]) {  	rangeStartAngle = m_BaseArcStart + (m_RangeStartValue [counter] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	rangeSweepAngle = (m_RangeEndValue [counter] - m_RangeStartValue [counter]) * m_BaseArcSweep / (m_MaxValue - m_MinValue);  	gp.Reset ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddPie (new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddPie (new Rectangle (m_Center.X - m_RangeInnerRadius [counter]' m_Center.Y - m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter]' 2 * m_RangeInnerRadius [counter])' rangeStartAngle' rangeSweepAngle);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.FillPie (new SolidBrush (m_RangeColor [counter])' new Rectangle (m_Center.X - m_RangeOuterRadius [counter]' m_Center.Y - m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter]' 2 * m_RangeOuterRadius [counter])' rangeStartAngle' rangeSweepAngle);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_BaseArcRadius > 0) {  	ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (m_BaseArcRadius > 0) {  	ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawArc (new Pen (m_BaseArcColor' m_BaseArcWidth)' new Rectangle (m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2 * m_BaseArcRadius' 2 * m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: while (countValue <= (m_MaxValue - m_MinValue)) {  	valueText = (m_MinValue + countValue).ToString (m_ScaleNumbersFormat);  	ggr.ResetTransform ();  	boundingBox = ggr.MeasureString (valueText' Font' -1' StringFormat.GenericTypographic);  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	if (countValue < (m_MaxValue - m_MinValue)) {  		for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  			if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  				ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  				gp.Reset ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  				gp.Reverse ();  				gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  				gp.Reverse ();  				ggr.SetClip (gp);  			}  			else {  				ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			}  		}  	}  	ggr.SetClip (ClientRectangle);  	if (m_ScaleNumbersRotation != 0) {  		ggr.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  		ggr.RotateTransform (90.0F + m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue));  	}  	ggr.TranslateTransform ((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' System.Drawing.Drawing2D.MatrixOrder.Append);  	if (counter1 >= ScaleNumbersStartScaleLine - 1) {  		ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  	}  	countValue += m_ScaleLinesMajorStepValue;  	counter1++;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorOuterRadius' m_Center.Y - m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius' 2 * m_ScaleLinesMajorOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMajorInnerRadius' m_Center.Y - m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius' 2 * m_ScaleLinesMajorInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMajorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMajorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (countValue < (m_MaxValue - m_MinValue)) {  	for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  		if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  			ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  			gp.Reset ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  			gp.Reverse ();  			gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  			gp.Reverse ();  			ggr.SetClip (gp);  		}  		else {  			ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		}  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: for (Int32 counter2 = 1; counter2 <= m_ScaleLinesMinorNumOf; counter2++) {  	if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  		ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  		gp.Reset ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  		gp.Reverse ();  		gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  		gp.Reverse ();  		ggr.SetClip (gp);  	}  	else {  		ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	}  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (((m_ScaleLinesMinorNumOf % 2) == 1) && ((Int32)(m_ScaleLinesMinorNumOf / 2) + 1 == counter2)) {  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  	ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  	gp.Reset ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  	gp.Reverse ();  	gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  	gp.Reverse ();  	ggr.SetClip (gp);  }  else {  	ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterOuterRadius' m_Center.Y - m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius' 2 * m_ScaleLinesInterOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesInterInnerRadius' m_Center.Y - m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius' 2 * m_ScaleLinesInterInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesInterColor' m_ScaleLinesInterWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesInterOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesInterOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorOuterRadius' m_Center.Y - m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius' 2 * m_ScaleLinesMinorOuterRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse (new Rectangle (m_Center.X - m_ScaleLinesMinorInnerRadius' m_Center.Y - m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius' 2 * m_ScaleLinesMinorInnerRadius));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine (new Pen (m_ScaleLinesMinorColor' m_ScaleLinesMinorWidth)' (Single)(Center.X)' (Single)(Center.Y)' (Single)(Center.X + 2 * m_ScaleLinesMinorOuterRadius * Math.Cos ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0))' (Single)(Center.Y + 2 * m_ScaleLinesMinorOuterRadius * Math.Sin ((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue) + counter2 * m_BaseArcSweep / (((Single)((m_MaxValue - m_MinValue) / m_ScaleLinesMajorStepValue)) * (m_ScaleLinesMinorNumOf + 1))) * Math.PI / 180.0)));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (counter1 >= ScaleNumbersStartScaleLine - 1) {  	ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (counter1 >= ScaleNumbersStartScaleLine - 1) {  	ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: ggr.DrawString (valueText' Font' new SolidBrush (m_ScaleNumbersColor)' -boundingBox.Width / 2' -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1) / 2' StringFormat.GenericTypographic);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  	brushBucket = brush1;  	brush1 = brush2;  	brush2 = brushBucket;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  	brushBucket = brush1;  	brush1 = brush2;  	brush2 = brushBucket;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  	brushBucket = brush1;  	brush1 = brush2;  	brush2 = brushBucket;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  	brush4 = brush3;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  	brush4 = brush3;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  	brush4 = brush3;  }  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_configure,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	string[] items = line.Split (' ');  	//  uint address = uint.Parse(items[3]);  	uint address = Convert.ToUInt32 (items [3]' 16);  	uint value = Convert.ToUInt32 (items [5]' 16);  	DAN_write_msg msg = new DAN_write_msg (address' value);  	PcapConnection.pcap.sendDanMsg (msg);  	// refresh my cached values  	getNextValues ();  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_configure,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	string[] items = line.Split (' ');  	//  uint address = uint.Parse(items[3]);  	uint address = Convert.ToUInt32 (items [3]' 16);  	uint value = Convert.ToUInt32 (items [5]' 16);  	DAN_write_msg msg = new DAN_write_msg (address' value);  	PcapConnection.pcap.sendDanMsg (msg);  	// refresh my cached values  	getNextValues ();  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_configure,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	string[] items = line.Split (' ');  	//  uint address = uint.Parse(items[3]);  	uint address = Convert.ToUInt32 (items [3]' 16);  	uint value = Convert.ToUInt32 (items [5]' 16);  	DAN_write_msg msg = new DAN_write_msg (address' value);  	PcapConnection.pcap.sendDanMsg (msg);  	// refresh my cached values  	getNextValues ();  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_configure,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	string[] items = line.Split (' ');  	//  uint address = uint.Parse(items[3]);  	uint address = Convert.ToUInt32 (items [3]' 16);  	uint value = Convert.ToUInt32 (items [5]' 16);  	DAN_write_msg msg = new DAN_write_msg (address' value);  	PcapConnection.pcap.sendDanMsg (msg);  	// refresh my cached values  	getNextValues ();  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: j += 4
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,CDU,C:\repos\dan-sw_PTP_GUI\CDU.cs,CDU_Write_File,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,Constellation,The following statement contains a magic number: constellations = new PhyConstellationData[4];  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,Constellation,The following statement contains a magic number: constellations [2] = new PhyConstellationData (PhyConstellationData.Antenna.ANT1' PhyConstellationData.EqPosition.BEFORE' PLLDebug);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,Constellation,The following statement contains a magic number: constellations [3] = new PhyConstellationData (PhyConstellationData.Antenna.ANT2' PhyConstellationData.EqPosition.BEFORE' PLLDebug);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,Constellation,The following statement contains a magic number: if (FormNodeProperties.instance.CG_Constelliation_Enable) {  	ChannelsGain = new PhyChannelGainData[2];  	ChannelsGain [0] = new PhyChannelGainData (PhyChannelGainData.SampleTime.Current);  	ChannelsGain [1] = new PhyChannelGainData (PhyChannelGainData.SampleTime.History);  	ChannelsGain [0].ChannelGainEnableRead ();  	CGStart = true;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,Constellation,The following statement contains a magic number: ChannelsGain = new PhyChannelGainData[2];  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyConstellationData constellation in constellations) {  	int loop = 0;  	constellation.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!constellation.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  		//System.Console.WriteLine("    sleep {0} complete (elapsed ms={1})"' loop' st.ElapsedMilliseconds);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	//    constellation.isDataReady().ToString()' loop' st.ElapsedMilliseconds' logIndex);  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!constellation.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  	//System.Console.WriteLine("flushToTempFile {0} complete (elapsed ms={1})"' constellation.fileName' st.ElapsedMilliseconds);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyConstellationData constellation in constellations) {  	int loop = 0;  	constellation.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!constellation.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  		//System.Console.WriteLine("    sleep {0} complete (elapsed ms={1})"' loop' st.ElapsedMilliseconds);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	//    constellation.isDataReady().ToString()' loop' st.ElapsedMilliseconds' logIndex);  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!constellation.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  	//System.Console.WriteLine("flushToTempFile {0} complete (elapsed ms={1})"' constellation.fileName' st.ElapsedMilliseconds);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyConstellationData constellation in constellations) {  	int loop = 0;  	constellation.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!constellation.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  		//System.Console.WriteLine("    sleep {0} complete (elapsed ms={1})"' loop' st.ElapsedMilliseconds);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	//    constellation.isDataReady().ToString()' loop' st.ElapsedMilliseconds' logIndex);  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!constellation.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  	//System.Console.WriteLine("flushToTempFile {0} complete (elapsed ms={1})"' constellation.fileName' st.ElapsedMilliseconds);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyConstellationData constellation in constellations) {  	int loop = 0;  	constellation.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!constellation.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  		//System.Console.WriteLine("    sleep {0} complete (elapsed ms={1})"' loop' st.ElapsedMilliseconds);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	//    constellation.isDataReady().ToString()' loop' st.ElapsedMilliseconds' logIndex);  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!constellation.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  	//System.Console.WriteLine("flushToTempFile {0} complete (elapsed ms={1})"' constellation.fileName' st.ElapsedMilliseconds);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: Thread.Sleep (3);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: while (!constellation.isDataReady () && (loop++ < 300)) {  	Thread.Sleep (10);  	//System.Console.WriteLine("    sleep {0} complete (elapsed ms={1})"' loop' st.ElapsedMilliseconds);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: while (!constellation.isDataReady () && (loop++ < 300)) {  	Thread.Sleep (10);  	//System.Console.WriteLine("    sleep {0} complete (elapsed ms={1})"' loop' st.ElapsedMilliseconds);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (loop >= 300) {  	return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	ChannelsGain [0].ChannelGainActivate (false);  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		int loop = 0;  		ChannelGain.refreshData ();  		Thread.Sleep (3);  		// 3 ms  		// Waits' at most' 3 seconds for the EVB replies  		while (!ChannelGain.isDataReady () && (loop++ < 300)) {  			Thread.Sleep (10);  		}  		//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  		if (loop >= 300) {  			return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  		}  		logIndex++;  		if (!ChannelGain.flushToTempFile ()) {  			// flushToFile only returns false after retrying several times'  			// so it's appropriate to cancel the constellation process (i.e.'  			// no need to continue for the other constellation files)  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  		}  	}  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		if (!ChannelGain.moveToMatlabFile ()) {  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  			// failed  		}  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	ChannelsGain [0].ChannelGainActivate (false);  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		int loop = 0;  		ChannelGain.refreshData ();  		Thread.Sleep (3);  		// 3 ms  		// Waits' at most' 3 seconds for the EVB replies  		while (!ChannelGain.isDataReady () && (loop++ < 300)) {  			Thread.Sleep (10);  		}  		//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  		if (loop >= 300) {  			return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  		}  		logIndex++;  		if (!ChannelGain.flushToTempFile ()) {  			// flushToFile only returns false after retrying several times'  			// so it's appropriate to cancel the constellation process (i.e.'  			// no need to continue for the other constellation files)  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  		}  	}  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		if (!ChannelGain.moveToMatlabFile ()) {  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  			// failed  		}  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	ChannelsGain [0].ChannelGainActivate (false);  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		int loop = 0;  		ChannelGain.refreshData ();  		Thread.Sleep (3);  		// 3 ms  		// Waits' at most' 3 seconds for the EVB replies  		while (!ChannelGain.isDataReady () && (loop++ < 300)) {  			Thread.Sleep (10);  		}  		//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  		if (loop >= 300) {  			return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  		}  		logIndex++;  		if (!ChannelGain.flushToTempFile ()) {  			// flushToFile only returns false after retrying several times'  			// so it's appropriate to cancel the constellation process (i.e.'  			// no need to continue for the other constellation files)  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  		}  	}  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		if (!ChannelGain.moveToMatlabFile ()) {  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  			// failed  		}  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	ChannelsGain [0].ChannelGainActivate (false);  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		int loop = 0;  		ChannelGain.refreshData ();  		Thread.Sleep (3);  		// 3 ms  		// Waits' at most' 3 seconds for the EVB replies  		while (!ChannelGain.isDataReady () && (loop++ < 300)) {  			Thread.Sleep (10);  		}  		//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  		if (loop >= 300) {  			return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  		}  		logIndex++;  		if (!ChannelGain.flushToTempFile ()) {  			// flushToFile only returns false after retrying several times'  			// so it's appropriate to cancel the constellation process (i.e.'  			// no need to continue for the other constellation files)  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  		}  	}  	foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  		if (!ChannelGain.moveToMatlabFile ()) {  			return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  			// failed  		}  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  	int loop = 0;  	ChannelGain.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!ChannelGain.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!ChannelGain.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  	int loop = 0;  	ChannelGain.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!ChannelGain.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!ChannelGain.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  	int loop = 0;  	ChannelGain.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!ChannelGain.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!ChannelGain.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: foreach (PhyChannelGainData ChannelGain in ChannelsGain) {  	int loop = 0;  	ChannelGain.refreshData ();  	Thread.Sleep (3);  	// 3 ms  	// Waits' at most' 3 seconds for the EVB replies  	while (!ChannelGain.isDataReady () && (loop++ < 300)) {  		Thread.Sleep (10);  	}  	//System.Console.WriteLine("Data ready {0} for constellation part {3}' after {1} loops (elapsed ms={2})"'  	if (loop >= 300) {  		return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  	}  	logIndex++;  	if (!ChannelGain.flushToTempFile ()) {  		// flushToFile only returns false after retrying several times'  		// so it's appropriate to cancel the constellation process (i.e.'  		// no need to continue for the other constellation files)  		return TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE;  	}  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: Thread.Sleep (3);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: while (!ChannelGain.isDataReady () && (loop++ < 300)) {  	Thread.Sleep (10);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: while (!ChannelGain.isDataReady () && (loop++ < 300)) {  	Thread.Sleep (10);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (loop >= 300) {  	return TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("16")) {  	constellationMode = 16;  }  else if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("16")) {  	constellationMode = 16;  }  else if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("16")) {  	constellationMode = 16;  }  else if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("16")) {  	constellationMode = 16;  }  else if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("16")) {  	constellationMode = 16;  }  else if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: constellationMode = 16;  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("64")) {  	constellationMode = 64;  }  else if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: constellationMode = 64;  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("256")) {  	constellationMode = 256;  }  else if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: constellationMode = 256;  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (modString.Contains ("1024")) {  	constellationMode = 1024;  }  else {  	constellationMode = 4;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: constellationMode = 1024;  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: constellationMode = 4;  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (PhyProfile.profiles [FormNodeProperties.instance.RunningProfile].Bandwidth > 30) {  	selectedFFT = 1;  }  else {  	selectedFFT = 0;  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' ChannelsGain [0].filePath' ChannelsGain [1].filePath' constellationMode' FFTsizes [selectedFFT]);  }  else {  	args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' constellations [2].filePath' constellations [3].filePath' constellationMode' FFTsizes [selectedFFT]);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' ChannelsGain [0].filePath' ChannelsGain [1].filePath' constellationMode' FFTsizes [selectedFFT]);  }  else {  	args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' constellations [2].filePath' constellations [3].filePath' constellationMode' FFTsizes [selectedFFT]);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' constellations [2].filePath' constellations [3].filePath' constellationMode' FFTsizes [selectedFFT]);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: args_logic4 = String.Format ("{0} {1} {2} {3} {4} {5}"' constellations [0].filePath' constellations [1].filePath' constellations [2].filePath' constellations [3].filePath' constellationMode' FFTsizes [selectedFFT]);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: try {  	TextWriter tw = new StreamWriter (paramsfilePath);  	if (CGEnable) {  		tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + ChannelsGain [0].filePath + "\n" + ChannelsGain [1].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  	}  	else {  		tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing params file at {0} - {1} "' paramsfilePath' ex.Message);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: try {  	TextWriter tw = new StreamWriter (paramsfilePath);  	if (CGEnable) {  		tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + ChannelsGain [0].filePath + "\n" + ChannelsGain [1].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  	}  	else {  		tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing params file at {0} - {1} "' paramsfilePath' ex.Message);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + ChannelsGain [0].filePath + "\n" + ChannelsGain [1].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  }  else {  	tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: if (CGEnable) {  	tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + ChannelsGain [0].filePath + "\n" + ChannelsGain [1].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  }  else {  	tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  }  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  
Magic Number,WindowsFormsApplication1,Constellation,C:\repos\dan-sw_PTP_GUI\Constellation.cs,trigger,The following statement contains a magic number: tw.WriteLine (constellations [0].filePath + "\n" + constellations [1].filePath + "\n" + constellations [2].filePath + "\n" + constellations [3].filePath + "\n" + constellationMode.ToString () + "\n" + FFTsizes [selectedFFT].ToString () + "\n" + persistence.ToString () + "\n" + Channel_estimation_graph_enable);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers = new ProcessMessageDelegate[9];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [2] = this.handleUnitTypeReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [3] = this.handleUnitAntModeReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [4] = this.handlePLLReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [5] = this.handlehypothesisReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [6] = this.handleSpectralInvAnt0ReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [7] = this.handleSpectralInvAnt1ReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: handlers [8] = this.handleUnitDuplexModeReadReply;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,FormNodeProperties,The following statement contains a magic number: Update_Timer.Interval = 500;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,treeViewNodeProperties_AfterSelect,The following statement contains a magic number: if (Permissionlevel == 1) {  	if (selection == 14) {  		selection = 13;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,treeViewNodeProperties_AfterSelect,The following statement contains a magic number: if (Permissionlevel == 1) {  	if (selection == 14) {  		selection = 13;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,treeViewNodeProperties_AfterSelect,The following statement contains a magic number: if (selection == 14) {  	selection = 13;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,treeViewNodeProperties_AfterSelect,The following statement contains a magic number: if (selection == 14) {  	selection = 13;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,treeViewNodeProperties_AfterSelect,The following statement contains a magic number: selection = 13;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS3.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [2]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS4.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [3]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS5.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [4]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS6.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [5]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS7.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [6]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS8.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [7]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS9.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [8]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,comboBoxPhyProfile_SelectedIndexChanged,The following statement contains a magic number: this.textBoxPhyExpectedThroughputMCS10.Text = String.Format ("{0:n1} Mb/s"' CalcRateResults [9]);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryRead_Click,The following statement contains a magic number: try {  	UInt32 address = (uint)Convert.ToInt32 (textBoxMemoryAddr.Text' 16);  	blockAddrs [0] = address;  	getNextValues ();  	//DAN_read_array_msg msg = new DAN_read_array_msg(address' 64);  	//outstandingRequestSeq = msg.seq;  	//PcapConnection.pcap.sendDanMsg(msg);  }  catch (System.FormatException) {  	MessageBox.Show ("Please enter a hexadecimal number"' "Invalid Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	this.textBoxMemoryAddr.Focus ();  	this.textBoxMemoryAddr.SelectAll ();  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleMemoryReadReply,The following statement contains a magic number: for (int i = 0; i < msg.size;) {  	string[] rowString = new string[5];  	rowString [0] = addr.ToString ("x8");  	for (int j = 0; j < 4; j++) {  		if (i >= msg.size) {  			rowString [j + 1] = "";  		}  		else {  			rowString [j + 1] = msg.data [i++].ToString ("x8");  		}  	}  	listViewMemory.Items.Add (new ListViewItem (rowString));  	addr += 16;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleMemoryReadReply,The following statement contains a magic number: for (int i = 0; i < msg.size;) {  	string[] rowString = new string[5];  	rowString [0] = addr.ToString ("x8");  	for (int j = 0; j < 4; j++) {  		if (i >= msg.size) {  			rowString [j + 1] = "";  		}  		else {  			rowString [j + 1] = msg.data [i++].ToString ("x8");  		}  	}  	listViewMemory.Items.Add (new ListViewItem (rowString));  	addr += 16;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleMemoryReadReply,The following statement contains a magic number: for (int i = 0; i < msg.size;) {  	string[] rowString = new string[5];  	rowString [0] = addr.ToString ("x8");  	for (int j = 0; j < 4; j++) {  		if (i >= msg.size) {  			rowString [j + 1] = "";  		}  		else {  			rowString [j + 1] = msg.data [i++].ToString ("x8");  		}  	}  	listViewMemory.Items.Add (new ListViewItem (rowString));  	addr += 16;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleMemoryReadReply,The following statement contains a magic number: for (int j = 0; j < 4; j++) {  	if (i >= msg.size) {  		rowString [j + 1] = "";  	}  	else {  		rowString [j + 1] = msg.data [i++].ToString ("x8");  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleMemoryReadReply,The following statement contains a magic number: addr += 16;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryWrite_Click,The following statement contains a magic number: try {  	address = (uint)Convert.ToInt32 (textBoxMemoryAddr.Text' 16);  }  catch (System.FormatException) {  	// TabControl selection only needed if this was an OK button handler  	//this.tabControlNodePropertyPages.SelectedIndex = MEM_VIEWER_PAGE;  	this.textBoxMemoryAddr.Focus ();  	this.textBoxMemoryAddr.SelectAll ();  	MessageBox.Show ("Please enter a hexadecimal number"' "Invalid Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	return;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryWrite_Click,The following statement contains a magic number: address = (uint)Convert.ToInt32 (textBoxMemoryAddr.Text' 16);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryWrite_Click,The following statement contains a magic number: try {  	value = (uint)Convert.ToInt32 (textBoxMemoryValue.Text' 16);  }  catch (System.FormatException) {  	//this.tabControlNodePropertyPages.SelectedIndex = MEM_VIEWER_PAGE;  	this.textBoxMemoryValue.Focus ();  	this.textBoxMemoryValue.SelectAll ();  	MessageBox.Show ("Please enter a hexadecimal number"' "Invalid Address"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	return;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonMemoryWrite_Click,The following statement contains a magic number: value = (uint)Convert.ToInt32 (textBoxMemoryValue.Text' 16);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,setCombosFromMCS,The following statement contains a magic number: switch (RunningProfile) {  case 0:  	bw = MCS.BANDWIDTH.MHZ80;  	break;  case 1:  	bw = MCS.BANDWIDTH.MHZ56;  	break;  case 2:  	bw = MCS.BANDWIDTH.MHZ28;  	break;  case 21:  	bw = MCS.BANDWIDTH.MHZ20;  	break;  case 22:  	bw = MCS.BANDWIDTH.MHZ10;  	break;  case 39:  	bw = MCS.BANDWIDTH.MHZ112;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,setCombosFromMCS,The following statement contains a magic number: switch (RunningProfile) {  case 0:  	bw = MCS.BANDWIDTH.MHZ80;  	break;  case 1:  	bw = MCS.BANDWIDTH.MHZ56;  	break;  case 2:  	bw = MCS.BANDWIDTH.MHZ28;  	break;  case 21:  	bw = MCS.BANDWIDTH.MHZ20;  	break;  case 22:  	bw = MCS.BANDWIDTH.MHZ10;  	break;  case 39:  	bw = MCS.BANDWIDTH.MHZ112;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,setCombosFromMCS,The following statement contains a magic number: switch (RunningProfile) {  case 0:  	bw = MCS.BANDWIDTH.MHZ80;  	break;  case 1:  	bw = MCS.BANDWIDTH.MHZ56;  	break;  case 2:  	bw = MCS.BANDWIDTH.MHZ28;  	break;  case 21:  	bw = MCS.BANDWIDTH.MHZ20;  	break;  case 22:  	bw = MCS.BANDWIDTH.MHZ10;  	break;  case 39:  	bw = MCS.BANDWIDTH.MHZ112;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,setCombosFromMCS,The following statement contains a magic number: switch (RunningProfile) {  case 0:  	bw = MCS.BANDWIDTH.MHZ80;  	break;  case 1:  	bw = MCS.BANDWIDTH.MHZ56;  	break;  case 2:  	bw = MCS.BANDWIDTH.MHZ28;  	break;  case 21:  	bw = MCS.BANDWIDTH.MHZ20;  	break;  case 22:  	bw = MCS.BANDWIDTH.MHZ10;  	break;  case 39:  	bw = MCS.BANDWIDTH.MHZ112;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS3.Text = MCSs [2];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS4.Text = MCSs [3];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS5.Text = MCSs [4];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS6.Text = MCSs [5];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS7.Text = MCSs [6];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS8.Text = MCSs [7];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS9.Text = MCSs [8];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initMCSTab,The following statement contains a magic number: MCS10.Text = MCSs [9];  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following statement contains a magic number: switch (comboBoxMCSSetSelect.Text) {  case ("MCS Set 1"):  	MCSSet = 1;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 2"):  	MCSSet = 2;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 3"):  	MCSSet = 3;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 4"):  	MCSSet = 4;  	MCSSetAutomatic = false;  	break;  case ("Automatic"):  	MCSSet = (int)PHY.phy.MCS_Set;  	MCSSetAutomatic = true;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following statement contains a magic number: switch (comboBoxMCSSetSelect.Text) {  case ("MCS Set 1"):  	MCSSet = 1;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 2"):  	MCSSet = 2;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 3"):  	MCSSet = 3;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 4"):  	MCSSet = 4;  	MCSSetAutomatic = false;  	break;  case ("Automatic"):  	MCSSet = (int)PHY.phy.MCS_Set;  	MCSSetAutomatic = true;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following statement contains a magic number: switch (comboBoxMCSSetSelect.Text) {  case ("MCS Set 1"):  	MCSSet = 1;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 2"):  	MCSSet = 2;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 3"):  	MCSSet = 3;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 4"):  	MCSSet = 4;  	MCSSetAutomatic = false;  	break;  case ("Automatic"):  	MCSSet = (int)PHY.phy.MCS_Set;  	MCSSetAutomatic = true;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following statement contains a magic number: MCSSet = 2;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following statement contains a magic number: MCSSet = 3;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following statement contains a magic number: MCSSet = 4;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_BER_Enable) {  	dataGridView1.Rows.Add ("Ant0 Bit Counter :"' bit_counter_ant0);  	dataGridView1.Rows.Add ("Ant0 Bit CRC Counter :"' error_bit_counter_ant0);  	dataGridView1.Rows.Add ("Ant0 BER :"' String.Format (" {0:0.0e+0}"' BER_calc_ant0));  	dataGridView1.Rows.Add ("Ant1 Bit Counter :"' bit_counter_ant1);  	dataGridView1.Rows.Add ("Ant1 Bit CRC Counter :"' error_bit_counter_ant1);  	dataGridView1.Rows.Add ("Ant1 BER :"' String.Format (" {0:0.0e+0}"' BER_calc_ant1));  	for (int i = 9; i < 15; i++) {  		this.dataGridView1.Rows [i].DefaultCellStyle.BackColor = Color.Orange;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_BER_Enable) {  	dataGridView1.Rows.Add ("Ant0 Bit Counter :"' bit_counter_ant0);  	dataGridView1.Rows.Add ("Ant0 Bit CRC Counter :"' error_bit_counter_ant0);  	dataGridView1.Rows.Add ("Ant0 BER :"' String.Format (" {0:0.0e+0}"' BER_calc_ant0));  	dataGridView1.Rows.Add ("Ant1 Bit Counter :"' bit_counter_ant1);  	dataGridView1.Rows.Add ("Ant1 Bit CRC Counter :"' error_bit_counter_ant1);  	dataGridView1.Rows.Add ("Ant1 BER :"' String.Format (" {0:0.0e+0}"' BER_calc_ant1));  	for (int i = 9; i < 15; i++) {  		this.dataGridView1.Rows [i].DefaultCellStyle.BackColor = Color.Orange;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: for (int i = 9; i < 15; i++) {  	this.dataGridView1.Rows [i].DefaultCellStyle.BackColor = Color.Orange;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: for (int i = 9; i < 15; i++) {  	this.dataGridView1.Rows [i].DefaultCellStyle.BackColor = Color.Orange;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_Uncoded_BER_Enable) {  	//  this.dataGridView1.GridColor = Color.Red;  	dataGridView1.Rows.Add ("Ant0 uncoded CRC :"' error_bit_uncoded_ant0);  	dataGridView1.Rows.Add ("Ant0 uncoded BER :"' String.Format (" {0:0.0e+0}"' uncoded_BER_Ant0));  	dataGridView1.Rows.Add ("Ant1 uncoded CRC :"' error_bit_uncoded_ant1);  	dataGridView1.Rows.Add ("Ant1 uncoded BER :"' String.Format (" {0:0.0e+0}"' uncoded_BER_Ant1));  	int j;  	if (Check_BER_Enable) {  		j = 15;  	}  	else {  		j = 9;  	}  	for (int i = 0; i < 4; i++) {  		this.dataGridView1.Rows [i + j].DefaultCellStyle.BackColor = Color.OrangeRed;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_Uncoded_BER_Enable) {  	//  this.dataGridView1.GridColor = Color.Red;  	dataGridView1.Rows.Add ("Ant0 uncoded CRC :"' error_bit_uncoded_ant0);  	dataGridView1.Rows.Add ("Ant0 uncoded BER :"' String.Format (" {0:0.0e+0}"' uncoded_BER_Ant0));  	dataGridView1.Rows.Add ("Ant1 uncoded CRC :"' error_bit_uncoded_ant1);  	dataGridView1.Rows.Add ("Ant1 uncoded BER :"' String.Format (" {0:0.0e+0}"' uncoded_BER_Ant1));  	int j;  	if (Check_BER_Enable) {  		j = 15;  	}  	else {  		j = 9;  	}  	for (int i = 0; i < 4; i++) {  		this.dataGridView1.Rows [i + j].DefaultCellStyle.BackColor = Color.OrangeRed;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_Uncoded_BER_Enable) {  	//  this.dataGridView1.GridColor = Color.Red;  	dataGridView1.Rows.Add ("Ant0 uncoded CRC :"' error_bit_uncoded_ant0);  	dataGridView1.Rows.Add ("Ant0 uncoded BER :"' String.Format (" {0:0.0e+0}"' uncoded_BER_Ant0));  	dataGridView1.Rows.Add ("Ant1 uncoded CRC :"' error_bit_uncoded_ant1);  	dataGridView1.Rows.Add ("Ant1 uncoded BER :"' String.Format (" {0:0.0e+0}"' uncoded_BER_Ant1));  	int j;  	if (Check_BER_Enable) {  		j = 15;  	}  	else {  		j = 9;  	}  	for (int i = 0; i < 4; i++) {  		this.dataGridView1.Rows [i + j].DefaultCellStyle.BackColor = Color.OrangeRed;  	}  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_BER_Enable) {  	j = 15;  }  else {  	j = 9;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: if (Check_BER_Enable) {  	j = 15;  }  else {  	j = 9;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: j = 15;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: j = 9;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initPHYCountersTab,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.dataGridView1.Rows [i + j].DefaultCellStyle.BackColor = Color.OrangeRed;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleUnitAntModeReadReply,The following statement contains a magic number: if (msg.data [0] == 0) {  	SisoMimoMode = "Single SISO";  }  else if (msg.data [0] == 1) {  	SisoMimoMode = "Double SISO";  }  else if (msg.data [0] == 2) {  	SisoMimoMode = "XPIC(MIMO)";  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleUnitAntModeReadReply,The following statement contains a magic number: if (msg.data [0] == 1) {  	SisoMimoMode = "Double SISO";  }  else if (msg.data [0] == 2) {  	SisoMimoMode = "XPIC(MIMO)";  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handleUnitAntModeReadReply,The following statement contains a magic number: if (msg.data [0] == 2) {  	SisoMimoMode = "XPIC(MIMO)";  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initConstellationTab,The following statement contains a magic number: try {  	this.textBoxConstellationUpdateInterval.Text = FormSystemStatus.ConstellationUpdateIntervalSec.ToString ();  	this.textBoxConstellationDataFolder.Text = PhyConstellationData.folderRoot;  	this.textBoxConstellationExecutable.Text = Constellation.constellationExecutable;  	this.comboBoxConstellationFFT.Items.Clear ();  	int selectionIndex = 0;  	int i = 0;  	foreach (int fft in Constellation.FFTsizes) {  		this.comboBoxConstellationFFT.Items.Add (fft.ToString ());  		if (fft == Constellation.selectedFFT) {  			selectionIndex = i;  		}  		i++;  	}  	this.comboBoxConstellationFFT.SelectedIndex = selectionIndex;  	if (PhyProfile.profiles [FormNodeProperties.instance.RunningProfile].Bandwidth > 30) {  		this.comboBoxConstellationFFT.SelectedIndex = 1;  	}  	else {  		this.comboBoxConstellationFFT.SelectedIndex = 0;  	}  }  catch (Exception e) {  	System.Console.WriteLine ("Error {0} {1}"' e.ToString ()' e.Message);  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,initConstellationTab,The following statement contains a magic number: if (PhyProfile.profiles [FormNodeProperties.instance.RunningProfile].Bandwidth > 30) {  	this.comboBoxConstellationFFT.SelectedIndex = 1;  }  else {  	this.comboBoxConstellationFFT.SelectedIndex = 0;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The following statement contains a magic number: try {  	newInterval = Convert.ToInt32 (textBoxConstellationUpdateInterval.Text);  	if (newInterval < 1 || newInterval > 20) {  		throw new System.FormatException ();  	}  }  catch (System.FormatException) {  	this.textBoxConstellationUpdateInterval.Focus ();  	this.textBoxConstellationUpdateInterval.SelectAll ();  	MessageBox.Show ("Please enter a number' between 0 and 21' for Matlab update"' "Invalid Interval"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	return;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonConstellationApply_Click,The following statement contains a magic number: if (newInterval < 1 || newInterval > 20) {  	throw new System.FormatException ();  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonApply_Click,The following statement contains a magic number: if ((textBoxUserName.Text == "admin") && (textBoxPassword.Text == "admin")) {  	Permissionlevel = 2;  }  else {  	Permissionlevel = 1;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonApply_Click,The following statement contains a magic number: Permissionlevel = 2;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_Working_Mode]) {  	case (257):  		//0x0101  		comboBoxPLLWorkingMode.SelectedIndex = 0;  		break;  	case (17):  		//0x0011  		comboBoxPLLWorkingMode.SelectedIndex = 1;  		break;  	case (1):  		//0x0001  		comboBoxPLLWorkingMode.SelectedIndex = 2;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_Working_Mode]) {  	case (257):  		//0x0101  		comboBoxPLLWorkingMode.SelectedIndex = 0;  		break;  	case (17):  		//0x0011  		comboBoxPLLWorkingMode.SelectedIndex = 1;  		break;  	case (1):  		//0x0001  		comboBoxPLLWorkingMode.SelectedIndex = 2;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_Working_Mode]) {  	case (257):  		//0x0101  		comboBoxPLLWorkingMode.SelectedIndex = 0;  		break;  	case (17):  		//0x0011  		comboBoxPLLWorkingMode.SelectedIndex = 1;  		break;  	case (1):  		//0x0001  		comboBoxPLLWorkingMode.SelectedIndex = 2;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_Working_Mode]) {  case (257):  	//0x0101  	comboBoxPLLWorkingMode.SelectedIndex = 0;  	break;  case (17):  	//0x0011  	comboBoxPLLWorkingMode.SelectedIndex = 1;  	break;  case (1):  	//0x0001  	comboBoxPLLWorkingMode.SelectedIndex = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_Working_Mode]) {  case (257):  	//0x0101  	comboBoxPLLWorkingMode.SelectedIndex = 0;  	break;  case (17):  	//0x0011  	comboBoxPLLWorkingMode.SelectedIndex = 1;  	break;  case (1):  	//0x0001  	comboBoxPLLWorkingMode.SelectedIndex = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_Working_Mode]) {  case (257):  	//0x0101  	comboBoxPLLWorkingMode.SelectedIndex = 0;  	break;  case (17):  	//0x0011  	comboBoxPLLWorkingMode.SelectedIndex = 1;  	break;  case (1):  	//0x0001  	comboBoxPLLWorkingMode.SelectedIndex = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLWorkingMode.SelectedIndex = 2;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B1]) {  	case (3648):  		//0xe40  		comboBoxPLLLoopBWB1.SelectedIndex = 0;  		break;  	case (2736):  		//0xab0  		comboBoxPLLLoopBWB1.SelectedIndex = 1;  		break;  	case (1824):  		//0x720  		comboBoxPLLLoopBWB1.SelectedIndex = 2;  		break;  	case (912):  		//0x390  		comboBoxPLLLoopBWB1.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB1.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B1]) {  case (3648):  	//0xe40  	comboBoxPLLLoopBWB1.SelectedIndex = 0;  	break;  case (2736):  	//0xab0  	comboBoxPLLLoopBWB1.SelectedIndex = 1;  	break;  case (1824):  	//0x720  	comboBoxPLLLoopBWB1.SelectedIndex = 2;  	break;  case (912):  	//0x390  	comboBoxPLLLoopBWB1.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB1.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLLoopBWB1.SelectedIndex = 2;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLLoopBWB1.SelectedIndex = 3;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLLoopBWB1.SelectedIndex = 4;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	switch (msg.data [PLL_LOOP_BW_B2]) {  	case (156):  		//0x09c  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		break;  	case (88):  		//0x058  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		break;  	case (39):  		//0x027  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		break;  	case (10):  		//0x00a  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		break;  	default:  		comboBoxPLLLoopBWB2.SelectedIndex = 4;  		break;  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: switch (msg.data [PLL_LOOP_BW_B2]) {  case (156):  	//0x09c  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	break;  case (88):  	//0x058  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	break;  case (39):  	//0x027  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	break;  case (10):  	//0x00a  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	break;  default:  	comboBoxPLLLoopBWB2.SelectedIndex = 4;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLLoopBWB2.SelectedIndex = 2;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLLoopBWB2.SelectedIndex = 3;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: comboBoxPLLLoopBWB2.SelectedIndex = 4;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	int index = (Convert.ToInt32 (msg.data [PLL_CINR_Factor].ToString ()) / 1638);  	comboBoxCINRFactor.SelectedIndex = (index - 1);  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following statement contains a magic number: try {  	int index = (Convert.ToInt32 (msg.data [PLL_Ch_Est_Factor].ToString ()) / 1638);  	comboBoxChannelEstimationFactor.SelectedIndex = (index - 1);  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: try {  	//Working Mode config  	switch (comboBoxPLLWorkingMode.SelectedIndex) {  	case (0):  		// 257                     		value = 0x0101;  		break;  	case (1):  		// 17  		value = 0x0011;  		break;  	case (2):  		// 1     		value = 0x0001;  		break;  	}  	write_new_command (blockAddrs [4]' value);  	//PLL loop B1 config   	switch (comboBoxPLLLoopBWB1.SelectedIndex) {  	case (0):  		//3648                     		value = 0xe40;  		break;  	case (1):  		//2736  		value = 0xab0;  		break;  	case (2):  		//1824  		value = 0x720;  		break;  	case (3):  		//912  		value = 0x390;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x04' value);  	//PLL loop B2 config  	switch (comboBoxPLLLoopBWB2.SelectedIndex) {  	case (0):  		//156  		comboBoxPLLLoopBWB2.SelectedIndex = 0;  		value = 0x09c;  		break;  	case (1):  		//88  		comboBoxPLLLoopBWB2.SelectedIndex = 1;  		value = 0x058;  		break;  	case (2):  		//39  		comboBoxPLLLoopBWB2.SelectedIndex = 2;  		value = 0x027;  		break;  	case (3):  		//10  		comboBoxPLLLoopBWB2.SelectedIndex = 3;  		value = 0x00a;  		break;  	default:  		value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  		break;  	}  	write_new_command (blockAddrs [4] + 0x08' value);  	//PLL derotation  	if (comboBoxDisablePLLDerotation.SelectedIndex == 0) {  		value = 1;  	}  	else {  		value = 0;  	}  	write_new_command (blockAddrs [4] + 0x10' value);  	//CINRFactor  	uint index = (UInt32)comboBoxCINRFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x18' value);  	//ChannelEstimationFactor  	index = (UInt32)comboBoxChannelEstimationFactor.SelectedIndex + 1;  	value = index * 1638;  	write_new_command (blockAddrs [4] + 0x14' value);  	//spctral Inversion  	if (comboBoxSpectralInversion.SelectedIndex == 1) {  		value = 0x00000808;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  	else {  		value = 0x00000000;  		write_new_command (blockAddrs [6]' value);  		write_new_command (blockAddrs [7]' value);  	}  }  catch {  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLWorkingMode.SelectedIndex) {  case (0):  	// 257                     	value = 0x0101;  	break;  case (1):  	// 17  	value = 0x0011;  	break;  case (2):  	// 1     	value = 0x0001;  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [4]' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLLoopBWB1.SelectedIndex) {  case (0):  	//3648                     	value = 0xe40;  	break;  case (1):  	//2736  	value = 0xab0;  	break;  case (2):  	//1824  	value = 0x720;  	break;  case (3):  	//912  	value = 0x390;  	break;  default:  	value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLLoopBWB1.SelectedIndex) {  case (0):  	//3648                     	value = 0xe40;  	break;  case (1):  	//2736  	value = 0xab0;  	break;  case (2):  	//1824  	value = 0x720;  	break;  case (3):  	//912  	value = 0x390;  	break;  default:  	value = Convert.ToUInt32 (comboBoxPLLLoopBWB1.Text.ToString ());  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [4] + 0x04' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLLoopBWB2.SelectedIndex) {  case (0):  	//156  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	value = 0x09c;  	break;  case (1):  	//88  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	value = 0x058;  	break;  case (2):  	//39  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	value = 0x027;  	break;  case (3):  	//10  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	value = 0x00a;  	break;  default:  	value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLLoopBWB2.SelectedIndex) {  case (0):  	//156  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	value = 0x09c;  	break;  case (1):  	//88  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	value = 0x058;  	break;  case (2):  	//39  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	value = 0x027;  	break;  case (3):  	//10  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	value = 0x00a;  	break;  default:  	value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLLoopBWB2.SelectedIndex) {  case (0):  	//156  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	value = 0x09c;  	break;  case (1):  	//88  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	value = 0x058;  	break;  case (2):  	//39  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	value = 0x027;  	break;  case (3):  	//10  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	value = 0x00a;  	break;  default:  	value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: switch (comboBoxPLLLoopBWB2.SelectedIndex) {  case (0):  	//156  	comboBoxPLLLoopBWB2.SelectedIndex = 0;  	value = 0x09c;  	break;  case (1):  	//88  	comboBoxPLLLoopBWB2.SelectedIndex = 1;  	value = 0x058;  	break;  case (2):  	//39  	comboBoxPLLLoopBWB2.SelectedIndex = 2;  	value = 0x027;  	break;  case (3):  	//10  	comboBoxPLLLoopBWB2.SelectedIndex = 3;  	value = 0x00a;  	break;  default:  	value = Convert.ToUInt32 (comboBoxPLLLoopBWB2.Text.ToString ());  	break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: comboBoxPLLLoopBWB2.SelectedIndex = 2;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: comboBoxPLLLoopBWB2.SelectedIndex = 3;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [4] + 0x08' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [4] + 0x10' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: value = index * 1638;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [4] + 0x18' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: value = index * 1638;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [4] + 0x14' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: if (comboBoxSpectralInversion.SelectedIndex == 1) {  	value = 0x00000808;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  else {  	value = 0x00000000;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: if (comboBoxSpectralInversion.SelectedIndex == 1) {  	value = 0x00000808;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  else {  	value = 0x00000000;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: if (comboBoxSpectralInversion.SelectedIndex == 1) {  	value = 0x00000808;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  else {  	value = 0x00000000;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: if (comboBoxSpectralInversion.SelectedIndex == 1) {  	value = 0x00000808;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  else {  	value = 0x00000000;  	write_new_command (blockAddrs [6]' value);  	write_new_command (blockAddrs [7]' value);  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [6]' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [7]' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [6]' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following statement contains a magic number: write_new_command (blockAddrs [7]' value);  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonCDUDownloadResults_Click_1,The following statement contains a magic number: while (get_cdu_results.get_all_messages () != true) {  	i++;  	if (i > 200000)  		break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonCDUDownloadResults_Click_1,The following statement contains a magic number: if (i > 200000)  	break;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDownloadMemory_Click_1,The following statement contains a magic number: while (memory_dump.get_all_messages () != true) {  	i++;  	if (i > 200000)  		break;  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDownloadMemory_Click_1,The following statement contains a magic number: if (i > 200000)  	break;  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,Save_Log_To_Files,The following statement contains a magic number: if ((PhyCfi.Length > 10000) && (GmacCfi.Length > 10000) || (PhySfi.Length > 100000)) {  	StopLogRecording ();  	StartLogRecording ();  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,Save_Log_To_Files,The following statement contains a magic number: if ((PhyCfi.Length > 10000) && (GmacCfi.Length > 10000) || (PhySfi.Length > 100000)) {  	StopLogRecording ();  	StartLogRecording ();  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,Save_Log_To_Files,The following statement contains a magic number: if ((PhyCfi.Length > 10000) && (GmacCfi.Length > 10000) || (PhySfi.Length > 100000)) {  	StopLogRecording ();  	StartLogRecording ();  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: if (Check_BER_Enable) {  	PHYCDataToSave += Convert.ToString ((PHY.phy.BER_Good_bits_Ant0 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.BER_Good_bits_Ant1 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant1)) + " ' ";  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: if (Check_BER_Enable) {  	PHYCDataToSave += Convert.ToString ((PHY.phy.BER_Good_bits_Ant0 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.BER_Good_bits_Ant1 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant1)) + " ' ";  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: PHYCDataToSave += Convert.ToString ((PHY.phy.BER_Good_bits_Ant0 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.BER_Good_bits_Ant1 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant1)) + " ' ";  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: PHYCDataToSave += Convert.ToString ((PHY.phy.BER_Good_bits_Ant0 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.BER_Good_bits_Ant1 * 32)) + " ' " + Convert.ToString ((PHY.phy.BER_Error_bits_Ant1)) + " ' ";  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: if (Check_Uncoded_BER_Enable) {  	PHYCDataToSave += Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Good_bits * 8 * 4));  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: if (Check_Uncoded_BER_Enable) {  	PHYCDataToSave += Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Good_bits * 8 * 4));  }  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: PHYCDataToSave += Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Good_bits * 8 * 4));  
Magic Number,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,LogPHYCToFile,The following statement contains a magic number: PHYCDataToSave += Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Error_bits_Ant0)) + " ' " + Convert.ToString ((PHY.phy.Uncoded_BER_Good_bits * 8 * 4));  
Magic Number,WindowsFormsApplication1,LinkIndicator,C:\repos\dan-sw_PTP_GUI\LinkIndicator.cs,LinkIndicator,The following statement contains a magic number: handlers = new ProcessMessageDelegate[6];  
Magic Number,WindowsFormsApplication1,LinkIndicator,C:\repos\dan-sw_PTP_GUI\LinkIndicator.cs,LinkIndicator,The following statement contains a magic number: handlers [2] = this.handleTxOn1;  
Magic Number,WindowsFormsApplication1,LinkIndicator,C:\repos\dan-sw_PTP_GUI\LinkIndicator.cs,LinkIndicator,The following statement contains a magic number: handlers [3] = this.handleGong;  
Magic Number,WindowsFormsApplication1,LinkIndicator,C:\repos\dan-sw_PTP_GUI\LinkIndicator.cs,LinkIndicator,The following statement contains a magic number: handlers [4] = this.handlePLLAnt0;  
Magic Number,WindowsFormsApplication1,LinkIndicator,C:\repos\dan-sw_PTP_GUI\LinkIndicator.cs,LinkIndicator,The following statement contains a magic number: handlers [5] = this.handlePLLAnt1;  
Magic Number,WindowsFormsApplication1,LinkIndicator,C:\repos\dan-sw_PTP_GUI\LinkIndicator.cs,handleSyncTimingPll,The following statement contains a magic number: timingLoopOK = (((msg.data [0] == 2) || (msg.data [0] == 0)) ? true : false);  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following statement contains a magic number: if (Specific_BW_MCS) {  	switch (BW) {  	case (BANDWIDTH.MHZ80):  		Current_MCS_scheme = mcsSet80;  		break;  	case (BANDWIDTH.MHZ56):  		Current_MCS_scheme = mcsSet56;  		break;  	case (BANDWIDTH.MHZ28):  		Current_MCS_scheme = mcsSet28;  		break;  	}  }  else {  	//switch (FormNodeProperties.instance.MCSSet)  	switch (MCSSetIndex) {  	case (1):  		Current_MCS_scheme = mcsMiroWaveSet1;  		break;  	case (2):  		Current_MCS_scheme = mcsMiroWaveSet2;  		break;  	case (3):  		Current_MCS_scheme = mcsMiroWaveSet3;  		break;  	case (4):  		Current_MCS_scheme = mcsMiroWaveSet4;  		break;  	default:  		Current_MCS_scheme = mcsMiroWaveSet2;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following statement contains a magic number: if (Specific_BW_MCS) {  	switch (BW) {  	case (BANDWIDTH.MHZ80):  		Current_MCS_scheme = mcsSet80;  		break;  	case (BANDWIDTH.MHZ56):  		Current_MCS_scheme = mcsSet56;  		break;  	case (BANDWIDTH.MHZ28):  		Current_MCS_scheme = mcsSet28;  		break;  	}  }  else {  	//switch (FormNodeProperties.instance.MCSSet)  	switch (MCSSetIndex) {  	case (1):  		Current_MCS_scheme = mcsMiroWaveSet1;  		break;  	case (2):  		Current_MCS_scheme = mcsMiroWaveSet2;  		break;  	case (3):  		Current_MCS_scheme = mcsMiroWaveSet3;  		break;  	case (4):  		Current_MCS_scheme = mcsMiroWaveSet4;  		break;  	default:  		Current_MCS_scheme = mcsMiroWaveSet2;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following statement contains a magic number: if (Specific_BW_MCS) {  	switch (BW) {  	case (BANDWIDTH.MHZ80):  		Current_MCS_scheme = mcsSet80;  		break;  	case (BANDWIDTH.MHZ56):  		Current_MCS_scheme = mcsSet56;  		break;  	case (BANDWIDTH.MHZ28):  		Current_MCS_scheme = mcsSet28;  		break;  	}  }  else {  	//switch (FormNodeProperties.instance.MCSSet)  	switch (MCSSetIndex) {  	case (1):  		Current_MCS_scheme = mcsMiroWaveSet1;  		break;  	case (2):  		Current_MCS_scheme = mcsMiroWaveSet2;  		break;  	case (3):  		Current_MCS_scheme = mcsMiroWaveSet3;  		break;  	case (4):  		Current_MCS_scheme = mcsMiroWaveSet4;  		break;  	default:  		Current_MCS_scheme = mcsMiroWaveSet2;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following statement contains a magic number: switch (MCSSetIndex) {  case (1):  	Current_MCS_scheme = mcsMiroWaveSet1;  	break;  case (2):  	Current_MCS_scheme = mcsMiroWaveSet2;  	break;  case (3):  	Current_MCS_scheme = mcsMiroWaveSet3;  	break;  case (4):  	Current_MCS_scheme = mcsMiroWaveSet4;  	break;  default:  	Current_MCS_scheme = mcsMiroWaveSet2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following statement contains a magic number: switch (MCSSetIndex) {  case (1):  	Current_MCS_scheme = mcsMiroWaveSet1;  	break;  case (2):  	Current_MCS_scheme = mcsMiroWaveSet2;  	break;  case (3):  	Current_MCS_scheme = mcsMiroWaveSet3;  	break;  case (4):  	Current_MCS_scheme = mcsMiroWaveSet4;  	break;  default:  	Current_MCS_scheme = mcsMiroWaveSet2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following statement contains a magic number: switch (MCSSetIndex) {  case (1):  	Current_MCS_scheme = mcsMiroWaveSet1;  	break;  case (2):  	Current_MCS_scheme = mcsMiroWaveSet2;  	break;  case (3):  	Current_MCS_scheme = mcsMiroWaveSet3;  	break;  case (4):  	Current_MCS_scheme = mcsMiroWaveSet4;  	break;  default:  	Current_MCS_scheme = mcsMiroWaveSet2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: if (BW > 30) {  	block_length = 512;  }  else {  	block_length = 256;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: if (BW > 30) {  	block_length = 512;  }  else {  	block_length = 256;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: if (BW > 30) {  	block_length = 512;  }  else {  	block_length = 256;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: block_length = 512;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: block_length = 256;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: if (AntMethod == "XPIC") {  	MIMO = 2;  }  else {  	MIMO = 1;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: MIMO = 2;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: switch (MCS_modulation) {  case "QPSK":  	bit = 2;  	break;  case "16 QAM":  	bit = 4;  	break;  case "64 QAM":  	bit = 6;  	break;  case "256 QAM":  	bit = 8;  	break;  case "1024 QAM":  	bit = 10;  	break;  default:  	bit = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: switch (MCS_modulation) {  case "QPSK":  	bit = 2;  	break;  case "16 QAM":  	bit = 4;  	break;  case "64 QAM":  	bit = 6;  	break;  case "256 QAM":  	bit = 8;  	break;  case "1024 QAM":  	bit = 10;  	break;  default:  	bit = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: switch (MCS_modulation) {  case "QPSK":  	bit = 2;  	break;  case "16 QAM":  	bit = 4;  	break;  case "64 QAM":  	bit = 6;  	break;  case "256 QAM":  	bit = 8;  	break;  case "1024 QAM":  	bit = 10;  	break;  default:  	bit = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: switch (MCS_modulation) {  case "QPSK":  	bit = 2;  	break;  case "16 QAM":  	bit = 4;  	break;  case "64 QAM":  	bit = 6;  	break;  case "256 QAM":  	bit = 8;  	break;  case "1024 QAM":  	bit = 10;  	break;  default:  	bit = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: switch (MCS_modulation) {  case "QPSK":  	bit = 2;  	break;  case "16 QAM":  	bit = 4;  	break;  case "64 QAM":  	bit = 6;  	break;  case "256 QAM":  	bit = 8;  	break;  case "1024 QAM":  	bit = 10;  	break;  default:  	bit = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: switch (MCS_modulation) {  case "QPSK":  	bit = 2;  	break;  case "16 QAM":  	bit = 4;  	break;  case "64 QAM":  	bit = 6;  	break;  case "256 QAM":  	bit = 8;  	break;  case "1024 QAM":  	bit = 10;  	break;  default:  	bit = 2;  	break;  }  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: bit = 2;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: bit = 4;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: bit = 6;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: bit = 8;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: bit = 10;  
Magic Number,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,CalcTput,The following statement contains a magic number: bit = 2;  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing CDU file {0} - {1} "' path' ex.Message);  	PcapConnection.pcap.removeListener (this);  	return false;  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: j += 4
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,MemoryDump,C:\repos\dan-sw_PTP_GUI\MemoryDump.cs,Memory_Write_File,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp Channel Gain file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp Channel Gain file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp Channel Gain file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp Channel Gain file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: j += 4
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,flushToTempFile,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,moveToMatlabFile,The following statement contains a magic number: for (int i = 0; i < 60; i++) {  	try {  		File.Delete (newPath);  	}  	catch (Exception e) {  		eSaved = e;  		System.Threading.Thread.Sleep (50);  		continue;  	}  	try {  		File.Move (path' newPath);  		return true;  	}  	catch (Exception e2) {  		// This we don't expect!  		System.Console.WriteLine ("Error writing Channel Gain file {0} - {1}"' newPath' e2.Message);  		return false;  	}  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,moveToMatlabFile,The following statement contains a magic number: for (int i = 0; i < 60; i++) {  	try {  		File.Delete (newPath);  	}  	catch (Exception e) {  		eSaved = e;  		System.Threading.Thread.Sleep (50);  		continue;  	}  	try {  		File.Move (path' newPath);  		return true;  	}  	catch (Exception e2) {  		// This we don't expect!  		System.Console.WriteLine ("Error writing Channel Gain file {0} - {1}"' newPath' e2.Message);  		return false;  	}  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,moveToMatlabFile,The following statement contains a magic number: try {  	File.Delete (newPath);  }  catch (Exception e) {  	eSaved = e;  	System.Threading.Thread.Sleep (50);  	continue;  }  
Magic Number,WindowsFormsApplication1,PhyChannelGainData,C:\repos\dan-sw_PTP_GUI\PhyChannelGainData.cs,moveToMatlabFile,The following statement contains a magic number: System.Threading.Thread.Sleep (50);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers = new ProcessMessageDelegate[8];  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers [2] = this.handleControlChannels;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers [3] = this.handlePLLPRITXAnt0;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers [4] = this.handlePLLPRITXAnt1;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers [5] = this.handleBERCounter;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers [6] = this.handleUncodedBERCounter;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,PHY,The following statement contains a magic number: handlers [7] = this.handleLinkStatistics;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleAvgCINRsAndTbCounts,The following statement contains a magic number: CINR1avg = Math.Min ((double)Math.Max (0' (double)msg.data [CINR1Avg_index])' 42);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleAvgCINRsAndTbCounts,The following statement contains a magic number: CINR2avg = Math.Min ((double)Math.Max (0' (double)msg.data [CINR2Avg_index])' 42);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: STO1 = (double)((Int16)msg.data [STO1_index]) / 512;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: STO2 = (double)((Int16)msg.data [STO2_index]) / 512;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: RSSI1 = (((double)msg.data [RSSI1_index]) / 32) - 90.5;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: RSSI1 = (((double)msg.data [RSSI1_index]) / 32) - 90.5;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [RSSI1_index]) / (double)32.0) > 256) {  	RSSI1 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [RSSI1_index]) / (double)32.0) > 256) {  	RSSI1 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: RSSI2 = (((double)msg.data [RSSI2_index]) / 32) - 90.5;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: RSSI2 = (((double)msg.data [RSSI2_index]) / 32) - 90.5;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [RSSI2_index]) / (double)32.0) > 256) {  	RSSI2 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [RSSI2_index]) / (double)32.0) > 256) {  	RSSI2 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: CINR1 = Math.Min ((((double)msg.data [CINR1_index]) / (double)32.0)' 42);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: CINR1 = Math.Min ((((double)msg.data [CINR1_index]) / (double)32.0)' 42);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [CINR1_index]) / (double)32.0) > 128) {  	CINR1 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [CINR1_index]) / (double)32.0) > 128) {  	CINR1 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: CINR2 = Math.Min ((((double)msg.data [CINR2_index]) / (double)32.0)' 42);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: CINR2 = Math.Min ((((double)msg.data [CINR2_index]) / (double)32.0)' 42);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [CINR2_index]) / (double)32.0) > 128) {  	CINR2 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: if ((((double)msg.data [CINR2_index]) / (double)32.0) > 128) {  	CINR2 = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: DC1I = (double)((msg.data [DC0_index] & 0xffff0000) >> 16);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: DC2I = (double)((msg.data [DC1_index] & 0xffff0000) >> 16);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: XPI1 = ((((double)(msg.data [XPI0_index])) - ((double)msg.data [RSSI1_index])) / 32.0);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleACKetc,The following statement contains a magic number: XPI2 = ((((double)(msg.data [XPI1_index])) - ((double)msg.data [RSSI2_index])) / 32.0);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleBERCounter,The following statement contains a magic number: BER_Good_bits_Ant0 = msg.data [Good_bits_counting1_Ant0] + ((ulong)msg.data [Good_bits_counting2_Ant0] << 32);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleBERCounter,The following statement contains a magic number: BER_Good_bits_Ant1 = msg.data [Good_bits_counting1_Ant1] + ((ulong)msg.data [Good_bits_counting2_Ant1] << 32);  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: if ((msg.data [Link_status_str] >= 0) && (msg.data [Link_status_str] <= 11)) {  	LinkStatus = msg.data [Link_status_str];  }  else {  	LinkStatus = 0;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: if ((msg.data [MCS_Set_str] >= 0) && (msg.data [MCS_Set_str] < 5)) {  	MCS_Set = msg.data [MCS_Set_str];  }  else {  	MCS_Set = 2;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: if ((msg.data [MCS_Set_str] >= 0) && (msg.data [MCS_Set_str] < 5)) {  	MCS_Set = msg.data [MCS_Set_str];  }  else {  	MCS_Set = 2;  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: MCS_Set = 2;  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: RFTypeReg = (msg.data [rf_Type_str + 3].ToString ("X") + msg.data [rf_Type_str + 2].ToString ("X") + msg.data [rf_Type_str + 1].ToString ("X") + msg.data [rf_Type_str].ToString ("X"));  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: RFTypeReg = (msg.data [rf_Type_str + 3].ToString ("X") + msg.data [rf_Type_str + 2].ToString ("X") + msg.data [rf_Type_str + 1].ToString ("X") + msg.data [rf_Type_str].ToString ("X"));  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: while (RFTypeReg.Length > 0) {  	tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  	RF_Type = RF_Type + tempRFType;  	RFTypeReg = RFTypeReg.Substring (0' RFTypeReg.Length - 2);  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: while (RFTypeReg.Length > 0) {  	tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  	RF_Type = RF_Type + tempRFType;  	RFTypeReg = RFTypeReg.Substring (0' RFTypeReg.Length - 2);  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: while (RFTypeReg.Length > 0) {  	tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  	RF_Type = RF_Type + tempRFType;  	RFTypeReg = RFTypeReg.Substring (0' RFTypeReg.Length - 2);  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: while (RFTypeReg.Length > 0) {  	tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  	RF_Type = RF_Type + tempRFType;  	RFTypeReg = RFTypeReg.Substring (0' RFTypeReg.Length - 2);  }  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: tempRFType = System.Convert.ToChar (System.Convert.ToUInt32 (RFTypeReg.Substring (RFTypeReg.Length - 2' 2)' 16)).ToString ();  
Magic Number,WindowsFormsApplication1,PHY,C:\repos\dan-sw_PTP_GUI\PHY.cs,handleLinkStatistics,The following statement contains a magic number: RFTypeReg = RFTypeReg.Substring (0' RFTypeReg.Length - 2);  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if ((GMAC0_BASE == (0xfffff000 & msg.address)) || (0xe045805 == (0xfffffff0 & msg.address))) {  	for (int i = 0; i < REG_COUNT0; i++) {  		if (msg.address == registers0 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  			CurrentCounters_GMAC0 [i] = msg.data [0];  			delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC0 [i] = 0;  			}  			return true;  		}  	}  }  else if (GMAC1_BASE == (0xfffff000 & msg.address)) {  	for (int i = 0; i < REG_COUNT1; i++) {  		if (msg.address == registers1 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  			CurrentCounters_GMAC1 [i] = msg.data [0];  			delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC1 [i] = 0;  			}  			return true;  		}  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if ((GMAC0_BASE == (0xfffff000 & msg.address)) || (0xe045805 == (0xfffffff0 & msg.address))) {  	for (int i = 0; i < REG_COUNT0; i++) {  		if (msg.address == registers0 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  			CurrentCounters_GMAC0 [i] = msg.data [0];  			delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC0 [i] = 0;  			}  			return true;  		}  	}  }  else if (GMAC1_BASE == (0xfffff000 & msg.address)) {  	for (int i = 0; i < REG_COUNT1; i++) {  		if (msg.address == registers1 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  			CurrentCounters_GMAC1 [i] = msg.data [0];  			delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC1 [i] = 0;  			}  			return true;  		}  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if ((GMAC0_BASE == (0xfffff000 & msg.address)) || (0xe045805 == (0xfffffff0 & msg.address))) {  	for (int i = 0; i < REG_COUNT0; i++) {  		if (msg.address == registers0 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  			CurrentCounters_GMAC0 [i] = msg.data [0];  			delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC0 [i] = 0;  			}  			return true;  		}  	}  }  else if (GMAC1_BASE == (0xfffff000 & msg.address)) {  	for (int i = 0; i < REG_COUNT1; i++) {  		if (msg.address == registers1 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  			CurrentCounters_GMAC1 [i] = msg.data [0];  			delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC1 [i] = 0;  			}  			return true;  		}  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if ((GMAC0_BASE == (0xfffff000 & msg.address)) || (0xe045805 == (0xfffffff0 & msg.address))) {  	for (int i = 0; i < REG_COUNT0; i++) {  		if (msg.address == registers0 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  			CurrentCounters_GMAC0 [i] = msg.data [0];  			delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC0 [i] = 0;  			}  			return true;  		}  	}  }  else if (GMAC1_BASE == (0xfffff000 & msg.address)) {  	for (int i = 0; i < REG_COUNT1; i++) {  		if (msg.address == registers1 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  			CurrentCounters_GMAC1 [i] = msg.data [0];  			delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC1 [i] = 0;  			}  			return true;  		}  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: for (int i = 0; i < REG_COUNT0; i++) {  	if (msg.address == registers0 [i]) {  		TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  		elapsedMS = elapsed.TotalMilliseconds;  		if (elapsedMS < 5) {  			// way off' so ignore this sample  			return true;  		}  		LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  		CurrentCounters_GMAC0 [i] = msg.data [0];  		delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  		if ((elapsedMS != 0) && (delta > 0)) {  			RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  		}  		else {  			RateCounters_GMAC0 [i] = 0;  		}  		return true;  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: for (int i = 0; i < REG_COUNT0; i++) {  	if (msg.address == registers0 [i]) {  		TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  		elapsedMS = elapsed.TotalMilliseconds;  		if (elapsedMS < 5) {  			// way off' so ignore this sample  			return true;  		}  		LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  		CurrentCounters_GMAC0 [i] = msg.data [0];  		delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  		if ((elapsedMS != 0) && (delta > 0)) {  			RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  		}  		else {  			RateCounters_GMAC0 [i] = 0;  		}  		return true;  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (msg.address == registers0 [i]) {  	TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  	elapsedMS = elapsed.TotalMilliseconds;  	if (elapsedMS < 5) {  		// way off' so ignore this sample  		return true;  	}  	LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  	CurrentCounters_GMAC0 [i] = msg.data [0];  	delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  	if ((elapsedMS != 0) && (delta > 0)) {  		RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  	}  	else {  		RateCounters_GMAC0 [i] = 0;  	}  	return true;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (msg.address == registers0 [i]) {  	TimeSpan elapsed = DateTime.Now - Time_GMAC0 [i];  	elapsedMS = elapsed.TotalMilliseconds;  	if (elapsedMS < 5) {  		// way off' so ignore this sample  		return true;  	}  	LastCounters_GMAC0 [i] = CurrentCounters_GMAC0 [i];  	CurrentCounters_GMAC0 [i] = msg.data [0];  	delta = CurrentCounters_GMAC0 [i] - LastCounters_GMAC0 [i];  	if ((elapsedMS != 0) && (delta > 0)) {  		RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  	}  	else {  		RateCounters_GMAC0 [i] = 0;  	}  	return true;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (elapsedMS < 5) {  	// way off' so ignore this sample  	return true;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if ((elapsedMS != 0) && (delta > 0)) {  	RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  }  else {  	RateCounters_GMAC0 [i] = 0;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: RateCounters_GMAC0 [i] = (delta / (elapsedMS / 1000));  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (GMAC1_BASE == (0xfffff000 & msg.address)) {  	for (int i = 0; i < REG_COUNT1; i++) {  		if (msg.address == registers1 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  			CurrentCounters_GMAC1 [i] = msg.data [0];  			delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC1 [i] = 0;  			}  			return true;  		}  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (GMAC1_BASE == (0xfffff000 & msg.address)) {  	for (int i = 0; i < REG_COUNT1; i++) {  		if (msg.address == registers1 [i]) {  			TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  			elapsedMS = elapsed.TotalMilliseconds;  			if (elapsedMS < 5) {  				// way off' so ignore this sample  				return true;  			}  			LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  			CurrentCounters_GMAC1 [i] = msg.data [0];  			delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  			if ((elapsedMS != 0) && (delta > 0)) {  				RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  			}  			else {  				RateCounters_GMAC1 [i] = 0;  			}  			return true;  		}  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: for (int i = 0; i < REG_COUNT1; i++) {  	if (msg.address == registers1 [i]) {  		TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  		elapsedMS = elapsed.TotalMilliseconds;  		if (elapsedMS < 5) {  			// way off' so ignore this sample  			return true;  		}  		LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  		CurrentCounters_GMAC1 [i] = msg.data [0];  		delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  		if ((elapsedMS != 0) && (delta > 0)) {  			RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  		}  		else {  			RateCounters_GMAC1 [i] = 0;  		}  		return true;  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: for (int i = 0; i < REG_COUNT1; i++) {  	if (msg.address == registers1 [i]) {  		TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  		elapsedMS = elapsed.TotalMilliseconds;  		if (elapsedMS < 5) {  			// way off' so ignore this sample  			return true;  		}  		LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  		CurrentCounters_GMAC1 [i] = msg.data [0];  		delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  		if ((elapsedMS != 0) && (delta > 0)) {  			RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  		}  		else {  			RateCounters_GMAC1 [i] = 0;  		}  		return true;  	}  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (msg.address == registers1 [i]) {  	TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  	elapsedMS = elapsed.TotalMilliseconds;  	if (elapsedMS < 5) {  		// way off' so ignore this sample  		return true;  	}  	LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  	CurrentCounters_GMAC1 [i] = msg.data [0];  	delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  	if ((elapsedMS != 0) && (delta > 0)) {  		RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  	}  	else {  		RateCounters_GMAC1 [i] = 0;  	}  	return true;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (msg.address == registers1 [i]) {  	TimeSpan elapsed = DateTime.Now - Time_GMAC1 [i];  	elapsedMS = elapsed.TotalMilliseconds;  	if (elapsedMS < 5) {  		// way off' so ignore this sample  		return true;  	}  	LastCounters_GMAC1 [i] = CurrentCounters_GMAC1 [i];  	CurrentCounters_GMAC1 [i] = msg.data [0];  	delta = CurrentCounters_GMAC1 [i] - LastCounters_GMAC1 [i];  	if ((elapsedMS != 0) && (delta > 0)) {  		RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  	}  	else {  		RateCounters_GMAC1 [i] = 0;  	}  	return true;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if (elapsedMS < 5) {  	// way off' so ignore this sample  	return true;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: if ((elapsedMS != 0) && (delta > 0)) {  	RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  }  else {  	RateCounters_GMAC1 [i] = 0;  }  
Magic Number,WindowsFormsApplication1,GMAC,C:\repos\dan-sw_PTP_GUI\GMAC.cs,MessageReplyListenerCallback,The following statement contains a magic number: RateCounters_GMAC1 [i] = (delta / (elapsedMS / 1000));  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp constellation file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp constellation file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp constellation file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: try {  	File.Delete (path);  	TextWriter tw = new StreamWriter (path);  	for (int j = 0; j < (data.Length - 3); j += 4) {  		tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  	}  	tw.Close ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Error writing temp constellation file {0} - {1} "' path' ex.Message);  	return false;  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: for (int j = 0; j < (data.Length - 3); j += 4) {  	tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: j += 4
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,flushToTempFile,The following statement contains a magic number: tw.WriteLine (" {0:x8}  {1:x8}  {2:x8}  {3:x8}  \r"' data [j]' data [j + 1]' data [j + 2]' data [j + 3]);  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,moveToMatlabFile,The following statement contains a magic number: for (int i = 0; i < 60; i++) {  	try {  		File.Delete (newPath);  	}  	catch (Exception e) {  		eSaved = e;  		System.Threading.Thread.Sleep (50);  		continue;  	}  	try {  		File.Move (path' newPath);  		return true;  	}  	catch (Exception e2) {  		// This we don't expect!  		System.Console.WriteLine ("Error writing constellation file {0} - {1}"' newPath' e2.Message);  		return false;  	}  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,moveToMatlabFile,The following statement contains a magic number: for (int i = 0; i < 60; i++) {  	try {  		File.Delete (newPath);  	}  	catch (Exception e) {  		eSaved = e;  		System.Threading.Thread.Sleep (50);  		continue;  	}  	try {  		File.Move (path' newPath);  		return true;  	}  	catch (Exception e2) {  		// This we don't expect!  		System.Console.WriteLine ("Error writing constellation file {0} - {1}"' newPath' e2.Message);  		return false;  	}  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,moveToMatlabFile,The following statement contains a magic number: try {  	File.Delete (newPath);  }  catch (Exception e) {  	eSaved = e;  	System.Threading.Thread.Sleep (50);  	continue;  }  
Magic Number,WindowsFormsApplication1,PhyConstellationData,C:\repos\dan-sw_PTP_GUI\PhyConstellationData.cs,moveToMatlabFile,The following statement contains a magic number: System.Threading.Thread.Sleep (50);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,FormSystemStatus,The following statement contains a magic number: this.comboBoxGraph1b.SelectedIndex = 7;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkConstellation_RunWorkerCompleted,The following statement contains a magic number: switch (constellationBackgroundResults) {  case Constellation.TRIGGER_RETURN_CODE.SOC_UNRESPONSIVE:  	MessageBox.Show ("Timeout fetching constellation data - the EVB has stopped responding."' "DAN PTP - Communication Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	stopConstellation ();  	return;  case Constellation.TRIGGER_RETURN_CODE.EXECUTABLE_FAILURE:  	MessageBox.Show ("The Matlab process failed to start"' "DAN PTP - Process Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	stopConstellation ();  	return;  case Constellation.TRIGGER_RETURN_CODE.FILE_WRITE_FAILURE:  	MessageBox.Show ("Error writing constellation files for the Matlab process"' "DAN PTP - File Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	stopConstellation ();  	return;  default:  	// TRIGGER_RETURN_CODE_OK  	if (constellation == null) {  		// Usually not needed; this is a typical exit from charting mode.  		stopConstellation ();  		return;  		// ends  	}  	// Restart the task' specifying a certain delay.  (Deduct the time  	// spent waiting for responses from SOC and filesystem I/O)  	int delayDuration = (ConstellationUpdateIntervalSec * 1000) - (int)constellationStopwatch.ElapsedMilliseconds;  	if (delayDuration < 0) {  		delayDuration = 1;  	}  	// already used up our time  	// Restart the task (bgWrkConstellation is not 'busy')  	bgWrkConstellation.RunWorkerAsync (delayDuration);  	break;  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (KeepAliveEnable) {  		if (keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  			// looking for heartbeat resume  			if (PHY.phy.RxNumFrameIndsDelta > 0 && PHY.phy.TxNumFrameIndsDelta > 0) {  				// reset  				keepAliveFailure = 0;  				string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationRegain;  				MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  				EVB_Connection_up = true;  			}  		}  		else {  			if (PHY.phy.RxNumFrameIndsDelta == 0 || PHY.phy.TxNumFrameIndsDelta == 0) {  				if (++keepAliveFailure > KEEP_ALIVE_FAILURE_THRESHOLD) {  					// Notify user  					string msg = global::WindowsFormsApplication1.Properties.Resources.HeartbeatNotificationError;  					MessageBox.Show (msg' "DAN PTP Heartbeat Notification"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  					EVB_Connection_up = false;  				}  			}  			else {  				// One good heartbeat resets the counter  				keepAliveFailure = 0;  			}  		}  	}  	if (EVB_Connection_up) {  		// Link Status  		//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		else {  			this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  		}  		this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  		// GMACs  		updateGroupboxLabels ();  		decimal rate;  		if (comboBoxGraph1a.SelectedIndex == 0) {  			rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  		}  		else {  			rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  		}  		this.spPerfChart0.AddValue (rate);  		this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  		this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		// Repeat for Graph1:  		if (comboBoxGraph0a.SelectedIndex == 0) {  			rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  		}  		else {  			rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  		}  		//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  		this.spPerfChart1.AddValue (rate);  		this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  		this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  		///  RSSI Graph - range {-40..0}  		///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  			}  			else {  				if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  				}  				else {  					this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  				}  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  		}  		this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  		this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  		/// CINR  -  range {0..50}  		try {  			decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  			}  			else {  				this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  		}  		this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  		this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  		/// PER  -  % {0..100}                      		decimal nack = (decimal)PHY.phy.NACK0;  		decimal ack = (decimal)PHY.phy.ACK0;  		decimal nackB = (decimal)PHY.phy.NACK1;  		decimal ackB = (decimal)PHY.phy.ACK1;  		decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  		decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  		try {  			if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  				this.spPerfChartPER.AddValues (val * 100' val * 100);  			}  			else {  				this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  			}  		}  		catch (Exception) {  			Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  		}  		this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  		this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  		this.labelGraphPER0Nack.Text = nack.ToString ();  		this.labelGraphPER1Nack.Text = nackB.ToString ();  		/// AMC-Averaged CINR  		// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  		MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  		// Valid values are enforced by AMC  		if (PHY.phy.controlChannelTx == null) {  			// may happen when PHY hasn't received a handleControlChannels  			// message yet  			Console.WriteLine ("null controlChannelTx...");  		}  		else {  			//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  			uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  			uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  			// Scale to 100  			try {  				// Scale based on number of defined modulations  				decimal scale = (100.0m / MCS.getMaxMCS ());  				decimal up_graph_offset = (decimal)-0.5;  				// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  				// Note that this chart is in absolute mode.  				decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  				// current size of Chart  				this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  				this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  			}  			catch (Exception) {  				Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  			}  			if (AMC.amc.AutoAMC) {  				this.labelMcsAuto.Text = "Auto";  				this.labelMcsManualSetting.Text = "";  			}  			else {  				this.labelMcsAuto.Text = "Manual:";  				// Note that current SOC uses antenna zero for both; but stores 2 values                              				uint specifiedMcs = AMC.amc.McsManualId0;  				try {  					this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  				}  				catch (Exception ex2) {  					Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  				}  			}  		}  		if (PHY.phy.controlChannelRx != null) {  			uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  			// Requested Rx Modulation  			uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  			//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  			//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  			labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  		}  		// Heartbeat monitor   		//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   		// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  		//  If the delta is zero' either this is the first (unlikely) sample  		// or something is stuck in MMC.  If delta is zero three times in a row'  		// show a message.  		//  Once the message is shown' doesn't show it again until things have  		// been corrected (heartbeat resumes.)  		// Restart' will no-op if pauseFormUpdates      		this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  		this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  		if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  			this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  			this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  		}  	}  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		labelGraphRSSI1Current.Visible = false;  		radioButtonRSSI2.Visible = false;  		labelGraphCINR1Current.Visible = false;  		radioButtonCINR2.Visible = false;  		labelGraphPER1Current.Visible = false;  		labelGraphPER1Nack.Visible = false;  		radioButtonPER2.Visible = false;  	}  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		groupBoxXPI.Visible = true;  	}  	if (FormNodeProperties.instance.LOGS_Enable) {  		FormNodeProperties.instance.Save_Log_To_Files ();  	}  	//if (chkBxTimerEnabled.Checked)  	//{  	//    RunTimer();  	//}  	RunTimer ();  }  catch (Exception ex) {  	System.Console.WriteLine ("Exception {0}"' ex.Message);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (EVB_Connection_up) {  	// Link Status  	//    this.panelLinkSync.BackColor = (LinkIndicator.links.SyncAchieved ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTimingLoop.BackColor = (LinkIndicator.links.TimingLoopOK ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	this.panelLinkTxOn.BackColor = (LinkIndicator.links.TxOn ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.panelLinkPllLock.BackColor = (LinkIndicator.links.PllLockAnt0 ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	else {  		this.panelLinkPllLock.BackColor = ((LinkIndicator.links.PllLockAnt0 & LinkIndicator.links.PllLockAnt1) ? System.Drawing.Color.LightGreen : System.Drawing.Color.Yellow);  	}  	this.labelLinkStatus.Text = FormNodeProperties.instance.linkstatus;  	// GMACs  	updateGroupboxLabels ();  	decimal rate;  	if (comboBoxGraph1a.SelectedIndex == 0) {  		rate = (decimal)gmacLeft.rateCounter_GMAC0 (gmacLeftSelection);  	}  	else {  		rate = (decimal)gmacLeft.rateCounter_GMAC1 (gmacLeftSelection);  	}  	this.spPerfChart0.AddValue (rate);  	this.labelGraph0Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart0.MaxValue);  	this.labelGraph0Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	// Repeat for Graph1:  	if (comboBoxGraph0a.SelectedIndex == 0) {  		rate = (decimal)gmacRight.rateCounter_GMAC0 (gmacRightSelection);  	}  	else {  		rate = (decimal)gmacRight.rateCounter_GMAC1 (gmacRightSelection);  	}  	//   rate = (decimal)gmacRight.rateCounter(gmacRightSelection);  	this.spPerfChart1.AddValue (rate);  	this.labelGraph1Max.Text = String.Format ("Max:  {0:0'0} f/s"' spPerfChart1.MaxValue);  	this.labelGraph1Latest.Text = String.Format ("{0:0'0.0} f/s"' rate);  	///  RSSI Graph - range {-40..0}  	///  (Since graphs don't support neg numbers' for now just chart abs(x) i.e' -1x)  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI1);  		}  		else {  			if ((PHY.phy.RSSI1 == 0) && (PHY.phy.RSSI2 == 0)) {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2);  			}  			else {  				this.spPerfChartRSSI.AddValues ((decimal)-PHY.phy.RSSI1' (decimal)-PHY.phy.RSSI2 + 1);  			}  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to RSSI"' -PHY.phy.RSSI1' -PHY.phy.RSSI2);  	}  	this.labelGraphRSSI0Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI1);  	this.labelGraphRSSI1Current.Text = String.Format (" {0:0.0} dBFS"' PHY.phy.RSSI2);  	/// CINR  -  range {0..50}  	try {  		decimal CINR_scale = 100.0m / (decimal)PHY.phy.CINR_Max;  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR1) * CINR_scale);  		}  		else {  			this.spPerfChartCINR.AddValues (((decimal)PHY.phy.CINR1) * CINR_scale' ((decimal)PHY.phy.CINR2) * CINR_scale + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to CINR"' PHY.phy.CINR1' PHY.phy.CINR2);  	}  	this.labelGraphCINR0Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR1);  	this.labelGraphCINR1Current.Text = String.Format (" {0:0.00} dB"' PHY.phy.CINR2);  	/// PER  -  % {0..100}                      	decimal nack = (decimal)PHY.phy.NACK0;  	decimal ack = (decimal)PHY.phy.ACK0;  	decimal nackB = (decimal)PHY.phy.NACK1;  	decimal ackB = (decimal)PHY.phy.ACK1;  	decimal val = ((ack + nack) == 0) ? 0m : nack / (ack + nack);  	decimal valB = ((ackB + nackB) == 0) ? 0m : nackB / (ackB + nackB);  	try {  		if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  			this.spPerfChartPER.AddValues (val * 100' val * 100);  		}  		else {  			this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  		}  	}  	catch (Exception) {  		Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  	}  	this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  	this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  	this.labelGraphPER0Nack.Text = nack.ToString ();  	this.labelGraphPER1Nack.Text = nackB.ToString ();  	/// AMC-Averaged CINR  	// TODO: Get bandwidth from somewhere... right now' looks like a SOC build #define  	MCS.BANDWIDTH bw = MCS.BANDWIDTH.MHZ80;  	// Valid values are enforced by AMC  	if (PHY.phy.controlChannelTx == null) {  		// may happen when PHY hasn't received a handleControlChannels  		// message yet  		Console.WriteLine ("null controlChannelTx...");  	}  	else {  		//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  		uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  		uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  		// Scale to 100  		try {  			// Scale based on number of defined modulations  			decimal scale = (100.0m / MCS.getMaxMCS ());  			decimal up_graph_offset = (decimal)-0.5;  			// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  			// Note that this chart is in absolute mode.  			decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  			// current size of Chart  			this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  			this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  		}  		catch (Exception) {  			Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  		}  		if (AMC.amc.AutoAMC) {  			this.labelMcsAuto.Text = "Auto";  			this.labelMcsManualSetting.Text = "";  		}  		else {  			this.labelMcsAuto.Text = "Manual:";  			// Note that current SOC uses antenna zero for both; but stores 2 values                              			uint specifiedMcs = AMC.amc.McsManualId0;  			try {  				this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  			}  			catch (Exception ex2) {  				Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  			}  		}  	}  	if (PHY.phy.controlChannelRx != null) {  		uint txAnnouncedMCS = this.radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelRx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2;  		// Requested Rx Modulation  		uint rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended1;  		//                        textBoxReqRxMod0.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		rxRequestedMcs = PHY.phy.controlChannelRx.rxRecommended2;  		//                        textBoxReqRxMod1.Text = String.Format("{0} ({1})"' rxRequestedMcs' MCS.getMCS(bw' rxRequestedMcs).modulation);  		labelMcsLatest.Text = String.Format ("{0} - {1}"' txAnnouncedMCS' MCS.getMCS (bw' txAnnouncedMCS).ToString ());  	}  	// Heartbeat monitor   	//  See PHY property RxNumFrameIndsDelta' which uses mmc_num_rx_frame_inds   	// for heartbeat (and TxNumFrameIndsDelta which uses mmc_num_tx_frame_inds.)  	//  If the delta is zero' either this is the first (unlikely) sample  	// or something is stuck in MMC.  If delta is zero three times in a row'  	// show a message.  	//  Once the message is shown' doesn't show it again until things have  	// been corrected (heartbeat resumes.)  	// Restart' will no-op if pauseFormUpdates      	this.textBoxSTO1.Text = String.Format (" {0:0.0}"' PHY.phy.STO1);  	this.textBoxSTO2.Text = String.Format (" {0:0.0}"' PHY.phy.STO2);  	if (FormNodeProperties.instance.SisoMimoMode == "XPIC(MIMO)") {  		this.textBoxXPIAnt0.Text = String.Format (" {0:0.0}"' PHY.phy.XPI1);  		this.textBoxXPIAnt1.Text = String.Format (" {0:0.0}"' PHY.phy.XPI2);  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.spPerfChartPER.AddValues (val * 100' val * 100);  	}  	else {  		this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  	}  }  catch (Exception) {  	Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.spPerfChartPER.AddValues (val * 100' val * 100);  	}  	else {  		this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  	}  }  catch (Exception) {  	Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.spPerfChartPER.AddValues (val * 100' val * 100);  	}  	else {  		this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  	}  }  catch (Exception) {  	Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.spPerfChartPER.AddValues (val * 100' val * 100);  	}  	else {  		this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  	}  }  catch (Exception) {  	Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.spPerfChartPER.AddValues (val * 100' val * 100);  	}  	else {  		this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  	}  }  catch (Exception) {  	Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  		this.spPerfChartPER.AddValues (val * 100' val * 100);  	}  	else {  		this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  	}  }  catch (Exception) {  	Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  	this.spPerfChartPER.AddValues (val * 100' val * 100);  }  else {  	this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  	this.spPerfChartPER.AddValues (val * 100' val * 100);  }  else {  	this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  	this.spPerfChartPER.AddValues (val * 100' val * 100);  }  else {  	this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (FormNodeProperties.instance.SisoMimoMode == "Single SISO") {  	this.spPerfChartPER.AddValues (val * 100' val * 100);  }  else {  	this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: this.spPerfChartPER.AddValues (val * 100' val * 100);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: this.spPerfChartPER.AddValues (val * 100' val * 100);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: this.spPerfChartPER.AddValues (val * 100' valB * 100 + 1);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: Console.WriteLine ("Error adding values {0} & {1} to PER"' val * 1000' valB * 1000);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: this.labelGraphPER0Current.Text = String.Format (" {0:0.0} %"' val * 100);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: this.labelGraphPER1Current.Text = String.Format (" {0:0.0} %"' valB * 100);  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: if (PHY.phy.controlChannelTx == null) {  	// may happen when PHY hasn't received a handleControlChannels  	// message yet  	Console.WriteLine ("null controlChannelTx...");  }  else {  	//uint mcsCurrent = (radioButtonMCSAnt1.Checked ? PHY.phy.controlChannelTx.txAnnounced1 : PHY.phy.controlChannelTx.txAnnounced2);  	uint mcsCurrent = PHY.phy.controlChannelRx.txAnnounced1;  	uint mcsCurrentB = PHY.phy.controlChannelTx.txAnnounced2;  	// Scale to 100  	try {  		// Scale based on number of defined modulations  		decimal scale = (100.0m / MCS.getMaxMCS ());  		decimal up_graph_offset = (decimal)-0.5;  		// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  		// Note that this chart is in absolute mode.  		decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  		// current size of Chart  		this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  		this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  	}  	catch (Exception) {  		Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  	}  	if (AMC.amc.AutoAMC) {  		this.labelMcsAuto.Text = "Auto";  		this.labelMcsManualSetting.Text = "";  	}  	else {  		this.labelMcsAuto.Text = "Manual:";  		// Note that current SOC uses antenna zero for both; but stores 2 values                              		uint specifiedMcs = AMC.amc.McsManualId0;  		try {  			this.labelMcsManualSetting.Text = MCS.getMCS (bw' specifiedMcs).ToString ();  		}  		catch (Exception ex2) {  			Console.WriteLine ("Exception setting labelMcsManualSetting from MCS value {0} - {1}"' specifiedMcs' ex2.Message);  		}  	}  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,bgWrkTimer_RunWorkerCompleted,The following statement contains a magic number: try {  	// Scale based on number of defined modulations  	decimal scale = (100.0m / MCS.getMaxMCS ());  	decimal up_graph_offset = (decimal)-0.5;  	// Multiply to scale {0..8} -> {0..100}' but then add 1/2 Grid_Y_' so they line up with the labels  	// Note that this chart is in absolute mode.  	decimal halfGridY = spPerfChartMCS.Grid_Y_Spacing / 2m;  	// current size of Chart  	this.spPerfChartMCS.AddValues ((mcsCurrent * scale) + up_graph_offset' (mcsCurrentB * scale) + up_graph_offset - 1);  	this.labelMcsLatest.Text = String.Format ("{0} ({1})"' mcsCurrent' MCS.getMCS (bw' mcsCurrent).ToString ());  }  catch (Exception) {  	Console.WriteLine ("Error adding value {0} to MCS chart' or getting display string"' mcsCurrent);  }  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonRSSI1_CheckedChanged,The following statement contains a magic number: spPerfChartRSSI.PerfChartStyle.ChartLinePen.Width = (radioButtonRSSI1.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonRSSI1_CheckedChanged,The following statement contains a magic number: spPerfChartRSSI.PerfChartStyle.ChartLinePen.Width = (radioButtonRSSI1.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonRSSI2_CheckedChanged,The following statement contains a magic number: spPerfChartRSSI.PerfChartStyle.ChartLinePenB.Width = (radioButtonRSSI2.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonRSSI2_CheckedChanged,The following statement contains a magic number: spPerfChartRSSI.PerfChartStyle.ChartLinePenB.Width = (radioButtonRSSI2.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonCINR1_CheckedChanged,The following statement contains a magic number: spPerfChartCINR.PerfChartStyle.ChartLinePen.Width = (radioButtonCINR1.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonCINR1_CheckedChanged,The following statement contains a magic number: spPerfChartCINR.PerfChartStyle.ChartLinePen.Width = (radioButtonCINR1.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonCINR2_CheckedChanged,The following statement contains a magic number: spPerfChartCINR.PerfChartStyle.ChartLinePenB.Width = (radioButtonCINR2.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonCINR2_CheckedChanged,The following statement contains a magic number: spPerfChartCINR.PerfChartStyle.ChartLinePenB.Width = (radioButtonCINR2.Checked) ? 3 : 2;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonPER1_CheckedChanged,The following statement contains a magic number: spPerfChartPER.PerfChartStyle.ChartLinePen.Width = (radioButtonPER1.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonPER1_CheckedChanged,The following statement contains a magic number: spPerfChartPER.PerfChartStyle.ChartLinePenB.Width = (radioButtonPER2.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonPER2_CheckedChanged,The following statement contains a magic number: spPerfChartPER.PerfChartStyle.ChartLinePen.Width = (radioButtonPER1.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonPER2_CheckedChanged,The following statement contains a magic number: spPerfChartPER.PerfChartStyle.ChartLinePenB.Width = (radioButtonPER2.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonMCSrx_CheckedChanged,The following statement contains a magic number: spPerfChartMCS.PerfChartStyle.ChartLinePen.Width = (radioButtonMCSAnt1.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonMCSrx_CheckedChanged,The following statement contains a magic number: spPerfChartMCS.PerfChartStyle.ChartLinePenB.Width = (radioButtonMCSAnt2.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonMCStx_CheckedChanged,The following statement contains a magic number: spPerfChartMCS.PerfChartStyle.ChartLinePen.Width = (radioButtonMCSAnt1.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,FormSystemStatus,C:\repos\dan-sw_PTP_GUI\FormSystemStatus.cs,radioButtonMCStx_CheckedChanged,The following statement contains a magic number: spPerfChartMCS.PerfChartStyle.ChartLinePenB.Width = (radioButtonMCSAnt2.Checked) ? 3 : 1;  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,unmarshal,The following statement contains a magic number: if (rv.msgType == (byte)MSG_TYPE.RSP_READ || // "OneWord Read" response  rv.msgType == (byte)MSG_TYPE.RSP_READ_ARRAY)// "Block Read" response   {  	// Data payload is an array of uint32 (memory words from the SOC at address)  	int offsetOfDanData = DAN_MSG_DAT_OFFSET_WITHIN_RAW_PACKET;  	// special case - zero length -> 256   	int dataWords = rv.size == 0 ? 256 : rv.size;  	rv.data = new UInt32[dataWords];  	for (int i = 0; i < dataWords; i++) {  		rv.data [i] = BitConverter.ToUInt32 (bytes' offsetOfDanData);  		offsetOfDanData += 4;  	}  }  else {  	// todo: Ignore (by filter) packets coming from me (requests)  	Console.WriteLine (" Ignoring DAN message type = " + rv.msgType);  }  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,unmarshal,The following statement contains a magic number: if (rv.msgType == (byte)MSG_TYPE.RSP_READ || // "OneWord Read" response  rv.msgType == (byte)MSG_TYPE.RSP_READ_ARRAY)// "Block Read" response   {  	// Data payload is an array of uint32 (memory words from the SOC at address)  	int offsetOfDanData = DAN_MSG_DAT_OFFSET_WITHIN_RAW_PACKET;  	// special case - zero length -> 256   	int dataWords = rv.size == 0 ? 256 : rv.size;  	rv.data = new UInt32[dataWords];  	for (int i = 0; i < dataWords; i++) {  		rv.data [i] = BitConverter.ToUInt32 (bytes' offsetOfDanData);  		offsetOfDanData += 4;  	}  }  else {  	// todo: Ignore (by filter) packets coming from me (requests)  	Console.WriteLine (" Ignoring DAN message type = " + rv.msgType);  }  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,unmarshal,The following statement contains a magic number: for (int i = 0; i < dataWords; i++) {  	rv.data [i] = BitConverter.ToUInt32 (bytes' offsetOfDanData);  	offsetOfDanData += 4;  }  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,unmarshal,The following statement contains a magic number: offsetOfDanData += 4;  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,marshal,The following statement contains a magic number: if (msgType == (byte)MSG_TYPE.CMD_WRITE32) {  	System.Diagnostics.Debug.Assert (data != null && data.Length == 1);  	sizeNeeded += 4;  	// sizeof(UInt32)  }  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,marshal,The following statement contains a magic number: sizeNeeded += 4;  
Magic Number,WindowsFormsApplication1,DAN_gui_msg,C:\repos\dan-sw_PTP_GUI\DAN_gui_msg.cs,marshal,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (seq)' 0' rv' DAN_MSG_SEQ_OFFSET' 2);  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: try {  	device.Open (DeviceMode.Normal' 1500);  	// 1.5 sec timeout  	// Set a filter for DAN GUI mgmt type messages  	string myMac = device.MacAddress.ToString ();  	myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  	string filter = "ip and ip[0]==21 and not ether src " + myMac;  	device.Filter = filter;  	// Even though this protocol works fine without IP addresses' they  	// are added to the IP packet.  It may help with debugging via Wireshark'  	// and may be needed for other capabilities' such as TFTP.   	// pcap.sendDanMsg() expects them in ipSrcAddr and ipDestAddr  	string[] parsedDevDescr = parseDeviceDescription (device);  	ipSrcAddr = System.Net.IPAddress.Parse (parsedDevDescr [0]);  	// IP dotted notation  	ipDestAddr = System.Net.IPAddress.Parse ("192.168.1.10");  	// default EVB addr  	ethDstAddr = PhysicalAddress.Parse (targetMAC);  	// "02-DE-AD-BE-EF-03");  	// Send a test message  	{  		//uint BaseaddressGMAC1 = 0xE577E000;  		//uint RxBcastFramesRecdOffset = 0x18c;  		UInt32 PHYbase = 0xe0458000;  		byte len = 8;  		//UInt32 PHYdata = 0xd0000000; byte len = 0;  		uint register = PHYbase;  		//BaseaddressGMAC1 + RxBcastFramesRecdOffset;  		//Console.WriteLine("Requesting counter Gmac1.rxBroadcastFramesRecd at {0}"' register.ToString("X2"));  		// TESTING!!  		//DAN_read_msg msg = new DAN_read_msg(register);  		DAN_read_array_msg msg = new DAN_read_array_msg (register' len);  		// 0 -> 256  		DAN_gui_msg responseMsg = null;  		pcap.sendDanMsg (msg);  		for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  			// due to capture filter not filtering out my own packets... repeat  			SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  			responseMsg = pcap.parsePacket (rawCapture);  			if (responseMsg != null) {  				int msgSize = msg.size == 0 ? 256 : msg.size;  				Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  				for (int i = 0; i < msgSize; i += 4) {  					Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  				}  				rv = true;  				break;  			}  		}  		return rv;  	}  }  catch (Exception e) {  	Console.WriteLine ("Error opening device: " + e.Message);  	stopDevice ();  	// clears property 'device'  	return rv;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: device.Open (DeviceMode.Normal' 1500);  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: myMac = myMac.Insert (10' ":").Insert (8' ":").Insert (6' ":").Insert (4' ":").Insert (2' ":");  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  	// due to capture filter not filtering out my own packets... repeat  	SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  	responseMsg = pcap.parsePacket (rawCapture);  	if (responseMsg != null) {  		int msgSize = msg.size == 0 ? 256 : msg.size;  		Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  		for (int i = 0; i < msgSize; i += 4) {  			Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  		}  		rv = true;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  	// due to capture filter not filtering out my own packets... repeat  	SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  	responseMsg = pcap.parsePacket (rawCapture);  	if (responseMsg != null) {  		int msgSize = msg.size == 0 ? 256 : msg.size;  		Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  		for (int i = 0; i < msgSize; i += 4) {  			Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  		}  		rv = true;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  	// due to capture filter not filtering out my own packets... repeat  	SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  	responseMsg = pcap.parsePacket (rawCapture);  	if (responseMsg != null) {  		int msgSize = msg.size == 0 ? 256 : msg.size;  		Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  		for (int i = 0; i < msgSize; i += 4) {  			Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  		}  		rv = true;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  	// due to capture filter not filtering out my own packets... repeat  	SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  	responseMsg = pcap.parsePacket (rawCapture);  	if (responseMsg != null) {  		int msgSize = msg.size == 0 ? 256 : msg.size;  		Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  		for (int i = 0; i < msgSize; i += 4) {  			Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  		}  		rv = true;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int loopCounter = 0; loopCounter < 3; loopCounter++) {  	// due to capture filter not filtering out my own packets... repeat  	SharpPcap.RawCapture rawCapture = pcap.device.GetNextPacket ();  	responseMsg = pcap.parsePacket (rawCapture);  	if (responseMsg != null) {  		int msgSize = msg.size == 0 ? 256 : msg.size;  		Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  		for (int i = 0; i < msgSize; i += 4) {  			Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  		}  		rv = true;  		break;  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: if (responseMsg != null) {  	int msgSize = msg.size == 0 ? 256 : msg.size;  	Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  	for (int i = 0; i < msgSize; i += 4) {  		Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  	}  	rv = true;  	break;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: if (responseMsg != null) {  	int msgSize = msg.size == 0 ? 256 : msg.size;  	Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  	for (int i = 0; i < msgSize; i += 4) {  		Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  	}  	rv = true;  	break;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: if (responseMsg != null) {  	int msgSize = msg.size == 0 ? 256 : msg.size;  	Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  	for (int i = 0; i < msgSize; i += 4) {  		Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  	}  	rv = true;  	break;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: if (responseMsg != null) {  	int msgSize = msg.size == 0 ? 256 : msg.size;  	Console.WriteLine ("Requested {1} 32-bit words at {0}"' msg.address.ToString ("X8")' msgSize);  	for (int i = 0; i < msgSize; i += 4) {  		Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  	}  	rv = true;  	break;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int i = 0; i < msgSize; i += 4) {  	Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int i = 0; i < msgSize; i += 4) {  	Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: for (int i = 0; i < msgSize; i += 4) {  	Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: i += 4
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,connect,The following statement contains a magic number: Console.WriteLine ("{0:x8} {1:x8} {2:x8} {3:x8} "' responseMsg.data [i]' responseMsg.data [i + 1]' responseMsg.data [i + 2]' responseMsg.data [i + 3]);  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parsePacket,The following statement contains a magic number: if (packet.Data [12] == 8 && packet.Data [13] == 0 && packet.Data [14] == 0x15 && (packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET] >= (byte)DAN_gui_msg.MSG_TYPE.RSP_READ)) {  	ByteArraySegment bas = new ByteArraySegment (packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (packet.Data);  	//responseMessage.print();  	return responseMessage;  }  else {  	return null;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parsePacket,The following statement contains a magic number: if (packet.Data [12] == 8 && packet.Data [13] == 0 && packet.Data [14] == 0x15 && (packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET] >= (byte)DAN_gui_msg.MSG_TYPE.RSP_READ)) {  	ByteArraySegment bas = new ByteArraySegment (packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (packet.Data);  	//responseMessage.print();  	return responseMessage;  }  else {  	return null;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parsePacket,The following statement contains a magic number: if (packet.Data [12] == 8 && packet.Data [13] == 0 && packet.Data [14] == 0x15 && (packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET] >= (byte)DAN_gui_msg.MSG_TYPE.RSP_READ)) {  	ByteArraySegment bas = new ByteArraySegment (packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (packet.Data);  	//responseMessage.print();  	return responseMessage;  }  else {  	return null;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parsePacket,The following statement contains a magic number: if (packet.Data [12] == 8 && packet.Data [13] == 0 && packet.Data [14] == 0x15 && (packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET] >= (byte)DAN_gui_msg.MSG_TYPE.RSP_READ)) {  	ByteArraySegment bas = new ByteArraySegment (packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (packet.Data);  	//responseMessage.print();  	return responseMessage;  }  else {  	return null;  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH   {  	// Quietly ignore packets that were generated by this machine - requests  	byte cmd = captureEventArgs.Packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET];  	if (cmd < (byte)DAN_gui_msg.MSG_TYPE.RSP_READ) {  		// Ignore DAN request messages.  Should never come thru here' if  		// the packet filter is working as intended.  		return;  	}  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	//int len = captureEventArgs.Packet.Data.Length;  	//Console.WriteLine("{0}:{1}:{2}'{3} Len={4}  type = {5}"'  	//    time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	if (ethType != LinkLayers.Ethernet) {  		Console.WriteLine ("Unexpected ethType {0}' ignored!"' ethType);  		return;  	}  	ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (captureEventArgs.Packet.Data);  	//responseMessage.print();  	System.Diagnostics.Stopwatch st = new System.Diagnostics.Stopwatch ();  	st.Start ();  	// The listeners may remove themselves during the callback.  To avoid  	// concurrentModificationException' use a duplicate of the collection  	// for iteration  	List<MessageReplyListener> listenersCopy = new List<MessageReplyListener> (pcap.listeners);  	MessageReplyListener lastListener = null;  	foreach (MessageReplyListener l in listenersCopy) {  		lastListener = l;  		st.Restart ();  		if (l.MessageReplyListenerCallback (responseMessage' time)) {  			break;  			//was handled  		}  		if (st.ElapsedMilliseconds > 20) {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  		}  	}  	if (st.ElapsedMilliseconds > 20) {  		if (lastListener == null) {  			System.Console.WriteLine ("This is weird");  		}  		else {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  		}  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH   {  	// Quietly ignore packets that were generated by this machine - requests  	byte cmd = captureEventArgs.Packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET];  	if (cmd < (byte)DAN_gui_msg.MSG_TYPE.RSP_READ) {  		// Ignore DAN request messages.  Should never come thru here' if  		// the packet filter is working as intended.  		return;  	}  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	//int len = captureEventArgs.Packet.Data.Length;  	//Console.WriteLine("{0}:{1}:{2}'{3} Len={4}  type = {5}"'  	//    time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	if (ethType != LinkLayers.Ethernet) {  		Console.WriteLine ("Unexpected ethType {0}' ignored!"' ethType);  		return;  	}  	ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (captureEventArgs.Packet.Data);  	//responseMessage.print();  	System.Diagnostics.Stopwatch st = new System.Diagnostics.Stopwatch ();  	st.Start ();  	// The listeners may remove themselves during the callback.  To avoid  	// concurrentModificationException' use a duplicate of the collection  	// for iteration  	List<MessageReplyListener> listenersCopy = new List<MessageReplyListener> (pcap.listeners);  	MessageReplyListener lastListener = null;  	foreach (MessageReplyListener l in listenersCopy) {  		lastListener = l;  		st.Restart ();  		if (l.MessageReplyListenerCallback (responseMessage' time)) {  			break;  			//was handled  		}  		if (st.ElapsedMilliseconds > 20) {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  		}  	}  	if (st.ElapsedMilliseconds > 20) {  		if (lastListener == null) {  			System.Console.WriteLine ("This is weird");  		}  		else {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  		}  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH   {  	// Quietly ignore packets that were generated by this machine - requests  	byte cmd = captureEventArgs.Packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET];  	if (cmd < (byte)DAN_gui_msg.MSG_TYPE.RSP_READ) {  		// Ignore DAN request messages.  Should never come thru here' if  		// the packet filter is working as intended.  		return;  	}  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	//int len = captureEventArgs.Packet.Data.Length;  	//Console.WriteLine("{0}:{1}:{2}'{3} Len={4}  type = {5}"'  	//    time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	if (ethType != LinkLayers.Ethernet) {  		Console.WriteLine ("Unexpected ethType {0}' ignored!"' ethType);  		return;  	}  	ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (captureEventArgs.Packet.Data);  	//responseMessage.print();  	System.Diagnostics.Stopwatch st = new System.Diagnostics.Stopwatch ();  	st.Start ();  	// The listeners may remove themselves during the callback.  To avoid  	// concurrentModificationException' use a duplicate of the collection  	// for iteration  	List<MessageReplyListener> listenersCopy = new List<MessageReplyListener> (pcap.listeners);  	MessageReplyListener lastListener = null;  	foreach (MessageReplyListener l in listenersCopy) {  		lastListener = l;  		st.Restart ();  		if (l.MessageReplyListenerCallback (responseMessage' time)) {  			break;  			//was handled  		}  		if (st.ElapsedMilliseconds > 20) {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  		}  	}  	if (st.ElapsedMilliseconds > 20) {  		if (lastListener == null) {  			System.Console.WriteLine ("This is weird");  		}  		else {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  		}  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH   {  	// Quietly ignore packets that were generated by this machine - requests  	byte cmd = captureEventArgs.Packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET];  	if (cmd < (byte)DAN_gui_msg.MSG_TYPE.RSP_READ) {  		// Ignore DAN request messages.  Should never come thru here' if  		// the packet filter is working as intended.  		return;  	}  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	//int len = captureEventArgs.Packet.Data.Length;  	//Console.WriteLine("{0}:{1}:{2}'{3} Len={4}  type = {5}"'  	//    time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	if (ethType != LinkLayers.Ethernet) {  		Console.WriteLine ("Unexpected ethType {0}' ignored!"' ethType);  		return;  	}  	ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (captureEventArgs.Packet.Data);  	//responseMessage.print();  	System.Diagnostics.Stopwatch st = new System.Diagnostics.Stopwatch ();  	st.Start ();  	// The listeners may remove themselves during the callback.  To avoid  	// concurrentModificationException' use a duplicate of the collection  	// for iteration  	List<MessageReplyListener> listenersCopy = new List<MessageReplyListener> (pcap.listeners);  	MessageReplyListener lastListener = null;  	foreach (MessageReplyListener l in listenersCopy) {  		lastListener = l;  		st.Restart ();  		if (l.MessageReplyListenerCallback (responseMessage' time)) {  			break;  			//was handled  		}  		if (st.ElapsedMilliseconds > 20) {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  		}  	}  	if (st.ElapsedMilliseconds > 20) {  		if (lastListener == null) {  			System.Console.WriteLine ("This is weird");  		}  		else {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  		}  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH   {  	// Quietly ignore packets that were generated by this machine - requests  	byte cmd = captureEventArgs.Packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET];  	if (cmd < (byte)DAN_gui_msg.MSG_TYPE.RSP_READ) {  		// Ignore DAN request messages.  Should never come thru here' if  		// the packet filter is working as intended.  		return;  	}  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	//int len = captureEventArgs.Packet.Data.Length;  	//Console.WriteLine("{0}:{1}:{2}'{3} Len={4}  type = {5}"'  	//    time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	if (ethType != LinkLayers.Ethernet) {  		Console.WriteLine ("Unexpected ethType {0}' ignored!"' ethType);  		return;  	}  	ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (captureEventArgs.Packet.Data);  	//responseMessage.print();  	System.Diagnostics.Stopwatch st = new System.Diagnostics.Stopwatch ();  	st.Start ();  	// The listeners may remove themselves during the callback.  To avoid  	// concurrentModificationException' use a duplicate of the collection  	// for iteration  	List<MessageReplyListener> listenersCopy = new List<MessageReplyListener> (pcap.listeners);  	MessageReplyListener lastListener = null;  	foreach (MessageReplyListener l in listenersCopy) {  		lastListener = l;  		st.Restart ();  		if (l.MessageReplyListenerCallback (responseMessage' time)) {  			break;  			//was handled  		}  		if (st.ElapsedMilliseconds > 20) {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  		}  	}  	if (st.ElapsedMilliseconds > 20) {  		if (lastListener == null) {  			System.Console.WriteLine ("This is weird");  		}  		else {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  		}  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 0x15)// DAN_GUI_MESSAGE_IP_V << 4 | IP_HEADER_DAN_GUI_LENGTH   {  	// Quietly ignore packets that were generated by this machine - requests  	byte cmd = captureEventArgs.Packet.Data [DAN_gui_msg.DAN_MSG_CMD_OFFSET_WITHIN_RAW_PACKET];  	if (cmd < (byte)DAN_gui_msg.MSG_TYPE.RSP_READ) {  		// Ignore DAN request messages.  Should never come thru here' if  		// the packet filter is working as intended.  		return;  	}  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	//int len = captureEventArgs.Packet.Data.Length;  	//Console.WriteLine("{0}:{1}:{2}'{3} Len={4}  type = {5}"'  	//    time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	if (ethType != LinkLayers.Ethernet) {  		Console.WriteLine ("Unexpected ethType {0}' ignored!"' ethType);  		return;  	}  	ByteArraySegment bas = new ByteArraySegment (captureEventArgs.Packet.Data' EthernetFields.HeaderLength' IPv4Fields.HeaderLength);  	IpPacket ipPacket = new IPv4Packet (bas);  	DAN_gui_msg responseMessage = DAN_gui_msg.unmarshal (captureEventArgs.Packet.Data);  	//responseMessage.print();  	System.Diagnostics.Stopwatch st = new System.Diagnostics.Stopwatch ();  	st.Start ();  	// The listeners may remove themselves during the callback.  To avoid  	// concurrentModificationException' use a duplicate of the collection  	// for iteration  	List<MessageReplyListener> listenersCopy = new List<MessageReplyListener> (pcap.listeners);  	MessageReplyListener lastListener = null;  	foreach (MessageReplyListener l in listenersCopy) {  		lastListener = l;  		st.Restart ();  		if (l.MessageReplyListenerCallback (responseMessage' time)) {  			break;  			//was handled  		}  		if (st.ElapsedMilliseconds > 20) {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  		}  	}  	if (st.ElapsedMilliseconds > 20) {  		if (lastListener == null) {  			System.Console.WriteLine ("This is weird");  		}  		else {  			System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  		}  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: foreach (MessageReplyListener l in listenersCopy) {  	lastListener = l;  	st.Restart ();  	if (l.MessageReplyListenerCallback (responseMessage' time)) {  		break;  		//was handled  	}  	if (st.ElapsedMilliseconds > 20) {  		System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (st.ElapsedMilliseconds > 20) {  	System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' l.ToString ());  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (st.ElapsedMilliseconds > 20) {  	if (lastListener == null) {  		System.Console.WriteLine ("This is weird");  	}  	else {  		System.Console.WriteLine ("Bug? Handler {2} took {0} ms: {1}"' st.ElapsedMilliseconds' responseMessage.ToString ()' lastListener.ToString ());  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,startPacketListener,The following statement contains a magic number: device.Open (DeviceMode.Normal' 15000);  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: if (name.Length == 0) {  	// non english output?  	if (splitStr.Length > 7) {  		name = splitStr [4].Trim ();  		gwAddress = splitStr [6].Trim ();  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: if (name.Length == 0) {  	// non english output?  	if (splitStr.Length > 7) {  		name = splitStr [4].Trim ();  		gwAddress = splitStr [6].Trim ();  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: if (name.Length == 0) {  	// non english output?  	if (splitStr.Length > 7) {  		name = splitStr [4].Trim ();  		gwAddress = splitStr [6].Trim ();  	}  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: if (splitStr.Length > 7) {  	name = splitStr [4].Trim ();  	gwAddress = splitStr [6].Trim ();  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: if (splitStr.Length > 7) {  	name = splitStr [4].Trim ();  	gwAddress = splitStr [6].Trim ();  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: if (splitStr.Length > 7) {  	name = splitStr [4].Trim ();  	gwAddress = splitStr [6].Trim ();  }  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: name = splitStr [4].Trim ();  
Magic Number,WindowsFormsApplication1,PcapConnection,C:\repos\dan-sw_PTP_GUI\PcapConnection.cs,parseDeviceDescription,The following statement contains a magic number: gwAddress = splitStr [6].Trim ();  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 1) {  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	int len = captureEventArgs.Packet.Data.Length;  	Console.WriteLine ("{0}:{1}:{2}'{3} Len={4}  type = {5}"' time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	for (int i = 0; i < len; i++) {  		int v = captureEventArgs.Packet.Data [i];  		string hexValue = v.ToString ("X2");  		Console.Write (hexValue + " ");  	}  	Console.WriteLine ();  	//System.Text.ASCIIEncoding.ASCII.GetString(captureEventArgs.Packet.Data));  }  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 1) {  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	int len = captureEventArgs.Packet.Data.Length;  	Console.WriteLine ("{0}:{1}:{2}'{3} Len={4}  type = {5}"' time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	for (int i = 0; i < len; i++) {  		int v = captureEventArgs.Packet.Data [i];  		string hexValue = v.ToString ("X2");  		Console.Write (hexValue + " ");  	}  	Console.WriteLine ();  	//System.Text.ASCIIEncoding.ASCII.GetString(captureEventArgs.Packet.Data));  }  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 1) {  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	int len = captureEventArgs.Packet.Data.Length;  	Console.WriteLine ("{0}:{1}:{2}'{3} Len={4}  type = {5}"' time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	for (int i = 0; i < len; i++) {  		int v = captureEventArgs.Packet.Data [i];  		string hexValue = v.ToString ("X2");  		Console.Write (hexValue + " ");  	}  	Console.WriteLine ();  	//System.Text.ASCIIEncoding.ASCII.GetString(captureEventArgs.Packet.Data));  }  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,device_OnPacketArrival,The following statement contains a magic number: if (captureEventArgs.Packet.Data [12] == 8 && captureEventArgs.Packet.Data [13] == 0 && captureEventArgs.Packet.Data [14] == 1) {  	DateTime time = captureEventArgs.Packet.Timeval.Date;  	int len = captureEventArgs.Packet.Data.Length;  	Console.WriteLine ("{0}:{1}:{2}'{3} Len={4}  type = {5}"' time.Hour' time.Minute' time.Second' time.Millisecond' len' ethType);  	for (int i = 0; i < len; i++) {  		int v = captureEventArgs.Packet.Data [i];  		string hexValue = v.ToString ("X2");  		Console.Write (hexValue + " ");  	}  	Console.WriteLine ();  	//System.Text.ASCIIEncoding.ASCII.GetString(captureEventArgs.Packet.Data));  }  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,startPacketListener,The following statement contains a magic number: device.Open (DeviceMode.Normal' 15000);  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,csum,The following statement contains a magic number: sum = (sum >> 16) + (sum & 0xffff);  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,csum,The following statement contains a magic number: sum += (sum >> 16);  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendPacket,The following statement contains a magic number: device.Open (DeviceMode.Normal' 15000);  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendUDP,The following statement contains a magic number: udpClientB.Send (sendBuffer' 12' "192.168.0.185"' 12345);  
Magic Number,WindowsFormsApplication1,RawSockConnection,C:\repos\dan-sw_PTP_GUI\RawSockConnection.cs,sendUDP,The following statement contains a magic number: udpClientB.Send (sendBuffer' 12' "192.168.0.185"' 12345);  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: try {  	uint BaseaddressGMAC1 = 0xE577E000;  	uint[] CountersOffset = new uint[] {  		0x18c'  		0X190'  		0X194'  		0X1c4'  		0X1d4'  		0X1d8'  		0X11c'  		0X120'  		0X13c'  		0X140'  		0X144  	};  	// Read the GMAC1 TX counter  	while (true) {  		for (int i = 3; i <= 10; i += 5) {  			uint register = BaseaddressGMAC1 + CountersOffset [i];  			Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  			DAN_read_msg msg = new DAN_read_msg (register);  			PcapConnection.pcap.sendDanMsg (msg);  			DAN_gui_msg responseMsg = null;  			while (responseMsg == null) {  				SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  				responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  			}  			System.Threading.Thread.Sleep (500);  		}  	}  }  catch (Exception e) {  	System.Console.WriteLine ("Error getMessage: " + e.Message);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: try {  	uint BaseaddressGMAC1 = 0xE577E000;  	uint[] CountersOffset = new uint[] {  		0x18c'  		0X190'  		0X194'  		0X1c4'  		0X1d4'  		0X1d8'  		0X11c'  		0X120'  		0X13c'  		0X140'  		0X144  	};  	// Read the GMAC1 TX counter  	while (true) {  		for (int i = 3; i <= 10; i += 5) {  			uint register = BaseaddressGMAC1 + CountersOffset [i];  			Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  			DAN_read_msg msg = new DAN_read_msg (register);  			PcapConnection.pcap.sendDanMsg (msg);  			DAN_gui_msg responseMsg = null;  			while (responseMsg == null) {  				SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  				responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  			}  			System.Threading.Thread.Sleep (500);  		}  	}  }  catch (Exception e) {  	System.Console.WriteLine ("Error getMessage: " + e.Message);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: try {  	uint BaseaddressGMAC1 = 0xE577E000;  	uint[] CountersOffset = new uint[] {  		0x18c'  		0X190'  		0X194'  		0X1c4'  		0X1d4'  		0X1d8'  		0X11c'  		0X120'  		0X13c'  		0X140'  		0X144  	};  	// Read the GMAC1 TX counter  	while (true) {  		for (int i = 3; i <= 10; i += 5) {  			uint register = BaseaddressGMAC1 + CountersOffset [i];  			Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  			DAN_read_msg msg = new DAN_read_msg (register);  			PcapConnection.pcap.sendDanMsg (msg);  			DAN_gui_msg responseMsg = null;  			while (responseMsg == null) {  				SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  				responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  			}  			System.Threading.Thread.Sleep (500);  		}  	}  }  catch (Exception e) {  	System.Console.WriteLine ("Error getMessage: " + e.Message);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: try {  	uint BaseaddressGMAC1 = 0xE577E000;  	uint[] CountersOffset = new uint[] {  		0x18c'  		0X190'  		0X194'  		0X1c4'  		0X1d4'  		0X1d8'  		0X11c'  		0X120'  		0X13c'  		0X140'  		0X144  	};  	// Read the GMAC1 TX counter  	while (true) {  		for (int i = 3; i <= 10; i += 5) {  			uint register = BaseaddressGMAC1 + CountersOffset [i];  			Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  			DAN_read_msg msg = new DAN_read_msg (register);  			PcapConnection.pcap.sendDanMsg (msg);  			DAN_gui_msg responseMsg = null;  			while (responseMsg == null) {  				SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  				responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  			}  			System.Threading.Thread.Sleep (500);  		}  	}  }  catch (Exception e) {  	System.Console.WriteLine ("Error getMessage: " + e.Message);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: while (true) {  	for (int i = 3; i <= 10; i += 5) {  		uint register = BaseaddressGMAC1 + CountersOffset [i];  		Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  		DAN_read_msg msg = new DAN_read_msg (register);  		PcapConnection.pcap.sendDanMsg (msg);  		DAN_gui_msg responseMsg = null;  		while (responseMsg == null) {  			SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  			responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  		}  		System.Threading.Thread.Sleep (500);  	}  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: while (true) {  	for (int i = 3; i <= 10; i += 5) {  		uint register = BaseaddressGMAC1 + CountersOffset [i];  		Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  		DAN_read_msg msg = new DAN_read_msg (register);  		PcapConnection.pcap.sendDanMsg (msg);  		DAN_gui_msg responseMsg = null;  		while (responseMsg == null) {  			SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  			responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  		}  		System.Threading.Thread.Sleep (500);  	}  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: while (true) {  	for (int i = 3; i <= 10; i += 5) {  		uint register = BaseaddressGMAC1 + CountersOffset [i];  		Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  		DAN_read_msg msg = new DAN_read_msg (register);  		PcapConnection.pcap.sendDanMsg (msg);  		DAN_gui_msg responseMsg = null;  		while (responseMsg == null) {  			SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  			responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  		}  		System.Threading.Thread.Sleep (500);  	}  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: while (true) {  	for (int i = 3; i <= 10; i += 5) {  		uint register = BaseaddressGMAC1 + CountersOffset [i];  		Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  		DAN_read_msg msg = new DAN_read_msg (register);  		PcapConnection.pcap.sendDanMsg (msg);  		DAN_gui_msg responseMsg = null;  		while (responseMsg == null) {  			SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  			responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  		}  		System.Threading.Thread.Sleep (500);  	}  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: for (int i = 3; i <= 10; i += 5) {  	uint register = BaseaddressGMAC1 + CountersOffset [i];  	Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  	DAN_read_msg msg = new DAN_read_msg (register);  	PcapConnection.pcap.sendDanMsg (msg);  	DAN_gui_msg responseMsg = null;  	while (responseMsg == null) {  		SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  		responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  	}  	System.Threading.Thread.Sleep (500);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: for (int i = 3; i <= 10; i += 5) {  	uint register = BaseaddressGMAC1 + CountersOffset [i];  	Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  	DAN_read_msg msg = new DAN_read_msg (register);  	PcapConnection.pcap.sendDanMsg (msg);  	DAN_gui_msg responseMsg = null;  	while (responseMsg == null) {  		SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  		responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  	}  	System.Threading.Thread.Sleep (500);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: for (int i = 3; i <= 10; i += 5) {  	uint register = BaseaddressGMAC1 + CountersOffset [i];  	Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  	DAN_read_msg msg = new DAN_read_msg (register);  	PcapConnection.pcap.sendDanMsg (msg);  	DAN_gui_msg responseMsg = null;  	while (responseMsg == null) {  		SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  		responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  	}  	System.Threading.Thread.Sleep (500);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: for (int i = 3; i <= 10; i += 5) {  	uint register = BaseaddressGMAC1 + CountersOffset [i];  	Console.WriteLine ("Requesting counter {0} Gmac1 at {1}"' i' register.ToString ("X2"));  	DAN_read_msg msg = new DAN_read_msg (register);  	PcapConnection.pcap.sendDanMsg (msg);  	DAN_gui_msg responseMsg = null;  	while (responseMsg == null) {  		SharpPcap.RawCapture rawCapture = PcapConnection.pcap.device.GetNextPacket ();  		responseMsg = PcapConnection.pcap.parsePacket (rawCapture);  	}  	System.Threading.Thread.Sleep (500);  }  
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: i += 5
Magic Number,WindowsFormsApplication1,Program,C:\repos\dan-sw_PTP_GUI\Program.cs,testRepeatedReqResponse,The following statement contains a magic number: System.Threading.Thread.Sleep (500);  
Magic Number,WindowsFormsApplication1,Terminal,C:\repos\dan-sw_PTP_GUI\Terminal.cs,SerialParameters,The following statement contains a magic number: BaudRate = 115200;  
Magic Number,WindowsFormsApplication1,Terminal,C:\repos\dan-sw_PTP_GUI\Terminal.cs,SerialParameters,The following statement contains a magic number: DataBits = 8;  
Magic Number,WindowsFormsApplication1,Terminal,C:\repos\dan-sw_PTP_GUI\Terminal.cs,SerialParameters,The following statement contains a magic number: ReadTimeout = 200;  
Magic Number,WindowsFormsApplication1,Terminal,C:\repos\dan-sw_PTP_GUI\Terminal.cs,SerialParameters,The following statement contains a magic number: WriteTimeout = 200;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10) {  	// unit  	OrderOfMagnitude = 0;  }  else if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100) {  	// Deci  	OrderOfMagnitude = 1;  }  else if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000) {  	// Centi  	OrderOfMagnitude = 2;  }  else if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 2;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000) {  	// Kilo  	OrderOfMagnitude = 3;  }  else if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 3;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000) {  	// Ten thousand  	OrderOfMagnitude = 4;  }  else if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 4;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 1000000) {  	// Hundred thousand  	OrderOfMagnitude = 5;  }  else if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 5;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 10000000) {  	// Mega  	OrderOfMagnitude = 6;  }  else if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 6;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Ten Million  	OrderOfMagnitude = 7;  }  else if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 7;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: if (maxValue <= 100000000) {  	// Hundred Million (one Gig highest value)  	OrderOfMagnitude = 8;  }  else {  	// Ten Gig (One billion per grid square)  	OrderOfMagnitude = 9;  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 8;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,adjustOrderOfMagnitude,The following statement contains a magic number: OrderOfMagnitude = 9;  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Relative) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (currentMaxValue.ToString ("n2")' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Relative) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (currentMaxValue.ToString ("n2")' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Relative) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (currentMaxValue.ToString ("n2")' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Relative) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (currentMaxValue.ToString ("n2")' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Magnitude) {  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	g.DrawString (MagnitudeLabel' this.Font' sb' 4.0f' 2.0f);  }  else if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (scaleMode == ScaleMode.Absolute && ShowAbsoluteScale) {  	// To see a different color' I'm using AverageLinePen.Color' which is not currently  	// used in this application' otherwise.  	SolidBrush sb = new SolidBrush (perfChartStyle.AvgLinePen.Color);  	// TODO: Refactor these into a single' more generic technique:  	if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  		// use default numbering  		g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  		float y = (float)(2 * grid_Y_spacing);  		g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(4 * grid_Y_spacing);  		g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(6 * grid_Y_spacing);  		g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y = (float)(8 * grid_Y_spacing);  		g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	}  	else {  		float y = 0.0f;  		float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  		foreach (string s in AbsoluteScaleLabels) {  			g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  			y += deltaY;  		}  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  	// use default numbering  	g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  	float y = (float)(2 * grid_Y_spacing);  	g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(4 * grid_Y_spacing);  	g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(6 * grid_Y_spacing);  	g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(8 * grid_Y_spacing);  	g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  }  else {  	float y = 0.0f;  	float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  	foreach (string s in AbsoluteScaleLabels) {  		g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y += deltaY;  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  	// use default numbering  	g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  	float y = (float)(2 * grid_Y_spacing);  	g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(4 * grid_Y_spacing);  	g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(6 * grid_Y_spacing);  	g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(8 * grid_Y_spacing);  	g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  }  else {  	float y = 0.0f;  	float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  	foreach (string s in AbsoluteScaleLabels) {  		g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y += deltaY;  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  	// use default numbering  	g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  	float y = (float)(2 * grid_Y_spacing);  	g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(4 * grid_Y_spacing);  	g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(6 * grid_Y_spacing);  	g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(8 * grid_Y_spacing);  	g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  }  else {  	float y = 0.0f;  	float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  	foreach (string s in AbsoluteScaleLabels) {  		g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y += deltaY;  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: if (AbsoluteScaleLabels == null || AbsoluteScaleLabels.Length == 0) {  	// use default numbering  	g.DrawString ("100"' this.Font' sb' 4.0f' 0.0f);  	float y = (float)(2 * grid_Y_spacing);  	g.DrawString ("80"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(4 * grid_Y_spacing);  	g.DrawString ("60"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(6 * grid_Y_spacing);  	g.DrawString ("40"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  	y = (float)(8 * grid_Y_spacing);  	g.DrawString ("20"' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  }  else {  	float y = 0.0f;  	float deltaY = (float)surfaceRectangle.Height / (float)AbsoluteScaleLabels.Length;  	foreach (string s in AbsoluteScaleLabels) {  		g.DrawString (s' this.Font' sb' 4.0f' (float)surfaceRectangle.Top + y);  		y += deltaY;  	}  }  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: y = (float)(4 * grid_Y_spacing);  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: y = (float)(6 * grid_Y_spacing);  
Magic Number,SpPerfChart,SpPerfChart,C:\repos\dan-sw_PTP_GUI\SpPerfChart.cs,DrawChart,The following statement contains a magic number: y = (float)(8 * grid_Y_spacing);  
Missing Default,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following switch statement is missing a default case: switch (BackgroundImageLayout) {  case ImageLayout.Center:  	ggr.DrawImageUnscaled (BackgroundImage' Width / 2 - BackgroundImage.Width / 2' Height / 2 - BackgroundImage.Height / 2);  	break;  case ImageLayout.None:  	ggr.DrawImageUnscaled (BackgroundImage' 0' 0);  	break;  case ImageLayout.Stretch:  	ggr.DrawImage (BackgroundImage' 0' 0' Width' Height);  	break;  case ImageLayout.Tile:  	Int32 pixelOffsetX = 0;  	Int32 pixelOffsetY = 0;  	while (pixelOffsetX < Width) {  		pixelOffsetY = 0;  		while (pixelOffsetY < Height) {  			ggr.DrawImageUnscaled (BackgroundImage' pixelOffsetX' pixelOffsetY);  			pixelOffsetY += BackgroundImage.Height;  		}  		pixelOffsetX += BackgroundImage.Width;  	}  	break;  case ImageLayout.Zoom:  	if ((Single)(BackgroundImage.Width / Width) < (Single)(BackgroundImage.Height / Height)) {  		ggr.DrawImage (BackgroundImage' 0' 0' Height' Height);  	}  	else {  		ggr.DrawImage (BackgroundImage' 0' 0' Width' Width);  	}  	break;  }  
Missing Default,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following switch statement is missing a default case: switch (m_NeedleType) {  case 0:  	PointF[] points = new PointF[3];  	Brush brush1 = Brushes.White;  	Brush brush2 = Brushes.White;  	Brush brush3 = Brushes.White;  	Brush brush4 = Brushes.White;  	Brush brushBucket = Brushes.White;  	Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);  	Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Red:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Green:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Blue:  		brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Magenta:  		brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Violet:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	case NeedleColorEnum.Yellow:  		brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  		brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  		brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  		brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  		pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  		break;  	}  	if (Math.Floor ((Single)(((brushAngle + 225) % 360) / 180.0)) == 0) {  		brushBucket = brush1;  		brush1 = brush2;  		brush2 = brushBucket;  	}  	if (Math.Floor ((Single)(((brushAngle + 135) % 360) / 180.0)) == 0) {  		brush4 = brush3;  	}  	points [0].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	pe.Graphics.FillPolygon (brush1' points);  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush2' points);  	points [0].X = (Single)(Center.X - (m_NeedleRadius / 20 - 1) * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - (m_NeedleRadius / 20 - 1) * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle + Math.PI / 2));  	points [1].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle + Math.PI / 2));  	points [2].X = (Single)(Center.X - m_NeedleRadius / 5 * Math.Cos (needleAngle) + m_NeedleWidth * 2 * Math.Cos (needleAngle - Math.PI / 2));  	points [2].Y = (Single)(Center.Y - m_NeedleRadius / 5 * Math.Sin (needleAngle) + m_NeedleWidth * 2 * Math.Sin (needleAngle - Math.PI / 2));  	pe.Graphics.FillPolygon (brush4' points);  	points [0].X = (Single)(Center.X - m_NeedleRadius / 20 * Math.Cos (needleAngle));  	points [0].Y = (Single)(Center.Y - m_NeedleRadius / 20 * Math.Sin (needleAngle));  	points [1].X = (Single)(Center.X + m_NeedleRadius * Math.Cos (needleAngle));  	points [1].Y = (Single)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle));  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [0].X' points [0].Y);  	pe.Graphics.DrawLine (new Pen (m_NeedleColor2)' Center.X' Center.Y' points [1].X' points [1].Y);  	break;  case 1:  	Point startPoint = new Point ((Int32)(Center.X - m_NeedleRadius / 8 * Math.Cos (needleAngle))' (Int32)(Center.Y - m_NeedleRadius / 8 * Math.Sin (needleAngle)));  	Point endPoint = new Point ((Int32)(Center.X + m_NeedleRadius * Math.Cos (needleAngle))' (Int32)(Center.Y + m_NeedleRadius * Math.Sin (needleAngle)));  	pe.Graphics.FillEllipse (new SolidBrush (m_NeedleColor2)' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	switch (m_NeedleColor1) {  	case NeedleColorEnum.Gray:  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Red:  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Green:  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Blue:  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Magenta:  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Violet:  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	case NeedleColorEnum.Yellow:  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  		pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  		break;  	}  	break;  }  
Missing Default,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following switch statement is missing a default case: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	brush1 = new SolidBrush (Color.FromArgb (80 + subcol' 80 + subcol' 80 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (180 - subcol' 180 - subcol' 180 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (80 + subcol2' 80 + subcol2' 80 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (180 - subcol2' 180 - subcol2' 180 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Gray' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Red:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Red' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Green:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Green' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Blue:  	brush1 = new SolidBrush (Color.FromArgb (subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Blue' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Magenta:  	brush1 = new SolidBrush (Color.FromArgb (subcol' 145 + subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (100 - subcol' 245 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (subcol2' 145 + subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (100 - subcol2' 245 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Magenta' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Violet:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' subcol' 145 + subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 100 - subcol' 245 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' subcol2' 145 + subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 100 - subcol2' 245 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  case NeedleColorEnum.Yellow:  	brush1 = new SolidBrush (Color.FromArgb (145 + subcol' 145 + subcol' subcol));  	brush2 = new SolidBrush (Color.FromArgb (245 - subcol' 245 - subcol' 100 - subcol));  	brush3 = new SolidBrush (Color.FromArgb (145 + subcol2' 145 + subcol2' subcol2));  	brush4 = new SolidBrush (Color.FromArgb (245 - subcol2' 245 - subcol2' 100 - subcol2));  	pe.Graphics.DrawEllipse (Pens.Violet' Center.X - m_NeedleWidth * 3' Center.Y - m_NeedleWidth * 3' m_NeedleWidth * 6' m_NeedleWidth * 6);  	break;  }  
Missing Default,WindowsFormsApplication1,AGaugeControl,C:\repos\dan-sw_PTP_GUI\AGaugeControl.cs,OnPaint,The following switch statement is missing a default case: switch (m_NeedleColor1) {  case NeedleColorEnum.Gray:  	pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.DarkGray' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  case NeedleColorEnum.Red:  	pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.Red' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  case NeedleColorEnum.Green:  	pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.Green' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  case NeedleColorEnum.Blue:  	pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.Blue' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  case NeedleColorEnum.Magenta:  	pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.Magenta' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  case NeedleColorEnum.Violet:  	pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.Violet' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  case NeedleColorEnum.Yellow:  	pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' endPoint.X' endPoint.Y);  	pe.Graphics.DrawLine (new Pen (Color.Yellow' m_NeedleWidth)' Center.X' Center.Y' startPoint.X' startPoint.Y);  	break;  }  
Missing Default,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,setCombosFromMCS,The following switch statement is missing a default case: switch (RunningProfile) {  case 0:  	bw = MCS.BANDWIDTH.MHZ80;  	break;  case 1:  	bw = MCS.BANDWIDTH.MHZ56;  	break;  case 2:  	bw = MCS.BANDWIDTH.MHZ28;  	break;  case 21:  	bw = MCS.BANDWIDTH.MHZ20;  	break;  case 22:  	bw = MCS.BANDWIDTH.MHZ10;  	break;  case 39:  	bw = MCS.BANDWIDTH.MHZ112;  	break;  }  
Missing Default,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,checkMCSSet2,The following switch statement is missing a default case: switch (comboBoxMCSSetSelect.Text) {  case ("MCS Set 1"):  	MCSSet = 1;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 2"):  	MCSSet = 2;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 3"):  	MCSSet = 3;  	MCSSetAutomatic = false;  	break;  case ("MCS Set 4"):  	MCSSet = 4;  	MCSSetAutomatic = false;  	break;  case ("Automatic"):  	MCSSet = (int)PHY.phy.MCS_Set;  	MCSSetAutomatic = true;  	break;  }  
Missing Default,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,handlePLLReadReply,The following switch statement is missing a default case: switch (msg.data [PLL_Working_Mode]) {  case (257):  	//0x0101  	comboBoxPLLWorkingMode.SelectedIndex = 0;  	break;  case (17):  	//0x0011  	comboBoxPLLWorkingMode.SelectedIndex = 1;  	break;  case (1):  	//0x0001  	comboBoxPLLWorkingMode.SelectedIndex = 2;  	break;  }  
Missing Default,WindowsFormsApplication1,FormNodeProperties,C:\repos\dan-sw_PTP_GUI\FormNodeProperties.cs,buttonDebugApply_Click,The following switch statement is missing a default case: switch (comboBoxPLLWorkingMode.SelectedIndex) {  case (0):  	// 257                     	value = 0x0101;  	break;  case (1):  	// 17  	value = 0x0011;  	break;  case (2):  	// 1     	value = 0x0001;  	break;  }  
Missing Default,WindowsFormsApplication1,MCS,C:\repos\dan-sw_PTP_GUI\MCS.cs,Current_MCS,The following switch statement is missing a default case: switch (BW) {  case (BANDWIDTH.MHZ80):  	Current_MCS_scheme = mcsSet80;  	break;  case (BANDWIDTH.MHZ56):  	Current_MCS_scheme = mcsSet56;  	break;  case (BANDWIDTH.MHZ28):  	Current_MCS_scheme = mcsSet28;  	break;  }  
