Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PacketDotNet,EthernetPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\EthernetPacket.cs,ParseEncapsulatedBytes,Cyclomatic complexity of the method is 18
Complex Method,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,Cyclomatic complexity of the method is 16
Complex Method,PacketDotNet,RadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,PacketDotNet,IpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IpPacket.cs,ParseEncapsulatedBytes,Cyclomatic complexity of the method is 18
Complex Method,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,ParsePacket,Cyclomatic complexity of the method is 17
Complex Method,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ParseOptions,Cyclomatic complexity of the method is 62
Complex Method,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,Cyclomatic complexity of the method is 13
Complex Method,PacketDotNet,PPPPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPPacket.cs,ParseEncapsulatedBytes,Cyclomatic complexity of the method is 8
Complex Method,PacketDotNet,LLDPPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\LLDPPacket.cs,TLVFactory,Cyclomatic complexity of the method is 12
Complex Method,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,Cyclomatic complexity of the method is 8
Complex Method,PacketDotNet.LLDP,ChassisID,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\ChassisID.cs,GetSubTypeValue,Cyclomatic complexity of the method is 13
Complex Method,PacketDotNet.LLDP,ChassisID,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\ChassisID.cs,SetSubTypeValue,Cyclomatic complexity of the method is 30
Complex Method,PacketDotNet.LLDP,PortID,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\PortID.cs,GetSubTypeValue,Cyclomatic complexity of the method is 15
Complex Method,PacketDotNet.LLDP,PortID,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\PortID.cs,SetSubTypeValue,Cyclomatic complexity of the method is 15
Long Parameter List,PacketDotNet,ARPPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\ARPPacket.cs,ARPPacket,The method has 5 parameters.
Long Identifier,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,AttachPseudoIPHeader,The length of the parameter numberOfBytesFromIPHeaderUsedToGenerateChecksum is 47.
Long Statement,PacketDotNet,EthernetPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\EthernetPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[EthernetPacket: SourceHwAddress={2}' DestinationHwAddress={3}' Type={4}]{1}"' color' colorEscape' HexPrinter.PrintMACAddress (SourceHwAddress)' HexPrinter.PrintMACAddress (DestinationHwAddress)' Type.ToString ()); " is 239.
Long Statement,PacketDotNet,EthernetPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\EthernetPacket.cs,RandomPacket,The length of the statement  "	return new EthernetPacket (new PhysicalAddress (srcPhysicalAddress)' new PhysicalAddress (dstPhysicalAddress)' EthernetPacketType.None); " is 136.
Long Statement,PacketDotNet,Ieee80211MacFrame,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211MacFrame.cs,SetAddress,The length of the statement  "		throw new System.InvalidOperationException ("address length " + hwAddress.Length + " not equal to the expected length of " + Ieee80211MacFields.AddressLength); " is 159.
Long Statement,PacketDotNet,Ieee80211MacFrame,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211MacFrame.cs,ToString,The length of the statement  "	return string.Format ("FrameControl {0}' InnerFrame {1}' FrameCheckSequence {2}"' FrameControl.ToString ()' InnerFrame.ToString ()' FrameCheckSequence); " is 152.
Long Statement,PacketDotNet,Ieee80211RadioPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[Ieee80211RadioPacket: Version={2}' Length={3}' Present[0]=0x{4:x}]{1}"' color' colorEscape' Version' Length' Present [0]); " is 148.
Long Statement,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The length of the statement  "			buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii); " is 125.
Long Statement,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ParseOptions,The length of the statement  "			throw new NotSupportedException ("Option: " + type.ToString () + " is not supported because its RFC specification is still experimental"); " is 138.
Long Statement,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[TCPPacket: SourcePort={2}' DestinationPort={3}' Flags={4}]{1}"' color' colorEscape' SourcePort' DestinationPort' flags); " is 146.
Long Statement,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The length of the statement  "		properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")"); " is 129.
Long Statement,PacketDotNet,UdpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\UdpPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[UDPPacket: SourcePort={2}' DestinationPort={3}]{1}"' color' colorEscape' SourcePort' DestinationPort); " is 128.
Long Statement,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,AttachPseudoIPHeader,The length of the statement  "	Array.Copy (header.Bytes' header.Offset + IPv4Fields.SourcePosition' headerForChecksum' 0' IPv4Fields.AddressLength * 2); " is 121.
Long Statement,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[IPv4Packet: SourceAddress={2}' DestinationAddress={3}' HeaderLength={4}' Protocol={5}' TimeToLive={6}]{1}"' color' colorEscape' SourceAddress' DestinationAddress' HeaderLength' Protocol' TimeToLive); " is 225.
Long Statement,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The length of the statement  "		properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]"); " is 120.
Long Statement,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[IPv6Packet: SourceAddress={2}' DestinationAddress={3}' NextHeader={4}]{1}"' color' colorEscape' SourceAddress' DestinationAddress' NextHeader); " is 169.
Long Statement,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The length of the statement  "		properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0')); " is 139.
Long Statement,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The length of the statement  "		string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " "); " is 135.
Long Statement,PacketDotNet,ARPPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\ARPPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[ARPPacket: Operation={2}' SenderHardwareAddress={3}' TargetHardwareAddress={4}' SenderProtocolAddress={5}' TargetProtocolAddress={6}]{1}"' color' colorEscape' Operation' HexPrinter.PrintMACAddress (SenderHardwareAddress)' HexPrinter.PrintMACAddress (TargetHardwareAddress)' SenderProtocolAddress' TargetProtocolAddress); " is 346.
Long Statement,PacketDotNet,ICMPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\ICMPv6Packet.cs,ToString,The length of the statement  "		buffer.AppendLine ("ICMP:  ******* ICMPv6 - \"Internet Control Message Protocol (Version 6)\"- offset=? length=" + TotalPacketLength); " is 134.
Long Statement,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[IGMPv2Packet: Type={2}' MaxResponseTime={3}' GroupAddress={4}]{1}"' color' colorEscape' Type' String.Format ("{0:0.0}"' (MaxResponseTime / 10))' GroupAddress); " is 185.
Long Statement,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The length of the statement  "		properties.Add ("max response time"' String.Format ("{0:0.0}"' MaxResponseTime / 10) + " sec (0x" + MaxResponseTime.ToString ("x") + ")"); " is 138.
Long Statement,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The length of the statement  "		buffer.AppendLine ("IGMP:  ******* IGMPv2 - \"Internet Group Management Protocol (Version 2)\" - offset=? length=" + TotalPacketLength); " is 136.
Long Statement,PacketDotNet,LinuxSLLPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\LinuxSLLPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("[{0}LinuxSLLPacket{1}: Type={2}' LinkLayerAddressType={3}' LinkLayerAddressLength={4}' Source={5}' ProtocolType={6}]"' color' colorEscape' Type' LinkLayerAddressType' LinkLayerAddressLength' BitConverter.ToString (LinkLayerAddress' 0)' EthernetProtocolType); " is 280.
Long Statement,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The length of the statement  "		buffer.AppendFormat ("{0}[PPPoEPacket: Version={2}' Type={3}' Code={4}' SessionId={5}' Length={6}]{1}"' color' colorEscape' Version' Type' Code' SessionId' Length); " is 164.
Long Statement,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The length of the statement  "		buffer.AppendLine ("PPPoE:  ******* PPPoE - \"Point-to-Point Protocol over Ethernet\" - offset=? length=" + TotalPacketLength); " is 127.
Long Statement,PacketDotNet,ICMPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\ICMPv4Packet.cs,ToString,The length of the statement  "		buffer.AppendLine ("ICMP:  ******* ICMPv4 - \"Internet Control Message Protocol (Version 4)\" - offset=? length=" + TotalPacketLength); " is 135.
Long Statement,PacketDotNet,TLVCollection,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\TLVCollection.cs,InsertItem,The length of the statement  "			log.DebugFormat ("Replacing {0} with user provided {1}' Type {2}"' this [Count - 1].GetType ()' item.GetType ()' item.Type); " is 124.
Long Statement,PacketDotNet.Utils,ByteArraySegment,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\ByteArraySegment.cs,EncapsulatedBytes,The length of the statement  "	log.DebugFormat ("NewSegmentLength {0}' NewByteLength {1}' BytesLength {2}"' NewSegmentLength' NewByteLength' BytesLength); " is 123.
Long Statement,PacketDotNet.Utils,ByteArraySegment,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\ByteArraySegment.cs,ToString,The length of the statement  "	return string.Format ("[ByteArraySegment: Length={0}' Bytes.Length={1}' BytesLength={2}' Offset={3}' NeedsCopyForActualBytes={4}]"' Length' Bytes.Length' BytesLength' Offset' NeedsCopyForActualBytes); " is 200.
Long Statement,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read,The length of the statement  "		throw new ArgumentException ("Not enough space in buffer for specified number of characters starting at specified index"); " is 122.
Long Statement,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadInternal,The length of the statement  "			throw new EndOfStreamException (String.Format ("End of stream reached with {0} byte{1} left to read."' size - index' size - index == 1 ? "s" : "")); " is 148.
Long Statement,PacketDotNet.LLDP,ManagementAddress,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\ManagementAddress.cs,ToString,The length of the statement  "	return string.Format ("[ManagementAddress: AddressLength={0}' AddressSubType={1}' MgmtAddress={2}' InterfaceSubType={3}' InterfaceNumber={4}' ObjIdLength={5}' ObjectIdentifier={6}]"' AddressLength' AddressSubType' MgmtAddress' InterfaceSubType' InterfaceNumber' ObjIdLength' ObjectIdentifier); " is 293.
Long Statement,PacketDotNet.LLDP,OrganizationSpecific,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\LLDP\OrganizationSpecific.cs,ToString,The length of the statement  "	return string.Format ("[OrganizationSpecific: OrganizationUniqueID={0}' OrganizationDefinedSubType={1}' OrganizationDefinedInfoString={2}]"' OrganizationUniqueID' OrganizationDefinedSubType' OrganizationDefinedInfoString); " is 222.
Long Statement,PacketDotNet.Tcp,WindowScaleFactor,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Tcp\WindowScaleFactor.cs,ToString,The length of the statement  "	return "[" + Kind.ToString () + ": ScaleFactor=" + ScaleFactor.ToString () + " (multiply by " + (1 << ScaleFactor).ToString () + ")]"; " is 134.
Magic Number,PacketDotNet,Ieee80211MacFrame,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211MacFrame.cs,GetOffsetForAddress,The following statement contains a magic number: if (addressIndex == 4)  	offset += Ieee80211MacFields.SequenceControlLength;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: switch (frequencyMHz) {  case 2412:  	return 1;  case 2417:  	return 2;  case 2422:  	return 3;  case 2427:  	return 4;  case 2432:  	return 5;  case 2437:  	return 6;  case 2442:  	return 7;  case 2447:  	return 8;  case 2452:  	return 9;  case 2457:  	return 10;  case 2462:  	return 11;  case 2467:  	return 12;  case 2472:  	return 13;  case 2484:  	return 14;  default:  	throw new System.NotImplementedException ("Unknown frequencyMHz " + frequencyMHz);  }  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 2;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 3;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 4;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 5;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 6;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 7;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 8;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 9;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 10;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 11;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 12;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 13;  
Magic Number,PacketDotNet,ChannelRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,ChannelFromFrequencyMHz,The following statement contains a magic number: return 14;  
Magic Number,PacketDotNet,FhssRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,FhssRadioTapField,The following statement contains a magic number: Pattern = (byte)((u16 >> 8) & 0xff);  
Magic Number,PacketDotNet,RateRadioTapField,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Ieee80211RadioTapFields.cs,RateRadioTapField,The following statement contains a magic number: RateMbps = (0.5 * (u8 & 0x7f));  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: for (int i = 1; i <= data.Length; i++) {  	// add the current byte to the bytes hex string  	bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  	// add the current byte to the asciiBytes array for later processing  	if (data [i - 1] < 0x21 || data [i - 1] > 0x7e) {  		ascii += ".";  	}  	else {  		ascii += Encoding.ASCII.GetString (new byte[1] {  			data [i - 1]  		});  	}  	// add an additional space to split the bytes into  	//  two groups of 8 bytes  	if (i % 16 != 0 && i % 8 == 0) {  		bytes += " ";  		ascii += " ";  	}  	// append the output string  	if (i % 16 == 0) {  		// add the 16 byte segment number  		segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  		// reset for the next line  		bytes = "";  		ascii = "";  		continue;  	}  	// handle the last pass  	if (i == data.Length) {  		// add the 16 byte segment number  		segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  		// build the line  		buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  	}  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: bytes += (data [i - 1].ToString ("x")).PadLeft (2' '0') + " ";  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 != 0 && i % 8 == 0) {  	bytes += " ";  	ascii += " ";  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 != 0 && i % 8 == 0) {  	bytes += " ";  	ascii += " ";  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 == 0) {  	// add the 16 byte segment number  	segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  	// reset for the next line  	bytes = "";  	ascii = "";  	continue;  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 == 0) {  	// add the 16 byte segment number  	segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  	// reset for the next line  	bytes = "";  	ascii = "";  	continue;  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 == 0) {  	// add the 16 byte segment number  	segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  	// reset for the next line  	bytes = "";  	ascii = "";  	continue;  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 == 0) {  	// add the 16 byte segment number  	segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  	// reset for the next line  	bytes = "";  	ascii = "";  	continue;  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i % 16 == 0) {  	// add the 16 byte segment number  	segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + segmentNumber + "  " + bytes + "  " + ascii);  	// reset for the next line  	bytes = "";  	ascii = "";  	continue;  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = ((((i - 16) / 16) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i == data.Length) {  	// add the 16 byte segment number  	segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i == data.Length) {  	// add the 16 byte segment number  	segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i == data.Length) {  	// add the 16 byte segment number  	segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i == data.Length) {  	// add the 16 byte segment number  	segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i == data.Length) {  	// add the 16 byte segment number  	segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: if (i == data.Length) {  	// add the 16 byte segment number  	segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  	// build the line  	buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  }  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: segmentNumber = (((((i - 16) / 16) + 1) * 10).ToString ()).PadLeft (4' '0');  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  
Magic Number,PacketDotNet,Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\Packet.cs,PrintHex,The following statement contains a magic number: buffer.AppendLine ("Data: " + (segmentNumber.ToString ()).PadLeft (4' '0') + "  " + bytes.PadRight (49' ' ') + "  " + ascii);  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,TcpPacket,The following statement contains a magic number: DataOffset = length / 4;  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,TcpPacket,The following statement contains a magic number: header.Length = DataOffset * 4;  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,TcpPacket,The following statement contains a magic number: if (this.ParentPacket is IPv4Packet) {  	// actual total length (tcp header + tcp payload)  	var ipv4Parent = (IPv4Packet)this.ParentPacket;  	var ipPayloadTotalLength = ipv4Parent.TotalLength - (ipv4Parent.HeaderLength * 4);  	log.DebugFormat ("ipv4Parent.TotalLength {0}' ipv4Parent.HeaderLength {1}"' ipv4Parent.TotalLength' ipv4Parent.HeaderLength * 4);  	var newTcpPayloadLength = ipPayloadTotalLength - this.Header.Length;  	log.DebugFormat ("Header.Length {0}' Current payload length: {1}' new payload length {2}"' this.header.Length' payloadPacketOrData.TheByteArraySegment.Length' newTcpPayloadLength);  	// the length of the payload is the total payload length  	// above' minus the length of the tcp header  	payloadPacketOrData.TheByteArraySegment.Length = newTcpPayloadLength;  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,TcpPacket,The following statement contains a magic number: if (this.ParentPacket is IPv4Packet) {  	// actual total length (tcp header + tcp payload)  	var ipv4Parent = (IPv4Packet)this.ParentPacket;  	var ipPayloadTotalLength = ipv4Parent.TotalLength - (ipv4Parent.HeaderLength * 4);  	log.DebugFormat ("ipv4Parent.TotalLength {0}' ipv4Parent.HeaderLength {1}"' ipv4Parent.TotalLength' ipv4Parent.HeaderLength * 4);  	var newTcpPayloadLength = ipPayloadTotalLength - this.Header.Length;  	log.DebugFormat ("Header.Length {0}' Current payload length: {1}' new payload length {2}"' this.header.Length' payloadPacketOrData.TheByteArraySegment.Length' newTcpPayloadLength);  	// the length of the payload is the total payload length  	// above' minus the length of the tcp header  	payloadPacketOrData.TheByteArraySegment.Length = newTcpPayloadLength;  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,TcpPacket,The following statement contains a magic number: log.DebugFormat ("ipv4Parent.TotalLength {0}' ipv4Parent.HeaderLength {1}"' ipv4Parent.TotalLength' ipv4Parent.HeaderLength * 4);  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Normal || outputFormat == StringOutputType.Colored) {  	// build flagstring  	string flags = "{";  	if (Urg)  		flags += "urg[0x" + System.Convert.ToString (UrgentPointer' 16) + "]|";  	if (Ack)  		flags += "ack[" + AcknowledgmentNumber + " (0x" + System.Convert.ToString (AcknowledgmentNumber' 16) + ")]|";  	if (Psh)  		flags += "psh|";  	if (Rst)  		flags += "rst|";  	if (Syn)  		flags += "syn[0x" + System.Convert.ToString (SequenceNumber' 16) + "'" + SequenceNumber + "]|";  	flags = flags.TrimEnd ('|');  	flags += "}";  	// build the output string  	buffer.AppendFormat ("{0}[TCPPacket: SourcePort={2}' DestinationPort={3}' Flags={4}]{1}"' color' colorEscape' SourcePort' DestinationPort' flags);  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Normal || outputFormat == StringOutputType.Colored) {  	// build flagstring  	string flags = "{";  	if (Urg)  		flags += "urg[0x" + System.Convert.ToString (UrgentPointer' 16) + "]|";  	if (Ack)  		flags += "ack[" + AcknowledgmentNumber + " (0x" + System.Convert.ToString (AcknowledgmentNumber' 16) + ")]|";  	if (Psh)  		flags += "psh|";  	if (Rst)  		flags += "rst|";  	if (Syn)  		flags += "syn[0x" + System.Convert.ToString (SequenceNumber' 16) + "'" + SequenceNumber + "]|";  	flags = flags.TrimEnd ('|');  	flags += "}";  	// build the output string  	buffer.AppendFormat ("{0}[TCPPacket: SourcePort={2}' DestinationPort={3}' Flags={4}]{1}"' color' colorEscape' SourcePort' DestinationPort' flags);  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Normal || outputFormat == StringOutputType.Colored) {  	// build flagstring  	string flags = "{";  	if (Urg)  		flags += "urg[0x" + System.Convert.ToString (UrgentPointer' 16) + "]|";  	if (Ack)  		flags += "ack[" + AcknowledgmentNumber + " (0x" + System.Convert.ToString (AcknowledgmentNumber' 16) + ")]|";  	if (Psh)  		flags += "psh|";  	if (Rst)  		flags += "rst|";  	if (Syn)  		flags += "syn[0x" + System.Convert.ToString (SequenceNumber' 16) + "'" + SequenceNumber + "]|";  	flags = flags.TrimEnd ('|');  	flags += "}";  	// build the output string  	buffer.AppendFormat ("{0}[TCPPacket: SourcePort={2}' DestinationPort={3}' Flags={4}]{1}"' color' colorEscape' SourcePort' DestinationPort' flags);  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (Urg)  	flags += "urg[0x" + System.Convert.ToString (UrgentPointer' 16) + "]|";  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: flags += "urg[0x" + System.Convert.ToString (UrgentPointer' 16) + "]|";  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (Ack)  	flags += "ack[" + AcknowledgmentNumber + " (0x" + System.Convert.ToString (AcknowledgmentNumber' 16) + ")]|";  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: flags += "ack[" + AcknowledgmentNumber + " (0x" + System.Convert.ToString (AcknowledgmentNumber' 16) + ")]|";  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (Syn)  	flags += "syn[0x" + System.Convert.ToString (SequenceNumber' 16) + "'" + SequenceNumber + "]|";  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: flags += "syn[0x" + System.Convert.ToString (SequenceNumber' 16) + "'" + SequenceNumber + "]|";  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("source port"' SourcePort.ToString ());  	properties.Add ("destination port"' DestinationPort.ToString ());  	properties.Add ("sequence number"' SequenceNumber.ToString () + " (0x" + SequenceNumber.ToString ("x") + ")");  	properties.Add ("acknowledgement number"' AcknowledgmentNumber.ToString () + " (0x" + AcknowledgmentNumber.ToString ("x") + ")");  	// TODO: Implement a HeaderLength property for TCPPacket  	//properties.Add("header length"' HeaderLength.ToString());  	properties.Add ("flags"' "(0x" + AllFlags.ToString ("x") + ")");  	string flags = Convert.ToString (AllFlags' 2).PadLeft (8' '0');  	properties.Add (""' flags [0] + "... .... = [" + flags [0] + "] congestion window reduced");  	properties.Add (" "' "." + flags [1] + ".. .... = [" + flags [1] + "] ECN - echo");  	properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  	properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  	properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  	properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  	properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  	properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  	properties.Add ("window size"' WindowSize.ToString ());  	properties.Add ("checksum"' "0x" + Checksum.ToString () + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  	var parsedOptions = OptionsCollection;  	if (parsedOptions != null) {  		for (int i = 0; i < parsedOptions.Count; i++) {  			properties.Add ("option" + (i + 1).ToString ()' parsedOptions [i].ToString ());  		}  	}  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("TCP:  ******* TCP - \"Transmission Control Protocol\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("TCP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("TCP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("TCP:");  }  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("  "' ".." + flags [2] + ". .... = [" + flags [2] + "] urgent");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("   "' "..." + flags [3] + " .... = [" + flags [3] + "] acknowledgement");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("    "' ".... " + flags [4] + "... = [" + flags [4] + "] push");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("     "' ".... ." + flags [5] + ".. = [" + flags [5] + "] reset");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("      "' ".... .." + flags [6] + ". = [" + flags [6] + "] syn");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("       "' ".... ..." + flags [7] + " = [" + flags [7] + "] fin");  
Magic Number,PacketDotNet,TcpPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\TcpPacket.cs,ToString,The following statement contains a magic number: properties.Add ("options"' "0x" + BitConverter.ToString (Options).Replace ("-"' "").PadLeft (12' '0'));  
Magic Number,PacketDotNet,EthernetFields,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\EthernetFields.cs,EthernetFields,The following statement contains a magic number: TypePosition = EthernetFields.MacAddressLength * 2;  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,AttachPseudoIPHeader,The following statement contains a magic number: Array.Copy (header.Bytes' header.Offset + IPv4Fields.SourcePosition' headerForChecksum' 0' IPv4Fields.AddressLength * 2);  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,AttachPseudoIPHeader,The following statement contains a magic number: headerForChecksum [8] = 0;  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,AttachPseudoIPHeader,The following statement contains a magic number: headerForChecksum [9] = (byte)Protocol;  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,AttachPseudoIPHeader,The following statement contains a magic number: EndianBitConverter.Big.CopyBytes (length' headerForChecksum' 10);  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,IPv4Packet,The following statement contains a magic number: HeaderLength = (HeaderMinimumLength / 4);  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,IPv4Packet,The following statement contains a magic number: header.Length = HeaderLength * 4;  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("version"' Version.ToString ());  	// FIXME: Header length output is incorrect  	properties.Add ("header length"' HeaderLength + " bytes");  	string diffServices = Convert.ToString (DifferentiatedServices' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  	properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  	properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  	properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  	properties.Add ("total length"' TotalLength.ToString ());  	properties.Add ("identification"' "0x" + Id.ToString ("x") + " (" + Id + ")");  	string flags = Convert.ToString (FragmentFlags' 2).PadLeft (8' '0').Substring (5' 3);  	properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  	properties.Add ("   "' flags [0] + ".. = [" + flags [0] + "] reserved");  	properties.Add ("    "' "." + flags [1] + ". = [" + flags [1] + "] don't fragment");  	properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  	properties.Add ("fragment offset"' FragmentOffset.ToString ());  	properties.Add ("time to live"' TimeToLive.ToString ());  	properties.Add ("protocol"' Protocol.ToString () + " (0x" + Protocol.ToString ("x") + ")");  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x") + " [" + (ValidChecksum ? "valid" : "invalid") + "]");  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IPv4 - \"Internet Protocol (Version 4)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP:");  }  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add ("differentiated services"' "0x" + DifferentiatedServices.ToString ("x").PadLeft (2' '0'));  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add (""' diffServices.Substring (0' 7) + ".. = [" + (DifferentiatedServices >> 2) + "] code point");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add (" "' ".... .." + diffServices [6] + ". = [" + diffServices [6] + "] ECN");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add ("  "' ".... ..." + diffServices [7] + " = [" + diffServices [7] + "] ECE");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add ("flags"' "0x" + FragmentFlags.ToString ("x").PadLeft (2' '0'));  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  
Magic Number,PacketDotNet,IPv4Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv4Packet.cs,ToString,The following statement contains a magic number: properties.Add ("     "' ".." + flags [2] + " = [" + flags [2] + "] more fragments");  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	string ipVersion = Convert.ToString ((int)Version' 2).PadLeft (4' '0');  	properties.Add ("version"' ipVersion + " .... .... .... .... .... .... .... = " + (int)Version);  	string trafficClass = Convert.ToString (TrafficClass' 2).PadLeft (8' '0').Insert (4' " ");  	properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  	string flowLabel = Convert.ToString (FlowLabel' 2).PadLeft (20' '0').Insert (16' " ").Insert (12' " ").Insert (8' " ").Insert (4' " ");  	properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  	properties.Add ("payload length"' PayloadLength.ToString ());  	properties.Add ("next header"' NextHeader.ToString () + " (0x" + NextHeader.ToString ("x") + ")");  	properties.Add ("hop limit"' HopLimit.ToString ());  	properties.Add ("source"' SourceAddress.ToString ());  	properties.Add ("destination"' DestinationAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IP:  ******* IP - \"Internet Protocol (Version 6)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IP:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("IP: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("IP");  }  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: properties.Add ("traffic class"' ".... " + trafficClass + " .... .... .... .... .... = 0x" + TrafficClass.ToString ("x").PadLeft (8' '0'));  
Magic Number,PacketDotNet,IPv6Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IPv6Packet.cs,ToString,The following statement contains a magic number: properties.Add ("flow label"' ".... .... .... " + flowLabel + " = 0x" + FlowLabel.ToString ("x").PadLeft (8' '0'));  
Magic Number,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Normal || outputFormat == StringOutputType.Colored) {  	// build the output string  	buffer.AppendFormat ("{0}[IGMPv2Packet: Type={2}' MaxResponseTime={3}' GroupAddress={4}]{1}"' color' colorEscape' Type' String.Format ("{0:0.0}"' (MaxResponseTime / 10))' GroupAddress);  }  
Magic Number,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The following statement contains a magic number: buffer.AppendFormat ("{0}[IGMPv2Packet: Type={2}' MaxResponseTime={3}' GroupAddress={4}]{1}"' color' colorEscape' Type' String.Format ("{0:0.0}"' (MaxResponseTime / 10))' GroupAddress);  
Magic Number,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	properties.Add ("type"' Type + " (0x" + Type.ToString ("x") + ")");  	properties.Add ("max response time"' String.Format ("{0:0.0}"' MaxResponseTime / 10) + " sec (0x" + MaxResponseTime.ToString ("x") + ")");  	// TODO: Implement checksum validation for IGMPv2  	properties.Add ("header checksum"' "0x" + Checksum.ToString ("x"));  	properties.Add ("group address"' GroupAddress.ToString ());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("IGMP:  ******* IGMPv2 - \"Internet Group Management Protocol (Version 2)\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("IGMP:");  	foreach (var property in properties) {  		buffer.AppendLine ("IGMP: " + property.Key.PadLeft (padLength) + " = " + property.Value);  	}  	buffer.AppendLine ("IGMP:");  }  
Magic Number,PacketDotNet,IGMPv2Packet,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\IGMPv2Packet.cs,ToString,The following statement contains a magic number: properties.Add ("max response time"' String.Format ("{0:0.0}"' MaxResponseTime / 10) + " sec (0x" + MaxResponseTime.ToString ("x") + ")");  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	// FIXME: The version output is incorrect  	properties.Add (""' Convert.ToString (Version' 2).PadLeft (4' '0') + " .... = version: " + Version.ToString ());  	properties.Add (" "' ".... " + Convert.ToString (Type' 2).PadLeft (4' '0') + " = type: " + Type.ToString ());  	// FIXME: The Code output is incorrect  	properties.Add ("code"' Code.ToString () + " (0x" + Code.ToString ("x") + ")");  	properties.Add ("session id"' "0x" + SessionId.ToString ("x"));  	// TODO: Implement a PayloadLength property for PPPoE  	//properties.Add("payload length"' PayloadLength.ToString());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("PPPoE:  ******* PPPoE - \"Point-to-Point Protocol over Ethernet\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("PPPoE:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("PPPoE:");  }  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	// FIXME: The version output is incorrect  	properties.Add (""' Convert.ToString (Version' 2).PadLeft (4' '0') + " .... = version: " + Version.ToString ());  	properties.Add (" "' ".... " + Convert.ToString (Type' 2).PadLeft (4' '0') + " = type: " + Type.ToString ());  	// FIXME: The Code output is incorrect  	properties.Add ("code"' Code.ToString () + " (0x" + Code.ToString ("x") + ")");  	properties.Add ("session id"' "0x" + SessionId.ToString ("x"));  	// TODO: Implement a PayloadLength property for PPPoE  	//properties.Add("payload length"' PayloadLength.ToString());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("PPPoE:  ******* PPPoE - \"Point-to-Point Protocol over Ethernet\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("PPPoE:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("PPPoE:");  }  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	// FIXME: The version output is incorrect  	properties.Add (""' Convert.ToString (Version' 2).PadLeft (4' '0') + " .... = version: " + Version.ToString ());  	properties.Add (" "' ".... " + Convert.ToString (Type' 2).PadLeft (4' '0') + " = type: " + Type.ToString ());  	// FIXME: The Code output is incorrect  	properties.Add ("code"' Code.ToString () + " (0x" + Code.ToString ("x") + ")");  	properties.Add ("session id"' "0x" + SessionId.ToString ("x"));  	// TODO: Implement a PayloadLength property for PPPoE  	//properties.Add("payload length"' PayloadLength.ToString());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("PPPoE:  ******* PPPoE - \"Point-to-Point Protocol over Ethernet\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("PPPoE:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("PPPoE:");  }  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: if (outputFormat == StringOutputType.Verbose || outputFormat == StringOutputType.VerboseColored) {  	// collect the properties and their value  	Dictionary<string' string> properties = new Dictionary<string' string> ();  	// FIXME: The version output is incorrect  	properties.Add (""' Convert.ToString (Version' 2).PadLeft (4' '0') + " .... = version: " + Version.ToString ());  	properties.Add (" "' ".... " + Convert.ToString (Type' 2).PadLeft (4' '0') + " = type: " + Type.ToString ());  	// FIXME: The Code output is incorrect  	properties.Add ("code"' Code.ToString () + " (0x" + Code.ToString ("x") + ")");  	properties.Add ("session id"' "0x" + SessionId.ToString ("x"));  	// TODO: Implement a PayloadLength property for PPPoE  	//properties.Add("payload length"' PayloadLength.ToString());  	// calculate the padding needed to right-justify the property names  	int padLength = Utils.RandomUtils.LongestStringLength (new List<string> (properties.Keys));  	// build the output string  	buffer.AppendLine ("PPPoE:  ******* PPPoE - \"Point-to-Point Protocol over Ethernet\" - offset=? length=" + TotalPacketLength);  	buffer.AppendLine ("PPPoE:");  	foreach (var property in properties) {  		if (property.Key.Trim () != "") {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + " = " + property.Value);  		}  		else {  			buffer.AppendLine ("PPPoE: " + property.Key.PadLeft (padLength) + "   " + property.Value);  		}  	}  	buffer.AppendLine ("PPPoE:");  }  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: properties.Add (""' Convert.ToString (Version' 2).PadLeft (4' '0') + " .... = version: " + Version.ToString ());  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: properties.Add (""' Convert.ToString (Version' 2).PadLeft (4' '0') + " .... = version: " + Version.ToString ());  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: properties.Add (" "' ".... " + Convert.ToString (Type' 2).PadLeft (4' '0') + " = type: " + Type.ToString ());  
Magic Number,PacketDotNet,PPPoEPacket,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\PacketDotNet\PPPoEPacket.cs,ToString,The following statement contains a magic number: properties.Add (" "' ".... " + Convert.ToString (Type' 2).PadLeft (4' '0') + " = type: " + Type.ToString ());  
Magic Number,PacketDotNet.Utils,AnsiEscapeSequences,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\AnsiEscapeSequences.cs,AnsiEscapeSequences,The following statement contains a magic number: EscapeBegin = "" + (char)27 + "[";  
Magic Number,PacketDotNet.Utils,ChecksumUtils,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\ChecksumUtils.cs,OnesSum,The following statement contains a magic number: while ((sum >> 16) != 0) {  	sum = (sum & 0xffff) + (sum >> 16);  }  
Magic Number,PacketDotNet.Utils,ChecksumUtils,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\ChecksumUtils.cs,OnesSum,The following statement contains a magic number: while ((sum >> 16) != 0) {  	sum = (sum & 0xffff) + (sum >> 16);  }  
Magic Number,PacketDotNet.Utils,ChecksumUtils,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\ChecksumUtils.cs,OnesSum,The following statement contains a magic number: sum = (sum & 0xffff) + (sum >> 16);  
Magic Number,PacketDotNet.Utils,HexPrinter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\HexPrinter.cs,PrintMACAddress,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  	output += bytes [i].ToString ("x").PadLeft (2' '0') + ":";  }  
Magic Number,PacketDotNet.Utils,HexPrinter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\Utils\HexPrinter.cs,PrintMACAddress,The following statement contains a magic number: output += bytes [i].ToString ("x").PadLeft (2' '0') + ":";  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,EndianBinaryReader,The following statement contains a magic number: if (encoding is UnicodeEncoding) {  	minBytesPerChar = 2;  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,EndianBinaryReader,The following statement contains a magic number: minBytesPerChar = 2;  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadInt16,The following statement contains a magic number: ReadInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadInt32,The following statement contains a magic number: ReadInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadInt64,The following statement contains a magic number: ReadInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadUInt16,The following statement contains a magic number: ReadInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadUInt32,The following statement contains a magic number: ReadInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadUInt64,The following statement contains a magic number: ReadInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadSingle,The following statement contains a magic number: ReadInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadDouble,The following statement contains a magic number: ReadInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadDecimal,The following statement contains a magic number: ReadInternal (buffer' 16);  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read,The following statement contains a magic number: if (byteBuffer.Length < count * minBytesPerChar) {  	byteBuffer = new byte[4096];  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read,The following statement contains a magic number: byteBuffer = new byte[4096];  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: for (int shift = 0; shift < 35; shift += 7) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = ret | ((b & 0x7f) << shift);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: for (int shift = 0; shift < 35; shift += 7) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = ret | ((b & 0x7f) << shift);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: shift += 7
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = (ret << 7) | (b & 0x7f);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = (ret << 7) | (b & 0x7f);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: ret = (ret << 7) | (b & 0x7f);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 16);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (value >= 128) {  	buffer [index++] = (byte)((value & 0x7f) | 0x80);  	value = value >> 7;  	index++;  }  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (value >= 128) {  	buffer [index++] = (byte)((value & 0x7f) | 0x80);  	value = value >> 7;  	index++;  }  
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\IO\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: value = value >> 7;  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i = 0; i < bytes; i++) {  	buffer [endOffset - i] = unchecked((byte)(value & 0xff));  	value = value >> 8;  }  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: value = value >> 8;  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < bytesToConvert; i++) {  	ret = unchecked((ret << 8) | buffer [startIndex + i]);  }  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: ret = unchecked((ret << 8) | buffer [startIndex + i]);  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: if (exponent == 0) {  	exponent++;  }  // Normal numbers; leave exponent as it is but add extra  // bit to the front of the mantissa  else {  	mantissa = mantissa | (1L << 52);  }  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: mantissa = mantissa | (1L << 52);  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: exponent -= 1075;  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: if (exponent < 0) {  	for (int i = 0; i < -exponent; i++)  		ad.MultiplyBy (5);  	ad.Shift (-exponent);  }  // Otherwise' we need to repeatedly multiply by 2  else {  	for (int i = 0; i < exponent; i++)  		ad.MultiplyBy (2);  }  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: if (exponent < 0) {  	for (int i = 0; i < -exponent; i++)  		ad.MultiplyBy (5);  	ad.Shift (-exponent);  }  // Otherwise' we need to repeatedly multiply by 2  else {  	for (int i = 0; i < exponent; i++)  		ad.MultiplyBy (2);  }  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: for (int i = 0; i < -exponent; i++)  	ad.MultiplyBy (5);  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: ad.MultiplyBy (5);  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: for (int i = 0; i < exponent; i++)  	ad.MultiplyBy (2);  
Magic Number,MiscUtil.Conversion,DoubleConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\DoubleConverter.cs,ToExactString,The following statement contains a magic number: ad.MultiplyBy (2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToChar,The following statement contains a magic number: return unchecked((char)(CheckedFromBytes (value' startIndex' 2)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToInt16,The following statement contains a magic number: return unchecked((short)(CheckedFromBytes (value' startIndex' 2)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToInt32,The following statement contains a magic number: return unchecked((int)(CheckedFromBytes (value' startIndex' 4)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return CheckedFromBytes (value' startIndex' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return unchecked((ushort)(CheckedFromBytes (value' startIndex' 2)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return unchecked((uint)(CheckedFromBytes (value' startIndex' 4)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return unchecked((ulong)(CheckedFromBytes (value' startIndex' 8)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	parts [i] = ToInt32 (value' startIndex + i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	parts [i] = ToInt32 (value' startIndex + i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: parts [i] = ToInt32 (value' startIndex + i * 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' bytes' i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' bytes' i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' bytes' i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' bytes' i * 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' bytes' i * 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (DoubleToInt64Bits (value)' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (SingleToInt32Bits (value)' 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (unchecked((long)value)' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 2' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (DoubleToInt64Bits (value)' 8' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 2' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 4' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 8' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (SingleToInt32Bits (value)' 4' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 2' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 4' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (unchecked((long)value)' 8' buffer' index);  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i = 0; i < bytes; i++) {  	buffer [i + index] = unchecked((byte)(value & 0xff));  	value = value >> 8;  }  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: value = value >> 8;  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < bytesToConvert; i++) {  	ret = unchecked((ret << 8) | buffer [startIndex + bytesToConvert - 1 - i]);  }  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,C:\repos\dan-sw_PTP_GUI\PacketDotNet\PacketDotNet\MiscUtil\Conversion\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: ret = unchecked((ret << 8) | buffer [startIndex + bytesToConvert - 1 - i]);  
