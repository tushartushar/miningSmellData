Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpPcap.LibPcap,PcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapDeviceCaptureLoop.cs,CaptureThread,The method has 121 lines of code.
Complex Method,SharpPcap,ARP,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\ARP.cs,Resolve,Cyclomatic complexity of the method is 17
Complex Method,SharpPcap.LibPcap,PcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapDeviceCaptureLoop.cs,CaptureThread,Cyclomatic complexity of the method is 20
Complex Method,SharpPcap.LibPcap,PcapStatistics,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapStatistics.cs,PcapStatistics,Cyclomatic complexity of the method is 8
Long Parameter List,SharpPcap.LibPcap,LibPcapSafeNativeMethods,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\LibPcapSafeNativeMethods.cs,pcap_open_live,The method has 5 parameters.
Long Parameter List,SharpPcap.LibPcap,LibPcapSafeNativeMethods,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\LibPcapSafeNativeMethods.cs,pcap_compile,The method has 5 parameters.
Long Parameter List,SharpPcap.WinPcap,SafeNativeMethods,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\WinPcap\SafeNativeMethods.cs,pcap_open,The method has 6 parameters.
Long Statement,SharpPcap.AirPcap,AirPcapChannelInfo,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapChannelInfo.cs,ToString,The length of the statement  "	return string.Format ("[AirPcapChannelInfo Frequency: {0}' ExtChannel: {1}' Flags: {2}]"' Frequency' ExtChannel' Flags); " is 120.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,KeyCollectionSize,The length of the statement  "	int memorySize = (int)(Marshal.SizeOf (typeof(AirPcapUnmanagedStructures.AirpcapKeysCollection)) + (Marshal.SizeOf (typeof(AirPcapUnmanagedStructures.AirpcapKey)) * keyCount)); " is 176.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,IntPtrToKeys,The length of the statement  "	var keysCollection = (AirPcapUnmanagedStructures.AirpcapKeysCollection)Marshal.PtrToStructure (pKeysCollection' typeof(AirPcapUnmanagedStructures.AirpcapKeysCollection)); " is 170.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,IntPtrToKeys,The length of the statement  "	IntPtr pKeys = new IntPtr (pKeysCollection.ToInt64 () + Marshal.SizeOf (typeof(AirPcapUnmanagedStructures.AirpcapKeysCollection))); " is 131.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,IntPtrToKeys,The length of the statement  "		var airpcapKey = (AirPcapUnmanagedStructures.AirpcapKey)Marshal.PtrToStructure (pKeys' typeof(AirPcapUnmanagedStructures.AirpcapKey)); " is 134.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,KeysToIntPtr,The length of the statement  "	pKeyCollectionPosition = new IntPtr (pKeyCollectionPosition.ToInt64 () + Marshal.SizeOf (typeof(AirPcapUnmanagedStructures.AirpcapKeysCollection))); " is 148.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,KeysToIntPtr,The length of the statement  "		pKeyCollectionPosition = new IntPtr (pKeyCollectionPosition.ToInt64 () + Marshal.SizeOf (typeof(AirPcapUnmanagedStructures.AirpcapKey))); " is 137.
Long Statement,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,CaptureThread,The length of the statement  "		if (!AirPcapSafeNativeMethods.AirpcapRead (AirPcapDeviceHandle' packetBuffer' (uint)packetBufferSize' out BytesReceived)) { " is 123.
Long Statement,SharpPcap.AirPcap,AirPcapDeviceCapabilities,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDeviceCapabilities.cs,ToString,The length of the statement  "	return string.Format ("[AirPcapDeviceCapabilities AdapterId: {0}' AdapterModelName: {1}' AdapterBus: {2}'" + " CanTransmit: {3}' CanSetTransmitPower: {4}' ExternalAntennaPlug: {5}'" + " SupportedMedia: {6}' SupportedBands: {7}]"' AdapterId' AdapterModelName' AdapterBus' CanTransmit' CanSetTransmitPower' ExternalAntennaPlug' SupportedMedia' SupportedBands); " is 358.
Long Statement,SharpPcap.AirPcap,AirPcapDeviceList,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDeviceList.cs,GetAirPcapDevices,The length of the statement  "		AirPcapUnmanagedStructures.AirpcapDeviceDescription deviceDescUnmanaged = (AirPcapUnmanagedStructures.AirpcapDeviceDescription)Marshal.PtrToStructure (nextDevPtr' typeof(AirPcapUnmanagedStructures.AirpcapDeviceDescription)); " is 224.
Long Statement,SharpPcap.AirPcap,AirPcapDeviceTimestamp,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDeviceTimestamp.cs,ToString,The length of the statement  "	return string.Format ("[AirPcapDeviceTimestamp DeviceTimestamp {0}' SoftwareTimestampBefore {1}' SoftwareTimestampAfter {2}"' DeviceTimestamp' SoftwareTimestampBefore' SoftwareTimestampAfter); " is 192.
Long Statement,SharpPcap.AirPcap,AirPcapPacketHeader,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapPacketHeader.cs,ToString,The length of the statement  "	return string.Format ("TsSec {0}' TsUSec {1}' Caplen {2}' Originallen {3}' Hdrlen {4}"' TsSec' TsUsec' Caplen' Originallen' Hdrlen); " is 132.
Long Statement,SharpPcap,CaptureDeviceList,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\CaptureDeviceList.cs,GetDevices,The length of the statement  "	if ((Environment.OSVersion.Platform == PlatformID.Win32NT) || (Environment.OSVersion.Platform == PlatformID.Win32Windows)) { " is 124.
Long Statement,SharpPcap,ARP,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\ARP.cs,BuildRequest,The length of the statement  "	var ethernetPacket = new PacketDotNet.EthernetPacket (localMac' PhysicalAddress.Parse ("FF-FF-FF-FF-FF-FF")' PacketDotNet.EthernetPacketType.Arp); " is 146.
Long Statement,SharpPcap,ARP,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\ARP.cs,BuildRequest,The length of the statement  "	var arpPacket = new PacketDotNet.ARPPacket (PacketDotNet.ARPOperation.Request' PhysicalAddress.Parse ("00-00-00-00-00-00")' destinationIP' localMac' localIP); " is 158.
Long Statement,SharpPcap.LibPcap,PcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapDeviceCaptureLoop.cs,StopCapture,The length of the statement  "				error = string.Format ("captureThread was aborted after {0}. Using a Mono" + " version >= 2.4 and installing Mono.Posix should" + " enable smooth thread shutdown"' StopCaptureTimeout.ToString ()); " is 196.
Long Statement,SharpPcap.LibPcap,PcapStatistics,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapStatistics.cs,ToString,The length of the statement  "	return string.Format ("[PcapStatistics: ReceivedPackets={0}' DroppedPackets={1}' InterfaceDroppedPackets={2}]"' ReceivedPackets' DroppedPackets' InterfaceDroppedPackets); " is 170.
Long Statement,SharpPcap.LibPcap,LibPcapLiveDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\LibPcapLiveDevice.cs,SendPacket,The length of the statement  "		throw new ArgumentException ("Invalid packetSize value: " + size + "\nArgument size is larger than the total size of the packet."); " is 131.
Long Statement,SharpPcap.LibPcap,LibPcapLiveDeviceList,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\LibPcapLiveDeviceList.cs,GetDevices,The length of the statement  "		PcapUnmanagedStructures.pcap_if pcap_if_unmanaged = (PcapUnmanagedStructures.pcap_if)Marshal.PtrToStructure (nextDevPtr' typeof(PcapUnmanagedStructures.pcap_if)); " is 162.
Long Statement,SharpPcap.WinPcap,WinPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\WinPcap\WinPcapDevice.cs,StartCapture,The length of the statement  "			throw new DeviceNotReadyException ("No delegates assigned to OnPacketArrival or OnPcapStatistics' no where for captured packets to go."); " is 137.
Long Statement,SharpPcap.WinPcap,WinPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\WinPcap\WinPcapDevice.cs,ThrowIfNotWinPcap,The length of the statement  "	if ((Environment.OSVersion.Platform != PlatformID.Win32NT) && (Environment.OSVersion.Platform != PlatformID.Win32Windows)) { " is 124.
Long Statement,SharpPcap.WinPcap,WinPcapDeviceList,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\WinPcap\WinPcapDeviceList.cs,Devices,The length of the statement  "		var pcap_if_unmanaged = (LibPcap.PcapUnmanagedStructures.pcap_if)Marshal.PtrToStructure (nextDevPtr' typeof(LibPcap.PcapUnmanagedStructures.pcap_if)); " is 150.
Magic Number,SharpPcap.AirPcap,AirPcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\AirPcap\AirPcapDevice.cs,MarshalPackets,The following statement contains a magic number: while (bufferPointer.ToInt64 () < bufferEnd.ToInt64 ()) {  	// marshal the header  	var header = new AirPcapPacketHeader (bufferPointer);  	// advance the pointer to the packet data and marshal that data  	// into a managed buffer  	bufferPointer = new IntPtr (bufferPointer.ToInt64 () + header.Hdrlen);  	var pkt_data = new byte[header.Caplen];  	Marshal.Copy (bufferPointer' pkt_data' 0' (int)header.Caplen);  	p = new RawCapture (linkType' new PosixTimeval (header.TsSec' header.TsUsec)' pkt_data);  	packets.Add (p);  	// advance the pointer by the size of the data  	// and round up to the next word offset since each frame header is on a word boundry  	int alignment = 4;  	var pointer = bufferPointer.ToInt64 () + header.Caplen;  	pointer = AirPcapDevice.RoundUp (pointer' alignment);  	bufferPointer = new IntPtr (pointer);  }  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,isUnix,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128)) {  	return true;  }  else {  	return false;  }  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,isUnix,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128)) {  	return true;  }  else {  	return false;  }  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,isUnix,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128)) {  	return true;  }  else {  	return false;  }  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,Pcap,The following statement contains a magic number: AF_INET = 2;  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,Pcap,The following statement contains a magic number: AF_PACKET = 17;  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,Pcap,The following statement contains a magic number: if (isUnix ()) {  	AF_INET6 = 10;  	// value for linux from socket.h  }  else {  	AF_INET6 = 23;  	// value for windows from winsock.h  }  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,Pcap,The following statement contains a magic number: if (isUnix ()) {  	AF_INET6 = 10;  	// value for linux from socket.h  }  else {  	AF_INET6 = 23;  	// value for windows from winsock.h  }  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,Pcap,The following statement contains a magic number: AF_INET6 = 10;  
Magic Number,SharpPcap,Pcap,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\Pcap.cs,Pcap,The following statement contains a magic number: AF_INET6 = 23;  
Magic Number,SharpPcap,ARP,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\ARP.cs,Resolve,The following statement contains a magic number: device.Open (DeviceMode.Promiscuous' 20);  
Magic Number,SharpPcap,PosixTimeval,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\PosixTimeval.cs,DateTimeToUnixTimeVal,The following statement contains a magic number: tvSec = (UInt64)(timeSpan.TotalMilliseconds / 1000.0);  
Magic Number,SharpPcap,PosixTimeval,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\PosixTimeval.cs,DateTimeToUnixTimeVal,The following statement contains a magic number: tvUsec = (UInt64)((timeSpan.TotalMilliseconds - (tvSec * 1000)) * 1000);  
Magic Number,SharpPcap,PosixTimeval,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\PosixTimeval.cs,DateTimeToUnixTimeVal,The following statement contains a magic number: tvUsec = (UInt64)((timeSpan.TotalMilliseconds - (tvSec * 1000)) * 1000);  
Magic Number,SharpPcap.LibPcap,PcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapDeviceCaptureLoop.cs,CaptureThread,The following statement contains a magic number: if (usePoll) {  	#if UseMonoUnixNativeDirectly  	                pollFds[0].fd = captureFileDescriptor;                 pollFds[0].events = PollEvents.POLLPRI | Mono.Unix.Native.PollEvents.POLLIN; #else  	FieldInfo field;  	pollFds = Array.CreateInstance (PollfdType' 1);  	// create a PollFd struct instance  	var pollFd = Activator.CreateInstance (PollfdType);  	// set the descriptor field  	field = PollfdType.GetField ("fd");  	field.SetValue (pollFd' captureFileDescriptor);  	// set the events field  	short eventValue = (short)(POLLIN | POLLPRI);  	// mask the two together  	field = PollfdType.GetField ("events");  	field.SetValue (pollFd' eventValue);  	// set the Pollfd entry  	pollFds.SetValue (pollFd' 0);  	// setup the parameters we will pass to the poll() method  	PollParameters = new object[2];  	PollParameters [0] = pollFds;  	PollParameters [1] = millisecondTimeout;  	#endif  }  
Magic Number,SharpPcap.LibPcap,PcapDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapDeviceCaptureLoop.cs,CaptureThread,The following statement contains a magic number: PollParameters = new object[2];  
Magic Number,SharpPcap.LibPcap,Sockaddr,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\Sockaddr.cs,Sockaddr,The following statement contains a magic number: if (saddr.sa_family == Pcap.AF_INET) {  	type = Type.AF_INET_AF_INET6;  	PcapUnmanagedStructures.sockaddr_in saddr_in = (PcapUnmanagedStructures.sockaddr_in)Marshal.PtrToStructure (sockaddrPtr' typeof(PcapUnmanagedStructures.sockaddr_in));  	ipAddress = new System.Net.IPAddress (saddr_in.sin_addr.s_addr);  }  else if (saddr.sa_family == Pcap.AF_INET6) {  	type = Type.AF_INET_AF_INET6;  	addressBytes = new byte[16];  	PcapUnmanagedStructures.sockaddr_in6 sin6 = (PcapUnmanagedStructures.sockaddr_in6)Marshal.PtrToStructure (sockaddrPtr' typeof(PcapUnmanagedStructures.sockaddr_in6));  	Array.Copy (sin6.sin6_addr' addressBytes' addressBytes.Length);  	ipAddress = new System.Net.IPAddress (addressBytes);  }  else if (saddr.sa_family == Pcap.AF_PACKET) {  	type = Type.HARDWARE;  	PcapUnmanagedStructures.sockaddr_ll saddr_ll = (PcapUnmanagedStructures.sockaddr_ll)Marshal.PtrToStructure (sockaddrPtr' typeof(PcapUnmanagedStructures.sockaddr_ll));  	byte[] hardwareAddressBytes = new byte[saddr_ll.sll_halen];  	for (int x = 0; x < saddr_ll.sll_halen; x++) {  		hardwareAddressBytes [x] = saddr_ll.sll_addr [x];  	}  	hardwareAddress = new PhysicalAddress (hardwareAddressBytes);  	// copy into the PhysicalAddress class  }  else {  	type = Type.UNKNOWN;  	// place the sockaddr.sa_data into the hardware address just in case  	// someone wants access to the bytes  	byte[] hardwareAddressBytes = new byte[saddr.sa_data.Length];  	for (int x = 0; x < saddr.sa_data.Length; x++) {  		hardwareAddressBytes [x] = saddr.sa_data [x];  	}  	hardwareAddress = new PhysicalAddress (hardwareAddressBytes);  }  
Magic Number,SharpPcap.LibPcap,Sockaddr,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\Sockaddr.cs,Sockaddr,The following statement contains a magic number: if (saddr.sa_family == Pcap.AF_INET6) {  	type = Type.AF_INET_AF_INET6;  	addressBytes = new byte[16];  	PcapUnmanagedStructures.sockaddr_in6 sin6 = (PcapUnmanagedStructures.sockaddr_in6)Marshal.PtrToStructure (sockaddrPtr' typeof(PcapUnmanagedStructures.sockaddr_in6));  	Array.Copy (sin6.sin6_addr' addressBytes' addressBytes.Length);  	ipAddress = new System.Net.IPAddress (addressBytes);  }  else if (saddr.sa_family == Pcap.AF_PACKET) {  	type = Type.HARDWARE;  	PcapUnmanagedStructures.sockaddr_ll saddr_ll = (PcapUnmanagedStructures.sockaddr_ll)Marshal.PtrToStructure (sockaddrPtr' typeof(PcapUnmanagedStructures.sockaddr_ll));  	byte[] hardwareAddressBytes = new byte[saddr_ll.sll_halen];  	for (int x = 0; x < saddr_ll.sll_halen; x++) {  		hardwareAddressBytes [x] = saddr_ll.sll_addr [x];  	}  	hardwareAddress = new PhysicalAddress (hardwareAddressBytes);  	// copy into the PhysicalAddress class  }  else {  	type = Type.UNKNOWN;  	// place the sockaddr.sa_data into the hardware address just in case  	// someone wants access to the bytes  	byte[] hardwareAddressBytes = new byte[saddr.sa_data.Length];  	for (int x = 0; x < saddr.sa_data.Length; x++) {  		hardwareAddressBytes [x] = saddr.sa_data [x];  	}  	hardwareAddress = new PhysicalAddress (hardwareAddressBytes);  }  
Magic Number,SharpPcap.LibPcap,Sockaddr,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\Sockaddr.cs,Sockaddr,The following statement contains a magic number: addressBytes = new byte[16];  
Magic Number,SharpPcap.LibPcap,LibPcapLiveDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\LibPcapLiveDevice.cs,Open,The following statement contains a magic number: if (!Opened) {  	StringBuilder errbuf = new StringBuilder (Pcap.PCAP_ERRBUF_SIZE);  	//will hold errors  	// set the StopCaptureTimeout value to twice the read timeout to ensure that  	// we wait long enough before considering the capture thread to be stuck when stopping  	// a background capture via StopCapture()  	//  	// NOTE: Doesn't affect Mono if unix poll is available' doesn't affect Linux because  	//       Linux devices have no timeout' they always block. Only affects Windows devices.  	StopCaptureTimeout = new TimeSpan (0' 0' 0' 0' read_timeout * 2);  	PcapHandle = LibPcapSafeNativeMethods.pcap_open_live (Name' // name of the device  	Pcap.MAX_PACKET_SIZE' // portion of the packet to capture.   	// MAX_PACKET_SIZE (65536) grants that the whole packet will be captured on all the MACs.  	(short)mode' // promiscuous mode  	(short)read_timeout' // read timeout  	errbuf);  	// error buffer  	if (PcapHandle == IntPtr.Zero) {  		string err = "Unable to open the adapter (" + Name + "). " + errbuf.ToString ();  		throw new PcapException (err);  	}  }  
Magic Number,SharpPcap.LibPcap,LibPcapLiveDevice,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\LibPcapLiveDevice.cs,Open,The following statement contains a magic number: StopCaptureTimeout = new TimeSpan (0' 0' 0' 0' read_timeout * 2);  
Missing Default,SharpPcap.LibPcap,PcapStatistics,C:\repos\dan-sw_PTP_GUI\SharpPcap\SharpPcap\LibPcap\PcapStatistics.cs,PcapStatistics,The following switch statement is missing a default case: switch (result) {  case PcapUnmanagedStructures.PcapStatReturnValue.Error:  	// retrieve the error information  	var error = LibPcapLiveDevice.GetLastError (pcap_t);  	// free the stats memory so we don't leak before we throw  	Marshal.FreeHGlobal (stat);  	throw new StatisticsException (error);  case PcapUnmanagedStructures.PcapStatReturnValue.Success:  	// nothing to do upon success  	break;  }  
