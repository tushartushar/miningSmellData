Implementation smell,Namespace,Class,File,Method,Description
Long Statement,QueuingPacketsForBackgroundProcessing,MainClass,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\QueuingPacketsForBackgroundProcessing\Main.cs,BackgroundThread,The length of the statement  "				Console.WriteLine ("BackgroundThread: {0}:{1}:{2}'{3} Len={4}"' time.Hour' time.Minute' time.Second' time.Millisecond' len); " is 124.
Magic Number,QueuingPacketsForBackgroundProcessing,MainClass,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\QueuingPacketsForBackgroundProcessing\Main.cs,BackgroundThread,The following statement contains a magic number: while (!BackgroundThreadStop) {  	bool shouldSleep = true;  	lock (QueueLock) {  		if (PacketQueue.Count != 0) {  			shouldSleep = false;  		}  	}  	if (shouldSleep) {  		System.Threading.Thread.Sleep (250);  	}  	else// should process the queue  	 {  		List<RawCapture> ourQueue;  		lock (QueueLock) {  			// swap queues' giving the capture callback a new one  			ourQueue = PacketQueue;  			PacketQueue = new List<RawCapture> ();  		}  		Console.WriteLine ("BackgroundThread: ourQueue.Count is {0}"' ourQueue.Count);  		foreach (var packet in ourQueue) {  			var time = packet.Timeval.Date;  			var len = packet.Data.Length;  			Console.WriteLine ("BackgroundThread: {0}:{1}:{2}'{3} Len={4}"' time.Hour' time.Minute' time.Second' time.Millisecond' len);  		}  		// Here is where we can process our packets freely without  		// holding off packet capture.  		//  		// NOTE: If the incoming packet rate is greater than  		//       the packet processing rate these queues will grow  		//       to enormous sizes. Packets should be dropped in these  		//       cases  	}  }  
Magic Number,QueuingPacketsForBackgroundProcessing,MainClass,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\QueuingPacketsForBackgroundProcessing\Main.cs,BackgroundThread,The following statement contains a magic number: if (shouldSleep) {  	System.Threading.Thread.Sleep (250);  }  else// should process the queue   {  	List<RawCapture> ourQueue;  	lock (QueueLock) {  		// swap queues' giving the capture callback a new one  		ourQueue = PacketQueue;  		PacketQueue = new List<RawCapture> ();  	}  	Console.WriteLine ("BackgroundThread: ourQueue.Count is {0}"' ourQueue.Count);  	foreach (var packet in ourQueue) {  		var time = packet.Timeval.Date;  		var len = packet.Data.Length;  		Console.WriteLine ("BackgroundThread: {0}:{1}:{2}'{3} Len={4}"' time.Hour' time.Minute' time.Second' time.Millisecond' len);  	}  	// Here is where we can process our packets freely without  	// holding off packet capture.  	//  	// NOTE: If the incoming packet rate is greater than  	//       the packet processing rate these queues will grow  	//       to enormous sizes. Packets should be dropped in these  	//       cases  }  
Magic Number,QueuingPacketsForBackgroundProcessing,MainClass,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\QueuingPacketsForBackgroundProcessing\Main.cs,BackgroundThread,The following statement contains a magic number: System.Threading.Thread.Sleep (250);  
