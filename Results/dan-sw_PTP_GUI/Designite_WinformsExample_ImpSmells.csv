Implementation smell,Namespace,Class,File,Method,Description
Long Statement,WinformsExample,CaptureForm,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\WinformsExample\CaptureForm.cs,BackgroundThread,The length of the statement  "				Console.WriteLine ("BackgroundThread: {0}:{1}:{2}'{3} Len={4}"' time.Hour' time.Minute' time.Second' time.Millisecond' len); " is 124.
Long Statement,WinformsExample,CaptureForm,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\WinformsExample\CaptureForm.cs,UpdateCaptureStatistics,The length of the statement  "	captureStatisticsToolStripStatusLabel.Text = string.Format ("Received packets: {0}' Dropped packets: {1}' Interface dropped packets: {2}"' captureStatistics.ReceivedPackets' captureStatistics.DroppedPackets' captureStatistics.InterfaceDroppedPackets); " is 251.
Magic Number,WinformsExample,CaptureForm,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\WinformsExample\CaptureForm.cs,BackgroundThread,The following statement contains a magic number: while (!BackgroundThreadStop) {  	bool shouldSleep = true;  	lock (QueueLock) {  		if (PacketQueue.Count != 0) {  			shouldSleep = false;  		}  	}  	if (shouldSleep) {  		System.Threading.Thread.Sleep (250);  	}  	else// should process the queue  	 {  		List<RawCapture> ourQueue;  		lock (QueueLock) {  			// swap queues' giving the capture callback a new one  			ourQueue = PacketQueue;  			PacketQueue = new List<RawCapture> ();  		}  		Console.WriteLine ("BackgroundThread: ourQueue.Count is {0}"' ourQueue.Count);  		foreach (var packet in ourQueue) {  			// Here is where we can process our packets freely without  			// holding off packet capture.  			//  			// NOTE: If the incoming packet rate is greater than  			//       the packet processing rate these queues will grow  			//       to enormous sizes. Packets should be dropped in these  			//       cases  			var packetWrapper = new PacketWrapper (packetCount' packet);  			this.BeginInvoke (new MethodInvoker (delegate {  				packetStrings.Enqueue (packetWrapper);  			}));  			packetCount++;  			var time = packet.Timeval.Date;  			var len = packet.Data.Length;  			Console.WriteLine ("BackgroundThread: {0}:{1}:{2}'{3} Len={4}"' time.Hour' time.Minute' time.Second' time.Millisecond' len);  		}  		this.BeginInvoke (new MethodInvoker (delegate {  			bs.DataSource = packetStrings.Reverse ();  		}));  		if (statisticsUiNeedsUpdate) {  			UpdateCaptureStatistics ();  			statisticsUiNeedsUpdate = false;  		}  	}  }  
Magic Number,WinformsExample,CaptureForm,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\WinformsExample\CaptureForm.cs,BackgroundThread,The following statement contains a magic number: if (shouldSleep) {  	System.Threading.Thread.Sleep (250);  }  else// should process the queue   {  	List<RawCapture> ourQueue;  	lock (QueueLock) {  		// swap queues' giving the capture callback a new one  		ourQueue = PacketQueue;  		PacketQueue = new List<RawCapture> ();  	}  	Console.WriteLine ("BackgroundThread: ourQueue.Count is {0}"' ourQueue.Count);  	foreach (var packet in ourQueue) {  		// Here is where we can process our packets freely without  		// holding off packet capture.  		//  		// NOTE: If the incoming packet rate is greater than  		//       the packet processing rate these queues will grow  		//       to enormous sizes. Packets should be dropped in these  		//       cases  		var packetWrapper = new PacketWrapper (packetCount' packet);  		this.BeginInvoke (new MethodInvoker (delegate {  			packetStrings.Enqueue (packetWrapper);  		}));  		packetCount++;  		var time = packet.Timeval.Date;  		var len = packet.Data.Length;  		Console.WriteLine ("BackgroundThread: {0}:{1}:{2}'{3} Len={4}"' time.Hour' time.Minute' time.Second' time.Millisecond' len);  	}  	this.BeginInvoke (new MethodInvoker (delegate {  		bs.DataSource = packetStrings.Reverse ();  	}));  	if (statisticsUiNeedsUpdate) {  		UpdateCaptureStatistics ();  		statisticsUiNeedsUpdate = false;  	}  }  
Magic Number,WinformsExample,CaptureForm,C:\repos\dan-sw_PTP_GUI\SharpPcap\Examples\WinformsExample\CaptureForm.cs,BackgroundThread,The following statement contains a magic number: System.Threading.Thread.Sleep (250);  
