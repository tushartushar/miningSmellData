Implementation smell,Namespace,Class,File,Method,Description
Long Method,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadObject,The method has 144 lines of code.
Complex Method,DotAmf.Encoder,Amf0Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf0Encoder.cs,WriteObject,Cyclomatic complexity of the method is 9
Complex Method,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteObject,Cyclomatic complexity of the method is 8
Complex Method,DotAmf.Encoder,AmfPacketEncoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\AmfPacketEncoder.cs,Encode,Cyclomatic complexity of the method is 14
Complex Method,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadArray,Cyclomatic complexity of the method is 8
Complex Method,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,DeserializePacket,Cyclomatic complexity of the method is 11
Complex Method,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,ReadObject,Cyclomatic complexity of the method is 8
Complex Method,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,Serialize,Cyclomatic complexity of the method is 8
Complex Method,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,WriteDataContract,Cyclomatic complexity of the method is 9
Complex Method,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,GetAmfxType,Cyclomatic complexity of the method is 9
Long Parameter List,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,WriteDataContract,The method has 5 parameters. Parameters: writer' graph' type' context' isDataContract
Long Statement,DotAmf.Encoder,Amf0Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf0Encoder.cs,WriteAmfValue,The length of the statement  "                throw new InvalidOperationException(string.Format(Errors.Amf0Decoder_ReadAmfValue_AmfVersionNotSupported' context.AmfVersion)); " is 127.
Long Statement,DotAmf.Encoder,Amf0Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf0Encoder.cs,WriteAmfValue,The length of the statement  "            if (input.NodeType != XmlNodeType.Element) throw new XmlException(string.Format("Element node expected' {0} found."' input.NodeType)); " is 134.
Long Statement,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteAmfValue,The length of the statement  "            if (input.NodeType != XmlNodeType.Element) throw new XmlException(string.Format("Element node expected' {0} found."' input.NodeType)); " is 134.
Long Statement,DotAmf.Decoder,Amf0Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf0Decoder.cs,ReadAmfValue,The length of the statement  "                throw new InvalidOperationException(string.Format(Errors.Amf0Decoder_ReadAmfValue_AmfVersionNotSupported' context.AmfVersion)); " is 127.
Long Statement,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadAmfValue,The length of the statement  "                throw new FormatException(string.Format(Errors.Amf3Decoder_ReadValue_TypeMarkerNotFound' reader.BaseStream.Position)' e); " is 121.
Long Statement,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,WriteObject,The length of the statement  "            if (!stream.CanWrite) throw new ArgumentException(Errors.DataContractAmfSerializer_WriteObject_InvalidStream' "stream"); " is 120.
Long Statement,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,Deserialize,The length of the statement  "            if (reader.NodeType != XmlNodeType.Element) throw new XmlException(string.Format("Element node expected' {0} found."' reader.NodeType)); " is 136.
Long Statement,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,ReadObject,The length of the statement  "                result = DataContractHelper.InstantiateContract(typeDescriptor.Type' properties' typeDescriptor.PropertyMap' typeDescriptor.FieldMap); " is 134.
Long Statement,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,WriteString,The length of the statement  "            if (value == string.Empty || context.AmfVersion != AmfVersion.Amf3 || (index = context.StringReferences.IndexOf(value)) == -1) " is 126.
Long Statement,DotAmf.Serialization,DataContractHelper,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractHelper.cs,GetContractAlias,The length of the statement  "            throw new ArgumentException(string.Format(Errors.DataContractUtil_GetContractAlias_InvalidContract' type.FullName)' "type"); " is 124.
Magic Number,DotAmf.IO,AmfStreamReader,C:\repos\artema_DotAmf\Src\DotAmf\IO\AmfStreamReader.cs,ReadInt16,The following statement contains a magic number: return BitConverter.ToInt16(PrepareBytes(ReadBytes(2))' 0);
Magic Number,DotAmf.IO,AmfStreamReader,C:\repos\artema_DotAmf\Src\DotAmf\IO\AmfStreamReader.cs,ReadUInt16,The following statement contains a magic number: return BitConverter.ToUInt16(PrepareBytes(ReadBytes(2))' 0);
Magic Number,DotAmf.IO,AmfStreamReader,C:\repos\artema_DotAmf\Src\DotAmf\IO\AmfStreamReader.cs,ReadInt32,The following statement contains a magic number: return BitConverter.ToInt32(PrepareBytes(ReadBytes(4))' 0);
Magic Number,DotAmf.IO,AmfStreamReader,C:\repos\artema_DotAmf\Src\DotAmf\IO\AmfStreamReader.cs,ReadUInt32,The following statement contains a magic number: return BitConverter.ToUInt32(PrepareBytes(ReadBytes(4))' 0);
Magic Number,DotAmf.IO,AmfStreamReader,C:\repos\artema_DotAmf\Src\DotAmf\IO\AmfStreamReader.cs,ReadDouble,The following statement contains a magic number: return BitConverter.ToDouble(PrepareBytes(ReadBytes(8))' 0);
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteUInt29,The following statement contains a magic number: if (value < 0x80)              {                  writer.Write((byte)value);                      //0xxxxxxx              }              //< 16'384:              //0x00000080 - 0x00003FFF              else if (value < 0x4000)              {                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //< 2'097'152:              //0x00004000 - 0x001FFFFF              else if (value < 0x200000)              {                  writer.Write((byte)(value >> 14 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //0x00200000 - 0x3FFFFFFF              else if (value < 0x40000000)              {                  writer.Write((byte)(value >> 22 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 15 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 8 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0xFF));               //xxxxxxxx              }              //0x40000000 - 0xFFFFFFFF' out of range              else              {                  throw new IndexOutOfRangeException("Integer is out of range: " + value);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteUInt29,The following statement contains a magic number: if (value < 0x80)              {                  writer.Write((byte)value);                      //0xxxxxxx              }              //< 16'384:              //0x00000080 - 0x00003FFF              else if (value < 0x4000)              {                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //< 2'097'152:              //0x00004000 - 0x001FFFFF              else if (value < 0x200000)              {                  writer.Write((byte)(value >> 14 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //0x00200000 - 0x3FFFFFFF              else if (value < 0x40000000)              {                  writer.Write((byte)(value >> 22 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 15 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 8 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0xFF));               //xxxxxxxx              }              //0x40000000 - 0xFFFFFFFF' out of range              else              {                  throw new IndexOutOfRangeException("Integer is out of range: " + value);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteUInt29,The following statement contains a magic number: if (value < 0x80)              {                  writer.Write((byte)value);                      //0xxxxxxx              }              //< 16'384:              //0x00000080 - 0x00003FFF              else if (value < 0x4000)              {                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //< 2'097'152:              //0x00004000 - 0x001FFFFF              else if (value < 0x200000)              {                  writer.Write((byte)(value >> 14 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //0x00200000 - 0x3FFFFFFF              else if (value < 0x40000000)              {                  writer.Write((byte)(value >> 22 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 15 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 8 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0xFF));               //xxxxxxxx              }              //0x40000000 - 0xFFFFFFFF' out of range              else              {                  throw new IndexOutOfRangeException("Integer is out of range: " + value);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteUInt29,The following statement contains a magic number: if (value < 0x80)              {                  writer.Write((byte)value);                      //0xxxxxxx              }              //< 16'384:              //0x00000080 - 0x00003FFF              else if (value < 0x4000)              {                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //< 2'097'152:              //0x00004000 - 0x001FFFFF              else if (value < 0x200000)              {                  writer.Write((byte)(value >> 14 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //0x00200000 - 0x3FFFFFFF              else if (value < 0x40000000)              {                  writer.Write((byte)(value >> 22 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 15 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 8 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0xFF));               //xxxxxxxx              }              //0x40000000 - 0xFFFFFFFF' out of range              else              {                  throw new IndexOutOfRangeException("Integer is out of range: " + value);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteUInt29,The following statement contains a magic number: if (value < 0x80)              {                  writer.Write((byte)value);                      //0xxxxxxx              }              //< 16'384:              //0x00000080 - 0x00003FFF              else if (value < 0x4000)              {                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //< 2'097'152:              //0x00004000 - 0x001FFFFF              else if (value < 0x200000)              {                  writer.Write((byte)(value >> 14 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //0x00200000 - 0x3FFFFFFF              else if (value < 0x40000000)              {                  writer.Write((byte)(value >> 22 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 15 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 8 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0xFF));               //xxxxxxxx              }              //0x40000000 - 0xFFFFFFFF' out of range              else              {                  throw new IndexOutOfRangeException("Integer is out of range: " + value);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteUInt29,The following statement contains a magic number: if (value < 0x80)              {                  writer.Write((byte)value);                      //0xxxxxxx              }              //< 16'384:              //0x00000080 - 0x00003FFF              else if (value < 0x4000)              {                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //< 2'097'152:              //0x00004000 - 0x001FFFFF              else if (value < 0x200000)              {                  writer.Write((byte)(value >> 14 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 7 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0x7F));               //xxxxxxxx              }              //0x00200000 - 0x3FFFFFFF              else if (value < 0x40000000)              {                  writer.Write((byte)(value >> 22 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 15 & 0x7F | 0x80));  //1xxxxxxx                  writer.Write((byte)(value >> 8 & 0x7F | 0x80));   //1xxxxxxx                  writer.Write((byte)(value & 0xFF));               //xxxxxxxx              }              //0x40000000 - 0xFFFFFFFF' out of range              else              {                  throw new IndexOutOfRangeException("Integer is out of range: " + value);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteObject,The following statement contains a magic number: if (!input.IsEmptyElement)              {                  traits = new AmfTypeTraits { TypeName = typeName };                  context.TraitsReferences.Add(traits);                    var traitsReader = input.ReadSubtree();                  traitsReader.MoveToContent();                  traitsReader.ReadStartElement();                    var members = new List<string>();                    while (input.NodeType != XmlNodeType.EndElement)                      members.Add(traitsReader.ReadElementContentAsString());                    traits.ClassMembers = members.ToArray();                    //The first bit is a flag with value 1.                   //The second bit is a flag with value 1.                  //The third bit is a flag with value 0.                   var flag = 0x3; //00000011                    if (traits.IsExternalizable) flag |= 0x4; //00000111                    //The fourth bit is a flag specifying whether the type is dynamic.                  //A value of 0 implies not dynamic' a value of 1 implies dynamic.                  if (traits.IsDynamic) flag |= 0x8; //00001011                    //The remaining 1 to 25 significant bits are used to encode the number                   //of sealed traits member names that follow after the class name.                  var count = traits.ClassMembers.Count();                  flag |= count << 4;                    WriteUInt29(writer' flag);                    WriteUtf8(context' writer' traits.TypeName);                    //Write member names                  foreach (var member in traits.ClassMembers)                      WriteUtf8(context' writer' member);              }              //Send traits by reference              else              {                  var index = Convert.ToInt32(input.GetAttribute(AmfxContent.TraitsId)' CultureInfo.InvariantCulture);                  traits = context.TraitsReferences[index];                    var flag = index & UInt29Mask; //Truncate value to UInt29                    //The first bit is a flag with value 1.                  //The second bit is a flag (representing whether a trait                  //reference follows) with value 0 to imply that this objects                  //traits are being sent by reference. The remaining 1 to 27                   //significant bits are used to encode a trait reference index.                  flag = (flag << 2) | 0x1;                  WriteUInt29(writer' flag);              }
Magic Number,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteObject,The following statement contains a magic number: if (!input.IsEmptyElement)              {                  traits = new AmfTypeTraits { TypeName = typeName };                  context.TraitsReferences.Add(traits);                    var traitsReader = input.ReadSubtree();                  traitsReader.MoveToContent();                  traitsReader.ReadStartElement();                    var members = new List<string>();                    while (input.NodeType != XmlNodeType.EndElement)                      members.Add(traitsReader.ReadElementContentAsString());                    traits.ClassMembers = members.ToArray();                    //The first bit is a flag with value 1.                   //The second bit is a flag with value 1.                  //The third bit is a flag with value 0.                   var flag = 0x3; //00000011                    if (traits.IsExternalizable) flag |= 0x4; //00000111                    //The fourth bit is a flag specifying whether the type is dynamic.                  //A value of 0 implies not dynamic' a value of 1 implies dynamic.                  if (traits.IsDynamic) flag |= 0x8; //00001011                    //The remaining 1 to 25 significant bits are used to encode the number                   //of sealed traits member names that follow after the class name.                  var count = traits.ClassMembers.Count();                  flag |= count << 4;                    WriteUInt29(writer' flag);                    WriteUtf8(context' writer' traits.TypeName);                    //Write member names                  foreach (var member in traits.ClassMembers)                      WriteUtf8(context' writer' member);              }              //Send traits by reference              else              {                  var index = Convert.ToInt32(input.GetAttribute(AmfxContent.TraitsId)' CultureInfo.InvariantCulture);                  traits = context.TraitsReferences[index];                    var flag = index & UInt29Mask; //Truncate value to UInt29                    //The first bit is a flag with value 1.                  //The second bit is a flag (representing whether a trait                  //reference follows) with value 0 to imply that this objects                  //traits are being sent by reference. The remaining 1 to 27                   //significant bits are used to encode a trait reference index.                  flag = (flag << 2) | 0x1;                  WriteUInt29(writer' flag);              }
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadTraitsReference,The following statement contains a magic number: if ((reference & 0x3) == 1) //x01 & x11 == x01              {                  //The remaining 1 to 27 significant bits are used to encode a trait reference index                  index = reference >> 2;                    if (context.TraitsReferences.Count <= index)                      throw new SerializationException("Invalid reference index: " + index);                    return context.TraitsReferences[index];              }
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadUint29,The following statement contains a magic number: if (octet < 128) return octet;
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadUint29,The following statement contains a magic number: var result = (octet & mask) << 7;
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadUint29,The following statement contains a magic number: if (octet < 128) return (result | octet);
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadUint29,The following statement contains a magic number: result = (result | (octet & mask)) << 7;
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadUint29,The following statement contains a magic number: if (octet < 128) return (result | octet);
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadUint29,The following statement contains a magic number: result = (result | (octet & mask)) << 8;
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadInteger,The following statement contains a magic number: const int mask = 1 << 28;
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadObject,The following statement contains a magic number: if ((traits = ReadTraitsReference(context' reader' out traitsindex' out traitsreference)) == null)              {                  var isExternalizable = ((traitsreference & 0x4) == 4);                  var isDynamic = ((traitsreference & 0x8) == 8);                  var typeName = ReadString(context' reader);                  var count = (traitsreference >> 4);                  var classMembers = new string[count];                    for (var i = 0; i < count; i++)                      classMembers[i] = ReadString(context' reader);                    traits = new AmfTypeTraits                               {                                   IsDynamic = isDynamic'                                   IsExternalizable = isExternalizable'                                   TypeName = typeName'                                     //No property names are included for types                                   //that are externizable or dynamic                                   ClassMembers = isDynamic || isExternalizable                                      ? new string[0]                                      : classMembers                               };                    context.TraitsReferences.Add(traits);              }
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadObject,The following statement contains a magic number: if ((traits = ReadTraitsReference(context' reader' out traitsindex' out traitsreference)) == null)              {                  var isExternalizable = ((traitsreference & 0x4) == 4);                  var isDynamic = ((traitsreference & 0x8) == 8);                  var typeName = ReadString(context' reader);                  var count = (traitsreference >> 4);                  var classMembers = new string[count];                    for (var i = 0; i < count; i++)                      classMembers[i] = ReadString(context' reader);                    traits = new AmfTypeTraits                               {                                   IsDynamic = isDynamic'                                   IsExternalizable = isExternalizable'                                   TypeName = typeName'                                     //No property names are included for types                                   //that are externizable or dynamic                                   ClassMembers = isDynamic || isExternalizable                                      ? new string[0]                                      : classMembers                               };                    context.TraitsReferences.Add(traits);              }
Magic Number,DotAmf.Decoder,Amf3Decoder,C:\repos\artema_DotAmf\Src\DotAmf\Decoder\Amf3Decoder.cs,ReadObject,The following statement contains a magic number: if ((traits = ReadTraitsReference(context' reader' out traitsindex' out traitsreference)) == null)              {                  var isExternalizable = ((traitsreference & 0x4) == 4);                  var isDynamic = ((traitsreference & 0x8) == 8);                  var typeName = ReadString(context' reader);                  var count = (traitsreference >> 4);                  var classMembers = new string[count];                    for (var i = 0; i < count; i++)                      classMembers[i] = ReadString(context' reader);                    traits = new AmfTypeTraits                               {                                   IsDynamic = isDynamic'                                   IsExternalizable = isExternalizable'                                   TypeName = typeName'                                     //No property names are included for types                                   //that are externizable or dynamic                                   ClassMembers = isDynamic || isExternalizable                                      ? new string[0]                                      : classMembers                               };                    context.TraitsReferences.Add(traits);              }
Magic Number,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,ReadDate,The following statement contains a magic number: var origin = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);
Magic Number,DotAmf.Serialization,DataContractHelper,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractHelper.cs,ConvertToTimestamp,The following statement contains a magic number: var origin = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,DotAmf.Serialization,DataContractHelper,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractHelper.cs,ConvertToTimestamp,The following statement contains a magic number: return (value - origin).TotalSeconds * 1000;
Missing Default,DotAmf.Encoder,Amf0Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf0Encoder.cs,WriteAmfValue,The following switch statement is missing a default case: switch (input.Name)              {                  case AmfxContent.Null:                      WriteNull(writer);                      return;                    case AmfxContent.True:                      WriteBoolean(writer' true);                      return;                    case AmfxContent.False:                      WriteBoolean(writer' false);                      return;              }
Missing Default,DotAmf.Encoder,Amf3Encoder,C:\repos\artema_DotAmf\Src\DotAmf\Encoder\Amf3Encoder.cs,WriteAmfValue,The following switch statement is missing a default case: switch (input.Name)              {                  case AmfxContent.Null:                      WriteTypeMarker(writer' Amf3TypeMarker.Null);                      return;                    case AmfxContent.True:                      WriteTypeMarker(writer' Amf3TypeMarker.True);                      return;                    case AmfxContent.False:                      WriteTypeMarker(writer' Amf3TypeMarker.False);                      return;              }
Missing Default,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,Deserialize,The following switch statement is missing a default case: switch (reader.Name)              {                  case AmfxContent.Null:                      reader.Read();                      return null;                    case AmfxContent.True:                      reader.Read();                      return true;                    case AmfxContent.False:                      reader.Read();                      return false;              }
Missing Default,DotAmf.Serialization,DataContractAmfSerializer,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractAmfSerializer.cs,GetAmfxType,The following switch statement is missing a default case: switch(typecode)              {                  //A boolean value                  case TypeCode.Boolean:                      return AmfxContent.Boolean;                    //A string                  case TypeCode.String:                      return AmfxContent.String;                    //A date                  case TypeCode.DateTime:                      return AmfxContent.Date;                    case TypeCode.Empty:                      return AmfxContent.Date;              }
Missing Default,DotAmf.Serialization,DataContractHelper,C:\repos\artema_DotAmf\Src\DotAmf\Serialization\DataContractHelper.cs,IsNumericType,The following switch statement is missing a default case: switch (typecode)              {                  case TypeCode.Byte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.SByte:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                      isInteger = true;                      return true;                    case TypeCode.Decimal:                  case TypeCode.Double:                  case TypeCode.Single:                      return true;                    case TypeCode.Object:                      {                          if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))                          {                              var subtype = Nullable.GetUnderlyingType(type);                              return IsNumericType(subtype' Type.GetTypeCode(subtype)' out isInteger);                          }                            return false;                      }              }
