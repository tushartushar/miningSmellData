Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The method has 101 lines of code.
Long Method,BitMiracle.LibJpeg.Classic,jpeg_error_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_error_mgr.cs,GetMessageText,The method has 201 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The method has 196 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The method has 150 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The method has 124 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The method has 109 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_markers,The method has 116 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The method has 108 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,update_box,The method has 140 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_nearby_colors,The method has 108 lines of code.
Long Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The method has 128 lines of code.
Complex Method,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,Seek,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg,SampleRow,C:\repos\b9chris_LibJpeg.Net\LibJpeg\SampleRow.cs,SampleRow,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg,SampleRow,C:\repos\b9chris_LibJpeg.Net\LibJpeg\SampleRow.cs,SampleRow,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_finish_compress,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,Cyclomatic complexity of the method is 46
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,Cyclomatic complexity of the method is 34
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_read_header,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_start_decompress,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_consume_input,Cyclomatic complexity of the method is 22
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,Cyclomatic complexity of the method is 22
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_read_coefficients,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_copy_critical_parameters,Cyclomatic complexity of the method is 13
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,Cyclomatic complexity of the method is 39
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_error_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_error_mgr.cs,GetMessageText,Cyclomatic complexity of the method is 99
Complex Method,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,Cyclomatic complexity of the method is 14
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,Cyclomatic complexity of the method is 42
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,color_convert,Cyclomatic complexity of the method is 18
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,start_pass,Cyclomatic complexity of the method is 18
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_data,Cyclomatic complexity of the method is 15
Complex Method,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,Cyclomatic complexity of the method is 13
Complex Method,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,Cyclomatic complexity of the method is 56
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,prepare_for_pass,Cyclomatic complexity of the method is 15
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,finish_pass,Cyclomatic complexity of the method is 13
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_WithoutContext,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_context,Cyclomatic complexity of the method is 14
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_for_output_pass,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,Cyclomatic complexity of the method is 16
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,downsample,Cyclomatic complexity of the method is 19
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,consume_data,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_onepass,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_data_ordinary,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,Cyclomatic complexity of the method is 34
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,start_pass,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_context_main,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,Cyclomatic complexity of the method is 19
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_make_c_derived_tbl,Cyclomatic complexity of the method is 13
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,Cyclomatic complexity of the method is 23
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_forward_dct,Cyclomatic complexity of the method is 15
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,Cyclomatic complexity of the method is 28
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTImpl,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,consume_markers,Cyclomatic complexity of the method is 14
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,per_scan_setup,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,start_pass,Cyclomatic complexity of the method is 41
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,inverse,Cyclomatic complexity of the method is 22
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_markers,Cyclomatic complexity of the method is 82
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,save_marker,Cyclomatic complexity of the method is 18
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_interesting_appn,Cyclomatic complexity of the method is 13
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,Cyclomatic complexity of the method is 17
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,write_frame_header,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,start_pass,Cyclomatic complexity of the method is 26
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,color_quantize,Cyclomatic complexity of the method is 18
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colorindex,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,select_ncolors,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,color_quantize,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,Cyclomatic complexity of the method is 20
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,update_box,Cyclomatic complexity of the method is 47
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_nearby_colors,Cyclomatic complexity of the method is 14
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,my_c_coef_controller,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,start_pass,Cyclomatic complexity of the method is 15
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressDataImpl,Cyclomatic complexity of the method is 16
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressFirstPass,Cyclomatic complexity of the method is 16
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressOutput,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_trans_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_trans_c_coef_controller.cs,compress_data,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,upsampleComponent,Cyclomatic complexity of the method is 24
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,phuff_entropy_decoder,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,start_pass,Cyclomatic complexity of the method is 20
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,Cyclomatic complexity of the method is 9
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,Cyclomatic complexity of the method is 29
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,Cyclomatic complexity of the method is 16
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,Cyclomatic complexity of the method is 14
Complex Method,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,finish_pass_gather_phuff,Cyclomatic complexity of the method is 8
Long Parameter List,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CMYK2RGB,The method has 7 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The method has 7 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,fill_a_scan,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,fill_scans,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace_SET_COMP,The method has 7 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,color_convert,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycc_rgb_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,gray_rgb_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,grayscale_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,null_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_quantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_quantizer.cs,color_quantize,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_data,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_1pass,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,JpegUtils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\JpegUtils.cs,jcopy_sample_rows,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,JpegUtils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\JpegUtils.cs,jcopy_sample_rows,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,JpegUtils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\JpegUtils.cs,jcopy_sample_rows,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,color_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_gray_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,grayscale_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,null_convert,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_data,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_WithoutContext,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_context,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,expand_bottom_edge,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,int_downsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_downsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v1_downsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,expand_right_edge,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,HUFF_DECODE,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_huff_decode,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forward_DCT,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTImpl,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,inverse,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,jpeg_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_upsampler.cs,upsample,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,color_quantize,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_ord_dither,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,color_quantize,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_no_dither,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,upsample,The method has 6 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,merged_2v_upsample,The method has 5 parameters.
Long Parameter List,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,upsample,The method has 6 parameters.
Long Statement,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The length of the statement  "	/* Compute colormap size and total file size */if (m_parameters.Colorspace == Colorspace.Grayscale || m_parameters.QuantizeColors) { " is 132.
Long Statement,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The length of the statement  "	/* biBitCount *//* we leave biCompression = 0' for none *//* we leave biSizeImage = 0; this is correct for uncompressed data */if (m_parameters.DensityUnit == DensityUnit.DotsCm) { " is 180.
Long Statement,BitMiracle.LibJpeg,CompressionParameters,C:\repos\b9chris_LibJpeg.Net\LibJpeg\CompressionParameters.cs,Equals,The length of the statement  "	return (m_quality == parameters.m_quality && m_smoothingFactor == parameters.m_smoothingFactor && m_simpleProgressive == parameters.m_simpleProgressive); " is 153.
Long Statement,BitMiracle.LibJpeg,DecompressorToJpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\DecompressorToJpegImage.cs,ProcessPixelsRow,The length of the statement  "	SampleRow samplesRow = new SampleRow (row' m_jpegImage.Width' m_jpegImage.BitsPerComponent' m_jpegImage.ComponentsPerSample); " is 125.
Long Statement,BitMiracle.LibJpeg,Jpeg,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Jpeg.cs,applyParameters,The length of the statement  "	m_compressor.jpeg_set_colorspace (m_compressor.map_colorspace (m_compressor.In_color_space)' parameters.YHSamp' parameters.YVSamp' parameters.CbHSamp' parameters.CbVSamp' parameters.CrHSamp' parameters.CrVSamp); " is 211.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_write_marker,The length of the statement  "	if (m_next_scanline != 0 || (m_global_state != JpegState.CSTATE_SCANNING && m_global_state != JpegState.CSTATE_RAW_OK && m_global_state != JpegState.CSTATE_WRCOEFS)) " is 165.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_write_m_header,The length of the statement  "	if (m_next_scanline != 0 || (m_global_state != JpegState.CSTATE_SCANNING && m_global_state != JpegState.CSTATE_RAW_OK && m_global_state != JpegState.CSTATE_WRCOEFS)) " is 165.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_defaults,The length of the statement  "	/* Set up two quantization tables using default quality of 75 */// TODO: Why use a default quality here when we know the desired output quality? " is 144.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The length of the statement  "		/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0); " is 150.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_linear_quality,The length of the statement  "	/* Set up two quantization tables using the specified scaling */jpeg_add_quant_table (0' std_luminance_quant_tbl' scale_factor' force_baseline); " is 144.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The length of the statement  "	/* Initialize sent_table false so table will be written to JPEG file. */m_quant_tbl_ptrs [which_tbl].Sent_table = false; " is 120.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The length of the statement  "		/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1); " is 143.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_write_raw_data,The length of the statement  "	/* Verify that at least one iMCU row has been passed. */int lines_per_iMCU_row = m_max_v_samp_factor * JpegConstants.DCTSIZE; " is 125.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jinit_compress_master,The length of the statement  "	/* Initialize master control (includes parameter checking/processing) */jinit_c_master_control (false/* full compression */); " is 125.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jinit_compress_master,The length of the statement  "	/* Need a full-image coefficient buffer in any multi-pass mode. */m_coef = new my_c_coef_controller (this' (bool)(m_num_scans > 1 || m_optimize_coding)); " is 153.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,transencode_master_selection,The length of the statement  "	/* Initialize master control (includes parameter checking/processing) */jinit_c_master_control (true/* transcode only */); " is 122.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "	/* Sanity check on image dimensions */if (m_image_height <= 0 || m_image_width <= 0 || m_num_components <= 0 || m_input_components <= 0) " is 136.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "	/* Make sure image isn't bigger than I can handle */if (m_image_height > JpegConstants.JPEG_MAX_DIMENSION || m_image_width > JpegConstants.JPEG_MAX_DIMENSION) " is 158.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "	/* Check that number of components won't exceed internal array sizes */if (m_num_components > JpegConstants.MAX_COMPONENTS) " is 123.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "		if (m_comp_info [ci].H_samp_factor <= 0 || m_comp_info [ci].H_samp_factor > JpegConstants.MAX_SAMP_FACTOR || m_comp_info [ci].V_samp_factor <= 0 || m_comp_info [ci].V_samp_factor > JpegConstants.MAX_SAMP_FACTOR) { " is 213.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "		/* Size in DCT blocks */m_comp_info [ci].Width_in_blocks = JpegUtils.jdiv_round_up (m_image_width * m_comp_info [ci].H_samp_factor' m_max_h_samp_factor * JpegConstants.DCTSIZE); " is 177.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "		m_comp_info [ci].height_in_blocks = JpegUtils.jdiv_round_up (m_image_height * m_comp_info [ci].V_samp_factor' m_max_v_samp_factor * JpegConstants.DCTSIZE); " is 155.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "		/* Size in samples */m_comp_info [ci].downsampled_width = JpegUtils.jdiv_round_up (m_image_width * m_comp_info [ci].H_samp_factor' m_max_h_samp_factor); " is 152.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The length of the statement  "		m_comp_info [ci].downsampled_height = JpegUtils.jdiv_round_up (m_image_height * m_comp_info [ci].V_samp_factor' m_max_v_samp_factor); " is 133.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The length of the statement  "	/* -1 until that coefficient has been seen; then last Al for it */if (m_scan_info [0].Ss != 0 || m_scan_info [0].Se != JpegConstants.DCTSIZE2 - 1) { " is 148.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The length of the statement  "			if (Ss < 0 || Ss >= JpegConstants.DCTSIZE2 || Se < Ss || Se >= JpegConstants.DCTSIZE2 || Ah < 0 || Ah > MAX_AH_AL || Al < 0 || Al > MAX_AH_AL) { " is 144.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The length of the statement  "			/* For sequential JPEG' all progression parameters must be these: */if (Ss != 0 || Se != JpegConstants.DCTSIZE2 - 1 || Ah != 0 || Al != 0) " is 138.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,add_huff_table,The length of the statement  "	/* Copy the number-of-symbols-of-each-code-length counts */Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length); " is 124.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_start_decompress,The length of the statement  "				/* Advance progress counter if appropriate */if (m_progress != null && (retcode == ReadResult.JPEG_ROW_COMPLETED || retcode == ReadResult.JPEG_REACHED_SOS)) { " is 158.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_finish_decompress,The length of the statement  "		/* STOPPING = repeat call after a suspension' anything else is error */ERREXIT (J_MESSAGE_CODE.JERR_BAD_STATE' (int)m_global_state); " is 132.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_read_raw_data,The length of the statement  "	/* Verify that at least one iMCU row can be returned. */int lines_per_iMCU_row = m_max_v_samp_factor * m_min_DCT_scaled_size; " is 125.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_has_multiple_scans,The length of the statement  "	/* Only valid after jpeg_read_header completes */if (m_global_state < JpegState.DSTATE_READY || m_global_state > JpegState.DSTATE_STOPPING) " is 139.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_finish_output,The length of the statement  "		/* BUFPOST = repeat call after a suspension' anything else is error */ERREXIT (J_MESSAGE_CODE.JERR_BAD_STATE' (int)m_global_state); " is 131.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_finish_output,The length of the statement  "	/* Read markers looking for SOS or EOI */while (m_input_scan_number <= m_output_scan_number && !m_inputctl.EOIReached ()) { " is 123.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_input_complete,The length of the statement  "	/* Check for valid jpeg object */if (m_global_state < JpegState.DSTATE_START || m_global_state > JpegState.DSTATE_STOPPING) " is 123.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The length of the statement  "		while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) { " is 229.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The length of the statement  "		/* Size in samples' after IDCT scaling */m_comp_info [ci].downsampled_width = JpegUtils.jdiv_round_up (m_image_width * m_comp_info [ci].H_samp_factor * m_comp_info [ci].DCT_scaled_size' m_max_h_samp_factor * JpegConstants.DCTSIZE); " is 231.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The length of the statement  "		m_comp_info [ci].downsampled_height = JpegUtils.jdiv_round_up (m_image_height * m_comp_info [ci].V_samp_factor * m_comp_info [ci].DCT_scaled_size' m_max_v_samp_factor * JpegConstants.DCTSIZE); " is 192.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The length of the statement  "	/* Report number of components in selected colorspace. *//* Probably this should be in the color conversion module... */switch (m_out_color_space) { " is 148.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_read_coefficients,The length of the statement  "			/* Advance progress counter if appropriate */if (m_progress != null && (retcode == ReadResult.JPEG_ROW_COMPLETED || retcode == ReadResult.JPEG_REACHED_SOS)) { " is 158.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_copy_critical_parameters,The length of the statement  "			Buffer.BlockCopy (m_quant_tbl_ptrs [tblno].quantval' 0' dstinfo.m_quant_tbl_ptrs [tblno].quantval' 0' dstinfo.m_quant_tbl_ptrs [tblno].quantval.Length * sizeof(short)); " is 168.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The length of the statement  "	/* my_upsampler only supports YCC=>RGB color conversion */if (m_jpeg_color_space != J_COLOR_SPACE.JCS_YCbCr || m_num_components != 3 || m_out_color_space != J_COLOR_SPACE.JCS_RGB || m_out_color_components != JpegConstants.RGB_PIXELSIZE) { " is 238.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The length of the statement  "	/* and it only handles 2h1v or 2h2v sampling ratios */if (m_comp_info [0].H_samp_factor != 2 || m_comp_info [1].H_samp_factor != 1 || m_comp_info [2].H_samp_factor != 1 || m_comp_info [0].V_samp_factor > 2 || m_comp_info [1].V_samp_factor != 1 || m_comp_info [2].V_samp_factor != 1) { " is 284.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The length of the statement  "	/* furthermore' it doesn't work if we've scaled the IDCTs differently */if (m_comp_info [0].DCT_scaled_size != m_min_DCT_scaled_size || m_comp_info [1].DCT_scaled_size != m_min_DCT_scaled_size || m_comp_info [2].DCT_scaled_size != m_min_DCT_scaled_size) { " is 255.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The length of the statement  "	/* Guess the input colorspace' and set output colorspace accordingly. *//* (Wish JPEG committee had provided a real way to specify this...) *//* Note application may override our guesses. */switch (m_num_components) { " is 217.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The length of the statement  "			if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) { " is 151.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The length of the statement  "			else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) { " is 156.
Long Statement,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The length of the statement  "			/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true; " is 125.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,start_pass,The length of the statement  "		/* Compute derived values for Huffman tables *//* We may do this more than once for a table' but it's not expensive */jpeg_make_d_derived_tbl (true' dctbl' ref m_dc_derived_tbls [dctbl]); " is 187.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,start_pass,The length of the statement  "	/* Precalculate decoding info for each block in an MCU of this scan */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) { " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The length of the statement  "				/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) { " is 169.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The length of the statement  "				/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) { " is 144.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,process_restart,The length of the statement  "	/* Throw away any unused bits remaining in bit buffer; *//* include any full bytes in next_marker's count of discarded bytes */m_cinfo.m_marker.SkipBytes (m_bitstate.bits_left / 8); " is 181.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The length of the statement  "		/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS); " is 263.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The length of the statement  "		/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS); " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The length of the statement  "		/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF; " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycc_rgb_convert,The length of the statement  "			/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset + JpegConstants.RGB_RED] = limit [limitOffset + y + m_Cr_r_tab [cr]]; " is 185.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycc_rgb_convert,The length of the statement  "			output_buf [output_row + row] [columnOffset + JpegConstants.RGB_GREEN] = limit [limitOffset + y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS)]; " is 168.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The length of the statement  "			/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])]; " is 190.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The length of the statement  "			/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))]; " is 184.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The length of the statement  "			/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])]; " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The length of the statement  "			/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col]; " is 179.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,gray_rgb_convert,The length of the statement  "			/* We can dispense with GETJSAMPLE() here */output_buf [output_row + row] [columnOffset + JpegConstants.RGB_RED] = input_buf [0] [input_row + component0RowOffset] [col]; " is 169.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,gray_rgb_convert,The length of the statement  "			output_buf [output_row + row] [columnOffset + JpegConstants.RGB_GREEN] = input_buf [0] [input_row + component1RowOffset] [col]; " is 127.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,gray_rgb_convert,The length of the statement  "			output_buf [output_row + row] [columnOffset + JpegConstants.RGB_BLUE] = input_buf [0] [input_row + component2RowOffset] [col]; " is 126.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,grayscale_convert,The length of the statement  "	JpegUtils.jcopy_sample_rows (input_buf [0]' input_row + m_perComponentOffsets [0]' output_buf' output_row' num_rows' m_cinfo.m_output_width); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,null_convert,The length of the statement  "				/* needn't bother with GETJSAMPLE() here */output_buf [output_row + row] [ci + componentOffset] = input_buf [ci] [input_row + perComponentOffset] [columnIndex]; " is 160.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_data,The length of the statement  "		m_cinfo.m_upsample.upsample (input_buf' ref in_row_group_ctr' in_row_groups_avail' output_buf' ref out_row_ctr' out_rows_avail); " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_1pass,The length of the statement  "	/* Fill the buffer' but not more than what we can dump out in one go. *//* Note we rely on the upsampler to detect bottom of image. */int max_rows = out_rows_avail - out_row_ctr; " is 178.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_prepass,The length of the statement  "	m_cinfo.m_upsample.upsample (input_buf' ref in_row_group_ctr' in_row_groups_avail' m_buffer' ref m_next_row' m_strip_height); " is 125.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_prepass,The length of the statement  "	/* Allow quantizer to scan new data.  No data is emitted' *//* but we advance out_row_ctr so outer loop can tell when we're done. */if (m_next_row > old_next_row) { " is 164.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_2pass,The length of the statement  "	/* We have to check bottom of image here' can't depend on upsampler. */max_rows = m_cinfo.m_output_height - m_starting_row; " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_post_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_post_controller.cs,post_process_2pass,The length of the statement  "	/* Quantize and emit data. */m_cinfo.m_cquantize.color_quantize (m_buffer' m_next_row' output_buf' out_row_ctr' num_rows); " is 122.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The length of the statement  "			/* Check for invalid table indexes *//* (make_c_derived_tbl does this in the other path) */if (dctbl < 0 || dctbl >= JpegConstants.NUM_HUFF_TBLS) " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The length of the statement  "			/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_dc_count_ptrs [dctbl] == null) " is 154.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The length of the statement  "			/* Compute derived values for Huffman tables *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (true' dctbl' ref m_dc_derived_tbls [dctbl]); " is 187.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_mcu_huff,The length of the statement  "		if (!encode_one_block (state' MCU_data [blkn] [0].data' state.last_dc_val [ci]' m_dc_derived_tbls [m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Dc_tbl_no]' m_ac_derived_tbls [m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Ac_tbl_no])) { " is 252.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_mcu_gather,The length of the statement  "		htest_one_block (MCU_data [blkn] [0].data' m_saved.last_dc_val [ci]' m_dc_count_ptrs [m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Dc_tbl_no]' m_ac_count_ptrs [m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Ac_tbl_no]); " is 235.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The length of the statement  "		/* temp is abs value of input *//* For a negative input' want temp2 = bitwise complement of abs(input) *//* This code assumes we are on a two's complement machine */temp2--; " is 173.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The length of the statement  "	/* Emit the Huffman-coded symbol for the number of bits */if (!emit_bits (state' dctbl.ehufco [nbits]' dctbl.ehufsi [nbits])) " is 125.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The length of the statement  "	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (nbits != 0) { " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The length of the statement  "			/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits)) " is 148.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The length of the statement  "                     *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS); " is 156.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The length of the statement  "			/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The length of the statement  "			/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_gray_convert,The length of the statement  "			/* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS); " is 154.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The length of the statement  "			/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3]; " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The length of the statement  "                     *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS); " is 156.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The length of the statement  "			/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The length of the statement  "			/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,prepare_for_output_pass,The length of the statement  "	/* Do a data-output pass. *//* We need not repeat per-scan setup if prior optimization pass did it. */if (!m_cinfo.m_optimize_coding) { " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,select_scan_parameters,The length of the statement  "		/* Prepare for current scan --- the script is already validated */jpeg_scan_info scanInfo = m_cinfo.m_scan_info [m_scan_number]; " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,select_scan_parameters,The length of the statement  "		/* Prepare for single sequential-JPEG scan containing all components */if (m_cinfo.m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) " is 134.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "		/* Interleaved (multi-component) scan */if (m_cinfo.m_comps_in_scan <= 0 || m_cinfo.m_comps_in_scan > JpegConstants.MAX_COMPS_IN_SCAN) " is 134.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "		/* Overall image size in MCUs */m_cinfo.m_MCUs_per_row = JpegUtils.jdiv_round_up (m_cinfo.m_image_width' m_cinfo.m_max_h_samp_factor * JpegConstants.DCTSIZE); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "		m_cinfo.m_MCU_rows_in_scan = JpegUtils.jdiv_round_up (m_cinfo.m_image_height' m_cinfo.m_max_v_samp_factor * JpegConstants.DCTSIZE); " is 131.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "			/* Sampling factors give # of blocks of component in each MCU */m_cinfo.Component_info [compIndex].MCU_width = m_cinfo.Component_info [compIndex].H_samp_factor; " is 160.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "			m_cinfo.Component_info [compIndex].MCU_blocks = m_cinfo.Component_info [compIndex].MCU_width * m_cinfo.Component_info [compIndex].MCU_height; " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "			m_cinfo.Component_info [compIndex].MCU_sample_width = m_cinfo.Component_info [compIndex].MCU_width * JpegConstants.DCTSIZE; " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "			/* Figure number of non-dummy blocks in last MCU column & row */int tmp = m_cinfo.Component_info [compIndex].Width_in_blocks % m_cinfo.Component_info [compIndex].MCU_width; " is 172.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The length of the statement  "	/* Convert restart specified in rows to actual MCU count. *//* Note that count must fit in 16 bits' so we provide limiting. */if (m_cinfo.m_restart_in_rows > 0) { " is 162.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_main_controller.cs,process_data,The length of the statement  "			m_cinfo.m_prep.pre_process_data (input_buf' ref in_row_ctr' in_rows_avail' m_buffer' ref m_rowgroup_ctr' JpegConstants.DCTSIZE); " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,start_pass,The length of the statement  "	/* Set next_buf_stop to stop after two row groups have been read in. */m_next_buf_stop = 2 * m_cinfo.m_max_v_samp_factor; " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_data,The length of the statement  "		pre_process_context (input_buf' ref in_row_ctr' in_rows_avail' output_buf' ref out_row_group_ctr' out_row_groups_avail); " is 120.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_data,The length of the statement  "		pre_process_WithoutContext (input_buf' ref in_row_ctr' in_rows_avail' output_buf' ref out_row_group_ctr' out_row_groups_avail); " is 127.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The length of the statement  "		int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor; " is 164.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_WithoutContext,The length of the statement  "		/* If at bottom of image' pad to fill the conversion buffer. */if (m_rows_to_go == 0 && m_next_buf_row < m_cinfo.m_max_v_samp_factor) { " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_WithoutContext,The length of the statement  "				expand_bottom_edge (m_color_buf [ci]' m_colorBufRowsOffset' m_cinfo.m_image_width' m_next_buf_row' m_cinfo.m_max_v_samp_factor); " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_WithoutContext,The length of the statement  "				expand_bottom_edge (output_buf [ci]' 0' componentInfo.Width_in_blocks * JpegConstants.DCTSIZE' out_row_group_ctr * componentInfo.V_samp_factor' out_row_groups_avail * componentInfo.V_samp_factor); " is 196.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_context,The length of the statement  "						JpegUtils.jcopy_sample_rows (m_color_buf [ci]' m_colorBufRowsOffset' m_color_buf [ci]' m_colorBufRowsOffset - row' 1' m_cinfo.m_image_width); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The length of the statement  "	/* Width of an output scanline must be representable as int. */long samplesperrow = m_cinfo.m_output_width * m_cinfo.m_out_color_components; " is 140.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The length of the statement  "		/* We use the 2-pass code to map to external colormaps. */if (m_cinfo.m_enable_2pass_quant || m_cinfo.m_enable_external_quant) { " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The length of the statement  "	/* Initialize principal buffer controllers. */bool use_c_buffer = m_cinfo.m_inputctl.HasMultipleScans () || m_cinfo.m_buffered_image; " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The length of the statement  "	/* Point to where post-IDCT table starts *//* End of simple table' rest of first half of post-IDCT table */for (int i = JpegConstants.CENTERJSAMPLE; i < 2 * (JpegConstants.MAXJSAMPLE + 1); i++) " is 193.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The length of the statement  "	/* Second half of post-IDCT table */Array.Clear (table' tableOffset + 2 * (JpegConstants.MAXJSAMPLE + 1)' 2 * (JpegConstants.MAXJSAMPLE + 1) - JpegConstants.CENTERJSAMPLE); " is 172.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The length of the statement  "	Buffer.BlockCopy (m_cinfo.m_sample_range_limit' 0' table' tableOffset + 4 * (JpegConstants.MAXJSAMPLE + 1) - JpegConstants.CENTERJSAMPLE' JpegConstants.CENTERJSAMPLE); " is 167.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,int_downsample,The length of the statement  "	expand_right_edge (input_data' startInputRow' m_cinfo.m_max_v_samp_factor' m_cinfo.m_image_width' output_cols * h_expand); " is 122.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_downsample,The length of the statement  "	/* Copy the data */JpegUtils.jcopy_sample_rows (input_data' startInputRow' output_data' startOutRow' m_cinfo.m_max_v_samp_factor' m_cinfo.m_image_width); " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_downsample,The length of the statement  "	/* Edge-expand */expand_right_edge (output_data' startOutRow' m_cinfo.m_max_v_samp_factor' m_cinfo.m_image_width' m_cinfo.Component_info [componentIndex].Width_in_blocks * JpegConstants.DCTSIZE); " is 195.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v1_downsample,The length of the statement  "			output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + outrow] [inputColumn] + (int)input_data [startInputRow + outrow] [inputColumn + 1] + bias) >> 1); " is 184.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The length of the statement  "			output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2); " is 306.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "	expand_right_edge (input_data' startInputRow - 1' m_cinfo.m_max_v_samp_factor + 2' m_cinfo.m_image_width' output_cols * 2); " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "	/* scaled SF/4 */for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) { " is 124.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "		/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1]; " is 296.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "		int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2]; " is 445.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "		neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2]; " is 234.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "			/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1]; " is 276.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "			/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2]; " is 482.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "			/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2]; " is 275.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "		/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1]; " is 252.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "		neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1]; " is 449.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The length of the statement  "		neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1]; " is 242.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The length of the statement  "		/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex]; " is 204.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The length of the statement  "		int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex]; " is 173.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The length of the statement  "			nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex]; " is 169.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,consume_data,The length of the statement  "	/* Align the virtual buffers for the components used in this scan. */for (int ci = 0; ci < m_cinfo.m_comps_in_scan; ci++) { " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,consume_data,The length of the statement  "		buffer [ci] = m_whole_image [componentInfo.Component_index].Access (m_cinfo.m_input_iMCU_row * componentInfo.V_samp_factor' componentInfo.V_samp_factor); " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,consume_data,The length of the statement  "	/* Loop to process one whole iMCU row */for (int yoffset = m_MCU_vert_offset; yoffset < m_MCU_rows_per_iMCU_row; yoffset++) { " is 125.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_onepass,The length of the statement  "	/* Loop to process as much as one whole iMCU row */for (int yoffset = m_MCU_vert_offset; yoffset < m_MCU_rows_per_iMCU_row; yoffset++) { " is 136.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_onepass,The length of the statement  "			/* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */for (int i = 0; i < m_cinfo.m_blocks_in_MCU; i++) " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_onepass,The length of the statement  "							m_cinfo.m_idct.inverse (componentInfo.Component_index' m_MCU_buffer [blkn + xindex].data' output_buf [componentInfo.Component_index]' outputIndex' output_col); " is 159.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_data_ordinary,The length of the statement  "	/* Force some input to be done if we are getting ahead of the input. */while (m_cinfo.m_input_scan_number < m_cinfo.m_output_scan_number || (m_cinfo.m_input_scan_number == m_cinfo.m_output_scan_number && m_cinfo.m_input_iMCU_row <= m_cinfo.m_output_iMCU_row)) { " is 261.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_data_ordinary,The length of the statement  "		/* Align the virtual buffer for this component. */JBLOCK[][] buffer = m_whole_image [ci].Access (m_cinfo.m_output_iMCU_row * componentInfo.V_samp_factor' componentInfo.V_samp_factor); " is 183.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_data_ordinary,The length of the statement  "			/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor; " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_data_ordinary,The length of the statement  "				m_cinfo.m_idct.inverse (componentInfo.Component_index' buffer [block_row] [block_num].data' output_buf [ci]' rowIndex' output_col); " is 131.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The length of the statement  "	/* Force some input to be done if we are getting ahead of the input. */while (m_cinfo.m_input_scan_number <= m_cinfo.m_output_scan_number && !m_cinfo.m_inputctl.EOIReached ()) { " is 177.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The length of the statement  "			/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor; " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The length of the statement  "			/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows); " is 136.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The length of the statement  "				/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col); " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,smoothing_ok,The length of the statement  "		/* All components' quantization values must already be latched. */JQUANT_TBL qtable = m_cinfo.Comp_info [ci].quant_table; " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,smoothing_ok,The length of the statement  "		/* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */if (qtable.quantval [0] == 0 || qtable.quantval [Q01_POS] == 0 || qtable.quantval [Q10_POS] == 0 || qtable.quantval [Q20_POS] == 0 || qtable.quantval [Q11_POS] == 0 || qtable.quantval [Q02_POS] == 0) { " is 274.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_simple_main,The length of the statement  "	/* There are always min_DCT_scaled_size row groups in an iMCU row. */int rowgroups_avail = m_cinfo.m_min_DCT_scaled_size; " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_simple_main,The length of the statement  "             *//* Feed the postprocessor */m_cinfo.m_post.post_process_data (cb' ref m_rowgroup_ctr' rowgroups_avail' output_buf' ref out_row_ctr' out_rows_avail); " is 150.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_context_main,The length of the statement  "		/* Call postprocessor using previously set pointers for postponed row */m_cinfo.m_post.post_process_data (cb' ref m_rowgroup_ctr' m_rowgroups_avail' output_buf' ref out_row_ctr' out_rows_avail); " is 194.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_context_main,The length of the statement  "		/* Call postprocessor using previously set pointers */m_cinfo.m_post.post_process_data (cb' ref m_rowgroup_ctr' m_rowgroups_avail' output_buf' ref out_row_ctr' out_rows_avail); " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_context_main,The length of the statement  "		/* Still need to process last row group of this iMCU row' *//* which is saved at index M+1 of the other xbuffer */m_rowgroup_ctr = m_cinfo.m_min_DCT_scaled_size + 1; " is 165.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,alloc_funny_pointers,The length of the statement  "		/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size; " is 165.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The length of the statement  "		/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size; " is 165.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The length of the statement  "		/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size; " is 165.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_bottom_pointers,The length of the statement  "		/* Count sample rows in one iMCU row and in one row group */int iMCUheight = m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size; " is 155.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_bottom_pointers,The length of the statement  "		/* Count nondummy sample rows remaining for this component */int rows_left = m_cinfo.Comp_info [ci].downsampled_height % iMCUheight; " is 132.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_bottom_pointers,The length of the statement  "			m_funnyIndices [m_whichFunny] [ci] [rows_left + i + rgroup] = m_funnyIndices [m_whichFunny] [ci] [rows_left - 1 + rgroup]; " is 122.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The length of the statement  "	/* Figure C.2: generate the codes themselves *//* We also validate that the counts represent a legal Huffman code tree. */int code = 0; " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The length of the statement  "			/* l = current code's length' p = its index in huffcode[] & huffval[]. *//* Generate left-justified code followed by all possible bit sequences */int lookbits = huffcode [p] << (JpegConstants.HUFF_LOOKAHEAD - l); " is 212.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The length of the statement  "	/* Attempt to load at least MIN_GET_BITS bits into get_buffer. *//* (It is assumed that no request will be for more than that many bits.) *//* We fail to do so only if we hit a marker or are forced to suspend. */bool noMoreBytes = false; " is 237.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_huff_decode,The length of the statement  "	/* HUFF_DECODE has determined that the code is at least min_bits *//* bits long' so fetch that many bits in one swoop. */int l = min_bits; " is 138.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_huff_decode,The length of the statement  "	/* Collect the rest of the Huffman code one bit at a time. *//* This is per Figure F.16 in the JPEG spec. */while (code > htbl.maxcode [l]) { " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_make_c_derived_tbl,The length of the statement  "	/* Figure C.2: generate the codes themselves *//* We also validate that the counts represent a legal Huffman code tree. */int code = 0; " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_make_c_derived_tbl,The length of the statement  "	/* Figure C.3: generate encoding tables *//* These are code and size indexed by symbol value *//* Set all codeless symbols to have code length 0;" is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The length of the statement  "		/* Find the smallest nonzero frequency' set c1 = its symbol *//* In case of ties' take the larger symbol number */c1 = -1; " is 122.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The length of the statement  "		/* Find the next smallest nonzero frequency' set c2 = its symbol *//* In case of ties' take the larger symbol number */c2 = -1; " is 127.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The length of the statement  "	/* Return a list of the symbols sorted by code length *//* It's not real clear to me why we don't need to consider the codelength" is 129.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The length of the statement  "		/* Make sure specified quantization table is present */if (qtblno < 0 || qtblno >= JpegConstants.NUM_QUANT_TBLS || m_cinfo.m_quant_tbl_ptrs [qtblno] == null) " is 157.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The length of the statement  "		/* Compute divisors for this quant table *//* We may do this more than once for same table' but it's not a big deal */int i = 0; " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The length of the statement  "	/* This routine is heavily used' so it's worth coding it tightly. */float[] workspace = new float[JpegConstants.DCTSIZE2]; " is 122.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The length of the statement  "				workspace [workspaceIndex] = (float)((int)sample_data [start_row + elemr] [start_col + column] - JpegConstants.CENTERJSAMPLE); " is 126.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The length of the statement  "		/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433); " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The length of the statement  "		/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433); " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "	/* Pass 1: process rows. *//* Note results are scaled up by sqrt(8) compared to a true DCT; *//* furthermore' we scale the results by 2**SLOW_INTEGER_PASS1_BITS. */int dataIndex = 0; " is 182.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 136.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 139.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS); " is 160.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS); " is 163.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS); " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS); " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS); " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The length of the statement  "		data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS); " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "	/* Make sure image isn't bigger than I can handle */if (m_cinfo.m_image_height > JpegConstants.JPEG_MAX_DIMENSION || m_cinfo.m_image_width > JpegConstants.JPEG_MAX_DIMENSION) { " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "	/* Check that number of components won't exceed internal array sizes */if (m_cinfo.m_num_components > JpegConstants.MAX_COMPONENTS) " is 131.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "		if (m_cinfo.Comp_info [ci].H_samp_factor <= 0 || m_cinfo.Comp_info [ci].H_samp_factor > JpegConstants.MAX_SAMP_FACTOR || m_cinfo.Comp_info [ci].V_samp_factor <= 0 || m_cinfo.Comp_info [ci].V_samp_factor > JpegConstants.MAX_SAMP_FACTOR) { " is 237.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "		/* Size in DCT blocks */m_cinfo.Comp_info [ci].Width_in_blocks = JpegUtils.jdiv_round_up (m_cinfo.m_image_width * m_cinfo.Comp_info [ci].H_samp_factor' m_cinfo.m_max_h_samp_factor * JpegConstants.DCTSIZE); " is 205.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "		m_cinfo.Comp_info [ci].height_in_blocks = JpegUtils.jdiv_round_up (m_cinfo.m_image_height * m_cinfo.Comp_info [ci].V_samp_factor' m_cinfo.m_max_v_samp_factor * JpegConstants.DCTSIZE); " is 183.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "                 *//* Size in samples */m_cinfo.Comp_info [ci].downsampled_width = JpegUtils.jdiv_round_up (m_cinfo.m_image_width * m_cinfo.Comp_info [ci].H_samp_factor' m_cinfo.m_max_h_samp_factor); " is 182.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "		m_cinfo.Comp_info [ci].downsampled_height = JpegUtils.jdiv_round_up (m_cinfo.m_image_height * m_cinfo.Comp_info [ci].V_samp_factor' m_cinfo.m_max_v_samp_factor); " is 161.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "	/* Compute number of fully interleaved MCU rows. */m_cinfo.m_total_iMCU_rows = JpegUtils.jdiv_round_up (m_cinfo.m_image_height' m_cinfo.m_max_v_samp_factor * JpegConstants.DCTSIZE); " is 181.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The length of the statement  "	/* Decide whether file contains multiple scans */if (m_cinfo.m_comps_in_scan < m_cinfo.m_num_components || m_cinfo.m_progressive_mode) " is 134.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,latch_quant_tables,The length of the statement  "		Buffer.BlockCopy (m_cinfo.m_quant_tbl_ptrs [qtblno].quantval' 0' qtbl.quantval' 0' qtbl.quantval.Length * sizeof(short)); " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,per_scan_setup,The length of the statement  "		/* Noninterleaved (single-component) scan */jpeg_component_info componentInfo = m_cinfo.Comp_info [m_cinfo.m_cur_comp_info [0]]; " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,per_scan_setup,The length of the statement  "		/* Interleaved (multi-component) scan */if (m_cinfo.m_comps_in_scan <= 0 || m_cinfo.m_comps_in_scan > JpegConstants.MAX_COMPS_IN_SCAN) " is 134.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,per_scan_setup,The length of the statement  "		/* Overall image size in MCUs */m_cinfo.m_MCUs_per_row = JpegUtils.jdiv_round_up (m_cinfo.m_image_width' m_cinfo.m_max_h_samp_factor * JpegConstants.DCTSIZE); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,per_scan_setup,The length of the statement  "		m_cinfo.m_MCU_rows_in_scan = JpegUtils.jdiv_round_up (m_cinfo.m_image_height' m_cinfo.m_max_v_samp_factor * JpegConstants.DCTSIZE); " is 131.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,per_scan_setup,The length of the statement  "			/* Figure number of non-dummy blocks in last MCU column & row */int tmp = componentInfo.Width_in_blocks % componentInfo.MCU_width; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,start_pass,The length of the statement  "				ifmtbl [i] = JpegUtils.DESCALE ((int)componentInfo.quant_table.quantval [i] * (int)aanscales [i]' CONST_BITS - IFAST_SCALE_BITS); " is 129.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "	/* Pass 1: process columns from input' store into work array. *//* Note results are scaled up by sqrt(8) compared to a true IDCT; *//* furthermore' we scale the results by 2**SLOW_INTEGER_PASS1_BITS. */int coefBlockIndex = 0; " is 225.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "                */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) { " is 453.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "			/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS; " is 202.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]); " is 242.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]); " is 149.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]); " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "                */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]); " is 149.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]); " is 147.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]); " is 147.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]); " is 147.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 202.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS); " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "	/* Pass 2: process rows from work array' store into output array. *//* Note that we must descale the results by a factor of 8 == 2**3' *//* and also undo the SLOW_INTEGER_PASS1_BITS scaling. */workspaceIndex = 0; " is 212.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) { " is 276.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "			/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2]; " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 237.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 176.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "                */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) { " is 453.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "			/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 175.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 166.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]); " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]); " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]); " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]); " is 165.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]); " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]); " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]); " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "	/* Pass 2: process rows from work array' store into output array. *//* Note that we must descale the results by a factor of 8 == 2**3' *//* and also undo the FAST_INTEGER_PASS1_BITS scaling. */workspaceIndex = 0; " is 212.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "                */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) { " is 278.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "			/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 155.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13; " is 138.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 222.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK]; " is 153.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "                */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) { " is 453.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "			/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 161.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]); " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]); " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]); " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]); " is 160.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]); " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]); " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]); " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "	/* Pass 2: process rows from work array' store into output array. *//* Note that we must descale the results by a factor of 8 == 2**3. */workspaceIndex = 0; " is 156.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK]; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) { " is 387.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "			/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS; " is 235.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 161.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]); " is 144.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]); " is 144.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]); " is 140.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]); " is 140.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]); " is 144.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337; " is 205.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447; " is 227.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1); " is 182.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1); " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1); " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1); " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) { " is 304.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "			/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK]; " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865); " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337; " is 205.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447; " is 227.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK]; " is 217.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK]; " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK]; " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK]; " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6) " is 152.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) { " is 259.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "			/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS; " is 240.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]); " is 159.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]); " is 154.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]); " is 169.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]); " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]); " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2); " is 188.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2); " is 135.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) { " is 226.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "			/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK]; " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785; " is 354.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK]; " is 223.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The length of the statement  "		m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK]; " is 170.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_markers,The length of the statement  "		/* Collect the marker proper' unless we already did. *//* NB: first_marker() enforces the requirement that SOI appear first. */if (m_cinfo.m_unread_marker == 0) { " is 162.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_restart_marker,The length of the statement  "	/* Obtain a marker unless we already did. *//* Note that next_marker will complain if it skips any data. */if (m_cinfo.m_unread_marker == 0) { " is 142.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_restart_marker,The length of the statement  "		/* Normal case --- swallow the marker and let entropy decoder continue */m_cinfo.TRACEMS (3' J_MESSAGE_CODE.JTRC_RST' m_cinfo.m_marker.m_next_restart_num); " is 155.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_restart_marker,The length of the statement  "		/* Uh-oh' the restart markers have been messed up. *//* Let the data source manager determine how to resync. */if (!m_cinfo.m_src.resync_to_restart (m_cinfo' m_cinfo.m_marker.m_next_restart_num)) " is 195.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,jpeg_save_markers,The length of the statement  "		/* If saving APP0/APP14' save at least enough for our internal use. */if (marker_code == (int)JPEG_MARKER.APP0 && length_limit < APP0_DATA_LEN) " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,jpeg_save_markers,The length of the statement  "		/* If discarding APP0/APP14' use our regular on-the-fly processor. */if (marker_code == (int)JPEG_MARKER.APP0 || marker_code == (int)JPEG_MARKER.APP14) " is 151.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,save_marker,The length of the statement  "			/* allocate and initialize the marker item */cur_marker = new jpeg_marker_struct ((byte)cinfo.m_unread_marker' length' limit); " is 126.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,save_marker,The length of the statement  "	/* Process the marker if interesting; else just make a generic trace msg */switch ((JPEG_MARKER)cinfo.m_unread_marker) { " is 120.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_interesting_appn,The length of the statement  "		/* can't get here unless jpeg_save_markers chooses wrong processor */cinfo.ERREXIT (J_MESSAGE_CODE.JERR_UNKNOWN_MARKER' cinfo.m_unread_marker); " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The length of the statement  "	if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) { " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The length of the statement  "		/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit); " is 189.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The length of the statement  "	else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) { " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The length of the statement  "	if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) { " is 132.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The length of the statement  "		/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining); " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The length of the statement  "	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOF' m_cinfo.m_unread_marker' m_cinfo.m_image_width' m_cinfo.m_image_height' m_cinfo.m_num_components); " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The length of the statement  "	/* We don't support files in which the image height is initially specified *//* as 0 and is later redefined by DNL.  As long as we have to check that'  *//* might as well have a general sanity check. */if (m_cinfo.m_image_height <= 0 || m_cinfo.m_image_width <= 0 || m_cinfo.m_num_components <= 0) " is 297.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The length of the statement  "		/* do only once' even if suspend */m_cinfo.Comp_info = jpeg_component_info.createArrayOfComponents (m_cinfo.m_num_components); " is 126.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The length of the statement  "		m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOF_COMPONENT' m_cinfo.Comp_info [ci].Component_id' m_cinfo.Comp_info [ci].H_samp_factor' m_cinfo.Comp_info [ci].V_samp_factor' m_cinfo.Comp_info [ci].Quant_tbl_no); " is 205.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The length of the statement  "		m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOS_COMPONENT' cc' m_cinfo.Comp_info [foundIndex].Dc_tbl_no' m_cinfo.Comp_info [foundIndex].Ac_tbl_no); " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The length of the statement  "		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]); " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The length of the statement  "		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]); " is 137.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The length of the statement  "			/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The length of the statement  "				m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]); " is 271.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The length of the statement  "	/* length *//* Make sure image isn't bigger than SOF field can handle */if (m_cinfo.m_image_height > 65535 || m_cinfo.m_image_width > 65535) " is 140.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_ord_dither,The length of the statement  "		/* Initialize output values to 0 so can process components separately */Array.Clear (output_buf [out_row + row]' 0' width); " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_ord_dither,The length of the statement  "                         */output_buf [outRow] [outIndex] += m_colorindex [ci] [m_colorindexOffset [ci] + input_buf [in_row + row] [inputIndex] + m_odither [ci] [row_index] [col_index]]; " is 161.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The length of the statement  "			int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]]; " is 126.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The length of the statement  "			pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]]; " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The length of the statement  "			pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]]; " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The length of the statement  "		/* Initialize output values to 0 so can process components separately */Array.Clear (output_buf [out_row + row]' 0' width); " is 123.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The length of the statement  "				/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur]; " is 133.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The length of the statement  "				/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode]; " is 206.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colormap,The length of the statement  "	/* Allocate and fill in the colormap. *//* The colors are ordered in the map in standard row-major order' *//* i.e. rightmost (highest-indexed) color changes most rapidly. */byte[][] colormap = jpeg_common_struct.AllocJpegSamples (total_colors' m_cinfo.m_out_color_components); " is 277.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colormap,The length of the statement  "	/* blksize is number of adjacent repeated entries for a component *//* blkdist is distance between groups of identical entries for a component */int blkdist = total_colors; " is 172.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colormap,The length of the statement  "			/* Fill in all colormap entries that have this value of this component */for (int ptr = j * blksize; ptr < total_colors; ptr += blkdist) { " is 138.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colorindex,The length of the statement  "	m_colorindex = jpeg_common_struct.AllocJpegSamples (JpegConstants.MAXJSAMPLE + 1 + pad' m_cinfo.m_out_color_components); " is 120.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colorindex,The length of the statement  "			/* premultiply so that no multiplication needed in main processing */m_colorindex [i] [m_colorindexOffset [i] + j] = (byte)(val * blksize); " is 139.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colorindex,The length of the statement  "				m_colorindex [i] [m_colorindexOffset [i] + JpegConstants.MAXJSAMPLE + j] = m_colorindex [i] [m_colorindexOffset [i] + JpegConstants.MAXJSAMPLE]; " is 144.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,largest_input_value,The length of the statement  "	/* Breakpoints are halfway between values returned by output_value */return (int)(((2 * j + 1) * JpegConstants.MAXJSAMPLE + maxj) / (2 * maxj)); " is 144.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,select_ncolors,The length of the statement  "	/* We can allocate at least the nc'th root of max_colors per component. *//* Compute floor(nc'th root of max_colors). */int iroot = 1; " is 134.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The length of the statement  "	/* Only F-S dithering or no dithering is supported. *//* If user asks for ordered dither' give him F-S. */if (m_cinfo.m_dither_mode != J_DITHER_MODE.JDITHER_NONE) " is 162.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,prescan_quantize,The length of the statement  "			int columnIndex = ((int)input_buf [in_row + row] [inputIndex + 1] >> C1_SHIFT) * HIST_C2_ELEMS + ((int)input_buf [in_row + row] [inputIndex + 2] >> C2_SHIFT); " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The length of the statement  "			/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0) " is 136.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_no_dither,The length of the statement  "			/* If we have not seen this color before' find nearest colormap entry *//* and update the cache */if (m_histogram [hRow] [hColumn] == 0) " is 136.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_no_dither,The length of the statement  "			/* Now emit the colormap index for this cell */output_buf [outRow] [outIndex] = (byte)(m_histogram [hRow] [hColumn] - 1); " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,compute_color,The length of the statement  "	/* Current algorithm: mean weighted by pixels (not colors) *//* Note it is important to get the rounding correct! */long total = 0; " is 131.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,init_error_limit,The length of the statement  "	/* Clamp the rest to final output value (which is (MAXJSAMPLE+1)/8) */for (; input <= JpegConstants.MAXJSAMPLE; input++) { " is 122.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The length of the statement  "	/* This array holds the distance to the nearest-so-far color for each cell */int[] bestdist = new int[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS]; " is 146.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The length of the statement  "		/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE; " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,fill_inverse_cmap,The length of the statement  "	/* Determine the actually nearest colors. *//* This array holds the actually closest colormap index for each cell. */byte[] bestcolor = new byte[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS]; " is 189.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressDataImpl,The length of the statement  "	/* Loop to write as much as one whole iMCU row */for (int yoffset = m_MCU_vert_offset; yoffset < m_MCU_rows_per_iMCU_row; yoffset++) { " is 134.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressDataImpl,The length of the statement  "						m_cinfo.m_fdct.forward_DCT (componentInfo.Quant_tbl_no' input_buf [componentInfo.Component_index]' m_MCU_buffer [blkn]' ypos' xpos' blockcnt); " is 142.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressDataImpl,The length of the statement  "							/* Create some dummy blocks at the right edge of the image. */for (int i = 0; i < (componentInfo.MCU_width - blockcnt); i++) " is 124.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressFirstPass,The length of the statement  "		/* Align the virtual buffer for this component. */JBLOCK[][] buffer = m_whole_image [ci].Access (m_iMCU_row_num * componentInfo.V_samp_factor' componentInfo.V_samp_factor); " is 172.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressFirstPass,The length of the statement  "			/* NB: can't use last_row_height here' since may not be set! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor; " is 137.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressFirstPass,The length of the statement  "			m_cinfo.m_fdct.forward_DCT (componentInfo.Quant_tbl_no' input_buf [ci]' buffer [block_row]' block_row * JpegConstants.DCTSIZE' 0' blocks_across); " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressFirstPass,The length of the statement  "				/* Create dummy blocks at the right edge of the image. */Array.Clear (buffer [block_row] [blocks_across].data' 0' buffer [block_row] [blocks_across].data.Length); " is 162.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressOutput,The length of the statement  "		buffer [ci] = m_whole_image [componentInfo.Component_index].Access (m_iMCU_row_num * componentInfo.V_samp_factor' componentInfo.V_samp_factor); " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compressOutput,The length of the statement  "	/* Loop to process one whole iMCU row */for (int yoffset = m_MCU_vert_offset; yoffset < m_MCU_rows_per_iMCU_row; yoffset++) { " is 125.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The length of the statement  "		/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS); " is 263.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The length of the statement  "		/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS); " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The length of the statement  "		/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF; " is 158.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_trans_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_trans_c_coef_controller.cs,compress_data,The length of the statement  "	/* Align the virtual buffers for the components used in this scan. */JBLOCK[][][] buffer = new JBLOCK[JpegConstants.MAX_COMPS_IN_SCAN][][]; " is 139.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_trans_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_trans_c_coef_controller.cs,compress_data,The length of the statement  "		buffer [ci] = m_whole_image [componentInfo.Component_index].Access (m_iMCU_row_num * componentInfo.V_samp_factor' componentInfo.V_samp_factor); " is 143.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,upsample,The length of the statement  "	/* Color-convert and emit rows *//* How many we have in the buffer: */int num_rows = m_cinfo.m_max_v_samp_factor - m_next_row_out; " is 130.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,upsample,The length of the statement  "	m_cinfo.m_cconvert.color_convert (m_color_buf' m_perComponentOffsets' m_next_row_out' output_buf' out_row_ctr' num_rows); " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,upsample,The length of the statement  "	/* When the buffer is emptied' declare this input row group consumed */if (m_next_row_out >= m_cinfo.m_max_v_samp_factor) " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The length of the statement  "			/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1]; " is 129.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The length of the statement  "				/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1]; " is 210.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,start_pass,The length of the statement  "		/* need not check Ss/Se < 0 since they came from unsigned bytes */if (m_cinfo.m_Ss > m_cinfo.m_Se || m_cinfo.m_Se >= JpegConstants.DCTSIZE2) " is 140.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,start_pass,The length of the statement  "				/* DC refinement needs no table */jpeg_make_d_derived_tbl (true' componentInfo.Dc_tbl_no' ref m_derived_tbls [componentInfo.Dc_tbl_no]); " is 136.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_DC_first,The length of the statement  "			if (!HUFF_DECODE (out s' ref br_state' m_derived_tbls [m_cinfo.Comp_info [m_cinfo.m_cur_comp_info [ci]].Dc_tbl_no]' ref get_buffer' ref bits_left)) " is 147.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_DC_first,The length of the statement  "			/* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */MCU_data [blkn] [0] = (short)(s << m_cinfo.m_Al); " is 121.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The length of the statement  "					/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al); " is 142.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_DC_refine,The length of the statement  "		/* Encoded data is simply the next bit of the two's-complement DC value */if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) " is 145.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The length of the statement  "	/* -1 in the bit position being coded *//* Process restart marker if needed; may have to suspend */if (m_cinfo.m_restart_interval != 0) { " is 137.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,process_restart,The length of the statement  "	/* Throw away any unused bits remaining in bit buffer; *//* include any full bytes in next_marker's count of discarded bytes */m_cinfo.m_marker.SkipBytes (m_bitstate.bits_left / 8); " is 181.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The length of the statement  "	/* We assume the scan parameters are already validated. *//* Select execution routines */bool is_DC_band = (m_cinfo.m_Ss == 0); " is 127.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The length of the statement  "			/* Check for invalid table index *//* (make_c_derived_tbl does this in the other path) */if (tbl < 0 || tbl >= JpegConstants.NUM_HUFF_TBLS) " is 139.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The length of the statement  "			/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_count_ptrs [tbl] == null) " is 149.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The length of the statement  "			/* Compute derived values for Huffman table *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (is_DC_band' tbl' ref m_derived_tbls [tbl]); " is 185.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,The length of the statement  "			/* For a negative input' want temp2 = bitwise complement of abs(input) *//* This code assumes we are on a two's complement machine */temp2--; " is 141.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,The length of the statement  "		/* Count/emit the Huffman-coded symbol for the number of bits */emit_symbol (m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Dc_tbl_no' nbits); " is 149.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,The length of the statement  "		/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (nbits != 0) { " is 128.
Long Statement,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The length of the statement  "		/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */emit_bits (temp2' nbits); " is 136.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_write_marker,The conditional expression  "m_next_scanline != 0 || (m_global_state != JpegState.CSTATE_SCANNING && m_global_state != JpegState.CSTATE_RAW_OK && m_global_state != JpegState.CSTATE_WRCOEFS)"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_write_m_header,The conditional expression  "m_next_scanline != 0 || (m_global_state != JpegState.CSTATE_SCANNING && m_global_state != JpegState.CSTATE_RAW_OK && m_global_state != JpegState.CSTATE_WRCOEFS)"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The conditional expression  "m_image_height <= 0 || m_image_width <= 0 || m_num_components <= 0 || m_input_components <= 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,initial_setup,The conditional expression  "m_comp_info [ci].H_samp_factor <= 0 || m_comp_info [ci].H_samp_factor > JpegConstants.MAX_SAMP_FACTOR || m_comp_info [ci].V_samp_factor <= 0 || m_comp_info [ci].V_samp_factor > JpegConstants.MAX_SAMP_FACTOR"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The conditional expression  "Ss < 0 || Ss >= JpegConstants.DCTSIZE2 || Se < Ss || Se >= JpegConstants.DCTSIZE2 || Ah < 0 || Ah > MAX_AH_AL || Al < 0 || Al > MAX_AH_AL"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The conditional expression  "Ss != 0 || Se != JpegConstants.DCTSIZE2 - 1 || Ah != 0 || Al != 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The conditional expression  "m_jpeg_color_space != J_COLOR_SPACE.JCS_YCbCr || m_num_components != 3 || m_out_color_space != J_COLOR_SPACE.JCS_RGB || m_out_color_components != JpegConstants.RGB_PIXELSIZE"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The conditional expression  "m_comp_info [0].H_samp_factor != 2 || m_comp_info [1].H_samp_factor != 1 || m_comp_info [2].H_samp_factor != 1 || m_comp_info [0].V_samp_factor > 2 || m_comp_info [1].V_samp_factor != 1 || m_comp_info [2].V_samp_factor != 1"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,start_pass,The conditional expression  "m_cinfo.m_Ss != 0 || m_cinfo.m_Se != JpegConstants.DCTSIZE2 - 1 || m_cinfo.m_Ah != 0 || m_cinfo.m_Al != 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,smoothing_ok,The conditional expression  "qtable.quantval [0] == 0 || qtable.quantval [Q01_POS] == 0 || qtable.quantval [Q10_POS] == 0 || qtable.quantval [Q20_POS] == 0 || qtable.quantval [Q11_POS] == 0 || qtable.quantval [Q02_POS] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,initial_setup,The conditional expression  "m_cinfo.Comp_info [ci].H_samp_factor <= 0 || m_cinfo.Comp_info [ci].H_samp_factor > JpegConstants.MAX_SAMP_FACTOR || m_cinfo.Comp_info [ci].V_samp_factor <= 0 || m_cinfo.Comp_info [ci].V_samp_factor > JpegConstants.MAX_SAMP_FACTOR"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The conditional expression  "coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The conditional expression  "workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The conditional expression  "coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The conditional expression  "workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The conditional expression  "coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The conditional expression  "coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The conditional expression  "workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The conditional expression  "coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The conditional expression  "workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The conditional expression  "datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The conditional expression  "datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0"  is complex.
Complex Conditional,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The conditional expression  "datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65"  is complex.
Virtual Method Call from Constructor,BitMiracle.LibJpeg,Sample,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Sample.cs,Sample,The constructor "Sample" calls a virtual method "Read".
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,BeginWrite,The following statement contains a magic number: while (m_rowWidth % 4 != 0)  	m_rowWidth++;  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putRgbRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 3;  	byte red = row [firstComponent];  	byte green = row [firstComponent + 1];  	byte blue = row [firstComponent + 2];  	m_pixels [firstComponent] [m_currentRow] = blue;  	m_pixels [firstComponent + 1] [m_currentRow] = green;  	m_pixels [firstComponent + 2] [m_currentRow] = red;  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putRgbRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 3;  	byte red = row [firstComponent];  	byte green = row [firstComponent + 1];  	byte blue = row [firstComponent + 2];  	m_pixels [firstComponent] [m_currentRow] = blue;  	m_pixels [firstComponent + 1] [m_currentRow] = green;  	m_pixels [firstComponent + 2] [m_currentRow] = red;  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putRgbRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 3;  	byte red = row [firstComponent];  	byte green = row [firstComponent + 1];  	byte blue = row [firstComponent + 2];  	m_pixels [firstComponent] [m_currentRow] = blue;  	m_pixels [firstComponent + 1] [m_currentRow] = green;  	m_pixels [firstComponent + 2] [m_currentRow] = red;  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putRgbRow,The following statement contains a magic number: m_pixels [firstComponent + 2] [m_currentRow] = red;  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 4;  	m_pixels [firstComponent] [m_currentRow] = row [firstComponent + 2];  	m_pixels [firstComponent + 1] [m_currentRow] = row [firstComponent + 1];  	m_pixels [firstComponent + 2] [m_currentRow] = row [firstComponent + 0];  	m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 4;  	m_pixels [firstComponent] [m_currentRow] = row [firstComponent + 2];  	m_pixels [firstComponent + 1] [m_currentRow] = row [firstComponent + 1];  	m_pixels [firstComponent + 2] [m_currentRow] = row [firstComponent + 0];  	m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 4;  	m_pixels [firstComponent] [m_currentRow] = row [firstComponent + 2];  	m_pixels [firstComponent + 1] [m_currentRow] = row [firstComponent + 1];  	m_pixels [firstComponent + 2] [m_currentRow] = row [firstComponent + 0];  	m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 4;  	m_pixels [firstComponent] [m_currentRow] = row [firstComponent + 2];  	m_pixels [firstComponent + 1] [m_currentRow] = row [firstComponent + 1];  	m_pixels [firstComponent + 2] [m_currentRow] = row [firstComponent + 0];  	m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: for (int i = 0; i < m_parameters.Width; ++i) {  	int firstComponent = i * 4;  	m_pixels [firstComponent] [m_currentRow] = row [firstComponent + 2];  	m_pixels [firstComponent + 1] [m_currentRow] = row [firstComponent + 1];  	m_pixels [firstComponent + 2] [m_currentRow] = row [firstComponent + 0];  	m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: m_pixels [firstComponent] [m_currentRow] = row [firstComponent + 2];  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: m_pixels [firstComponent + 2] [m_currentRow] = row [firstComponent + 0];  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,putCmykRow,The following statement contains a magic number: m_pixels [firstComponent + 3] [m_currentRow] = row [firstComponent + 3];  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.Grayscale || m_parameters.QuantizeColors) {  	bits_per_pixel = 8;  	cmap_entries = 256;  }  else {  	cmap_entries = 0;  	if (m_parameters.Colorspace == Colorspace.RGB)  		bits_per_pixel = 24;  	else if (m_parameters.Colorspace == Colorspace.CMYK)  		bits_per_pixel = 32;  	else  		throw new InvalidOperationException ();  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.Grayscale || m_parameters.QuantizeColors) {  	bits_per_pixel = 8;  	cmap_entries = 256;  }  else {  	cmap_entries = 0;  	if (m_parameters.Colorspace == Colorspace.RGB)  		bits_per_pixel = 24;  	else if (m_parameters.Colorspace == Colorspace.CMYK)  		bits_per_pixel = 32;  	else  		throw new InvalidOperationException ();  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.Grayscale || m_parameters.QuantizeColors) {  	bits_per_pixel = 8;  	cmap_entries = 256;  }  else {  	cmap_entries = 0;  	if (m_parameters.Colorspace == Colorspace.RGB)  		bits_per_pixel = 24;  	else if (m_parameters.Colorspace == Colorspace.CMYK)  		bits_per_pixel = 32;  	else  		throw new InvalidOperationException ();  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.Grayscale || m_parameters.QuantizeColors) {  	bits_per_pixel = 8;  	cmap_entries = 256;  }  else {  	cmap_entries = 0;  	if (m_parameters.Colorspace == Colorspace.RGB)  		bits_per_pixel = 24;  	else if (m_parameters.Colorspace == Colorspace.CMYK)  		bits_per_pixel = 32;  	else  		throw new InvalidOperationException ();  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: bits_per_pixel = 8;  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: cmap_entries = 256;  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.RGB)  	bits_per_pixel = 24;  else if (m_parameters.Colorspace == Colorspace.CMYK)  	bits_per_pixel = 32;  else  	throw new InvalidOperationException ();  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.RGB)  	bits_per_pixel = 24;  else if (m_parameters.Colorspace == Colorspace.CMYK)  	bits_per_pixel = 32;  else  	throw new InvalidOperationException ();  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: bits_per_pixel = 24;  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (m_parameters.Colorspace == Colorspace.CMYK)  	bits_per_pixel = 32;  else  	throw new InvalidOperationException ();  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: bits_per_pixel = 32;  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: if (cmap_entries > 0)  	writeColormap (cmap_entries' 4);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeHeader,The following statement contains a magic number: writeColormap (cmap_entries' 4);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,createBitmapFileHeader,The following statement contains a magic number: PUT_4B (bmpfileheader' 2' fileSize);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,createBitmapFileHeader,The following statement contains a magic number: PUT_4B (bmpfileheader' 10' offsetToPixels);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 4' m_parameters.Width);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 8' m_parameters.Height);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_2B (infoHeader' 12' 1);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_2B (infoHeader' 14' bitsPerPixel);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: if (m_parameters.DensityUnit == DensityUnit.DotsCm) {  	/* if have density in dots/cm' then */PUT_4B (infoHeader' 24' m_parameters.DensityX * 100);  	/* XPels/M */PUT_4B (infoHeader' 28' m_parameters.DensityY * 100);  	/* XPels/M */}  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: if (m_parameters.DensityUnit == DensityUnit.DotsCm) {  	/* if have density in dots/cm' then */PUT_4B (infoHeader' 24' m_parameters.DensityX * 100);  	/* XPels/M */PUT_4B (infoHeader' 28' m_parameters.DensityY * 100);  	/* XPels/M */}  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: if (m_parameters.DensityUnit == DensityUnit.DotsCm) {  	/* if have density in dots/cm' then */PUT_4B (infoHeader' 24' m_parameters.DensityX * 100);  	/* XPels/M */PUT_4B (infoHeader' 28' m_parameters.DensityY * 100);  	/* XPels/M */}  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: if (m_parameters.DensityUnit == DensityUnit.DotsCm) {  	/* if have density in dots/cm' then */PUT_4B (infoHeader' 24' m_parameters.DensityX * 100);  	/* XPels/M */PUT_4B (infoHeader' 28' m_parameters.DensityY * 100);  	/* XPels/M */}  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 24' m_parameters.DensityX * 100);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 24' m_parameters.DensityX * 100);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 28' m_parameters.DensityY * 100);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 28' m_parameters.DensityY * 100);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,fillBitmapInfoHeader,The following statement contains a magic number: PUT_2B (infoHeader' 32' cmap_entries);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,createBitmapV4InfoHeader,The following statement contains a magic number: PUT_4B (infoHeader' 56' 0x02);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (colormap != null) {  	if (m_parameters.ComponentsPerSample == 3) {  		/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [2] [i]);  			m_output.WriteByte (colormap [1] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  	else {  		/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  }  else {  	/* If no colormap' must be grayscale data.  Generate a linear "map". */for (i = 0; i < 256; i++) {  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (colormap != null) {  	if (m_parameters.ComponentsPerSample == 3) {  		/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [2] [i]);  			m_output.WriteByte (colormap [1] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  	else {  		/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  }  else {  	/* If no colormap' must be grayscale data.  Generate a linear "map". */for (i = 0; i < 256; i++) {  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (colormap != null) {  	if (m_parameters.ComponentsPerSample == 3) {  		/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [2] [i]);  			m_output.WriteByte (colormap [1] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  	else {  		/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  }  else {  	/* If no colormap' must be grayscale data.  Generate a linear "map". */for (i = 0; i < 256; i++) {  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (colormap != null) {  	if (m_parameters.ComponentsPerSample == 3) {  		/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [2] [i]);  			m_output.WriteByte (colormap [1] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  	else {  		/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  }  else {  	/* If no colormap' must be grayscale data.  Generate a linear "map". */for (i = 0; i < 256; i++) {  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (colormap != null) {  	if (m_parameters.ComponentsPerSample == 3) {  		/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [2] [i]);  			m_output.WriteByte (colormap [1] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  	else {  		/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  }  else {  	/* If no colormap' must be grayscale data.  Generate a linear "map". */for (i = 0; i < 256; i++) {  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (colormap != null) {  	if (m_parameters.ComponentsPerSample == 3) {  		/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [2] [i]);  			m_output.WriteByte (colormap [1] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  	else {  		/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			m_output.WriteByte (colormap [0] [i]);  			if (map_entry_size == 4)  				m_output.WriteByte (0);  		}  	}  }  else {  	/* If no colormap' must be grayscale data.  Generate a linear "map". */for (i = 0; i < 256; i++) {  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		m_output.WriteByte ((byte)i);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (m_parameters.ComponentsPerSample == 3) {  	/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [2] [i]);  		m_output.WriteByte (colormap [1] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  else {  	/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (m_parameters.ComponentsPerSample == 3) {  	/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [2] [i]);  		m_output.WriteByte (colormap [1] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  else {  	/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (m_parameters.ComponentsPerSample == 3) {  	/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [2] [i]);  		m_output.WriteByte (colormap [1] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  else {  	/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (m_parameters.ComponentsPerSample == 3) {  	/* Normal case with RGB colormap */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [2] [i]);  		m_output.WriteByte (colormap [1] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  else {  	/* Grayscale colormap (only happens with grayscale quantization) */for (i = 0; i < num_colors; i++) {  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		m_output.WriteByte (colormap [0] [i]);  		if (map_entry_size == 4)  			m_output.WriteByte (0);  	}  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: for (i = 0; i < num_colors; i++) {  	m_output.WriteByte (colormap [2] [i]);  	m_output.WriteByte (colormap [1] [i]);  	m_output.WriteByte (colormap [0] [i]);  	if (map_entry_size == 4)  		m_output.WriteByte (0);  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: for (i = 0; i < num_colors; i++) {  	m_output.WriteByte (colormap [2] [i]);  	m_output.WriteByte (colormap [1] [i]);  	m_output.WriteByte (colormap [0] [i]);  	if (map_entry_size == 4)  		m_output.WriteByte (0);  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: m_output.WriteByte (colormap [2] [i]);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (map_entry_size == 4)  	m_output.WriteByte (0);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: for (i = 0; i < num_colors; i++) {  	m_output.WriteByte (colormap [0] [i]);  	m_output.WriteByte (colormap [0] [i]);  	m_output.WriteByte (colormap [0] [i]);  	if (map_entry_size == 4)  		m_output.WriteByte (0);  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (map_entry_size == 4)  	m_output.WriteByte (0);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	m_output.WriteByte ((byte)i);  	m_output.WriteByte ((byte)i);  	m_output.WriteByte ((byte)i);  	if (map_entry_size == 4)  		m_output.WriteByte (0);  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	m_output.WriteByte ((byte)i);  	m_output.WriteByte ((byte)i);  	m_output.WriteByte ((byte)i);  	if (map_entry_size == 4)  		m_output.WriteByte (0);  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (map_entry_size == 4)  	m_output.WriteByte (0);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: for (; i < map_colors; i++) {  	m_output.WriteByte (0);  	m_output.WriteByte (0);  	m_output.WriteByte (0);  	if (map_entry_size == 4)  		m_output.WriteByte (0);  }  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,writeColormap,The following statement contains a magic number: if (map_entry_size == 4)  	m_output.WriteByte (0);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,PUT_2B,The following statement contains a magic number: array [offset + 1] = (byte)(((value) >> 8) & 0xFF);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,PUT_4B,The following statement contains a magic number: array [offset + 1] = (byte)(((value) >> 8) & 0xFF);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,PUT_4B,The following statement contains a magic number: array [offset + 2] = (byte)(((value) >> 16) & 0xFF);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,PUT_4B,The following statement contains a magic number: array [offset + 2] = (byte)(((value) >> 16) & 0xFF);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,PUT_4B,The following statement contains a magic number: array [offset + 3] = (byte)(((value) >> 24) & 0xFF);  
Magic Number,BitMiracle.LibJpeg,BitmapDestination,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitmapDestination.cs,PUT_4B,The following statement contains a magic number: array [offset + 3] = (byte)(((value) >> 24) & 0xFF);  
Magic Number,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,read,The following statement contains a magic number: if (bitsCount < 0 || bitsCount > 32)  	throw new ArgumentOutOfRangeException ("bitsCount");  
Magic Number,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,read,The following statement contains a magic number: while (bitsRead == 0 || (bitsRead - m_positionInByte < bitsCount)) {  	m_stream.Read (bt' 0' 1);  	result = (result << bitsInByte);  	result += bt [0];  	bitsRead += 8;  }  
Magic Number,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,read,The following statement contains a magic number: bitsRead += 8;  
Magic Number,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,read,The following statement contains a magic number: m_positionInByte = (m_positionInByte + bitsCount) % 8;  
Magic Number,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,read,The following statement contains a magic number: if (bitsCount < 32) {  	int mask = ((1 << bitsCount) - 1);  	result = result & mask;  }  
Magic Number,BitMiracle.LibJpeg,DecompressorToJpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\DecompressorToJpegImage.cs,SetImageAttributes,The following statement contains a magic number: m_jpegImage.BitsPerComponent = 8;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,isCompressed,The following statement contains a magic number: if (imageData.Length <= 2)  	return false;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelFormat == PixelFormat.Format16bppGrayScale) {  	m_bitsPerComponent = 16;  	m_componentsPerSample = 1;  	m_colorspace = Colorspace.Grayscale;  	return;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 32 && formatIndexByte == 15)//PixelFormat32bppCMYK (15 | (32 << 8))   {  	m_bitsPerComponent = 8;  	m_componentsPerSample = 4;  	m_colorspace = Colorspace.CMYK;  	return;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 32 && formatIndexByte == 15)//PixelFormat32bppCMYK (15 | (32 << 8))   {  	m_bitsPerComponent = 8;  	m_componentsPerSample = 4;  	m_colorspace = Colorspace.CMYK;  	return;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 32 && formatIndexByte == 15)//PixelFormat32bppCMYK (15 | (32 << 8))   {  	m_bitsPerComponent = 8;  	m_componentsPerSample = 4;  	m_colorspace = Colorspace.CMYK;  	return;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 32 && formatIndexByte == 15)//PixelFormat32bppCMYK (15 | (32 << 8))   {  	m_bitsPerComponent = 8;  	m_componentsPerSample = 4;  	m_colorspace = Colorspace.CMYK;  	return;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_bitsPerComponent = 8;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_componentsPerSample = 4;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_bitsPerComponent = 8;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_componentsPerSample = 3;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 16)  	m_bitsPerComponent = 6;  else if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_bitsPerComponent = 6;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 24 || pixelSizeByte == 32)  	m_bitsPerComponent = 8;  else if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_bitsPerComponent = 8;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: if (pixelSizeByte == 48 || pixelSizeByte == 64)  	m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,processPixelFormat,The following statement contains a magic number: m_bitsPerComponent = 16;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	short[] samples = new short[Width * 3];  	for (int x = 0; x < Width; ++x) {  		Color color = m_bitmap.GetPixel (x' y);  		samples [x * 3] = color.R;  		samples [x * 3 + 1] = color.G;  		samples [x * 3 + 2] = color.B;  	}  	m_rows.Add (new SampleRow (samples' m_bitsPerComponent' m_componentsPerSample));  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	short[] samples = new short[Width * 3];  	for (int x = 0; x < Width; ++x) {  		Color color = m_bitmap.GetPixel (x' y);  		samples [x * 3] = color.R;  		samples [x * 3 + 1] = color.G;  		samples [x * 3 + 2] = color.B;  	}  	m_rows.Add (new SampleRow (samples' m_bitsPerComponent' m_componentsPerSample));  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	short[] samples = new short[Width * 3];  	for (int x = 0; x < Width; ++x) {  		Color color = m_bitmap.GetPixel (x' y);  		samples [x * 3] = color.R;  		samples [x * 3 + 1] = color.G;  		samples [x * 3 + 2] = color.B;  	}  	m_rows.Add (new SampleRow (samples' m_bitsPerComponent' m_componentsPerSample));  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	short[] samples = new short[Width * 3];  	for (int x = 0; x < Width; ++x) {  		Color color = m_bitmap.GetPixel (x' y);  		samples [x * 3] = color.R;  		samples [x * 3 + 1] = color.G;  		samples [x * 3 + 2] = color.B;  	}  	m_rows.Add (new SampleRow (samples' m_bitsPerComponent' m_componentsPerSample));  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	short[] samples = new short[Width * 3];  	for (int x = 0; x < Width; ++x) {  		Color color = m_bitmap.GetPixel (x' y);  		samples [x * 3] = color.R;  		samples [x * 3 + 1] = color.G;  		samples [x * 3 + 2] = color.B;  	}  	m_rows.Add (new SampleRow (samples' m_bitsPerComponent' m_componentsPerSample));  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	Color color = m_bitmap.GetPixel (x' y);  	samples [x * 3] = color.R;  	samples [x * 3 + 1] = color.G;  	samples [x * 3 + 2] = color.B;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	Color color = m_bitmap.GetPixel (x' y);  	samples [x * 3] = color.R;  	samples [x * 3 + 1] = color.G;  	samples [x * 3 + 2] = color.B;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	Color color = m_bitmap.GetPixel (x' y);  	samples [x * 3] = color.R;  	samples [x * 3 + 1] = color.G;  	samples [x * 3 + 2] = color.B;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	Color color = m_bitmap.GetPixel (x' y);  	samples [x * 3] = color.R;  	samples [x * 3 + 1] = color.G;  	samples [x * 3 + 2] = color.B;  }  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: samples [x * 3] = color.R;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: samples [x * 3 + 1] = color.G;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: samples [x * 3 + 2] = color.B;  
Magic Number,BitMiracle.LibJpeg,JpegImage,C:\repos\b9chris_LibJpeg.Net\LibJpeg\JpegImage.cs,fillSamplesFromBitmap,The following statement contains a magic number: samples [x * 3 + 2] = color.B;  
Magic Number,BitMiracle.LibJpeg,Sample,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Sample.cs,Sample,The following statement contains a magic number: if (bitsPerComponent <= 0 || bitsPerComponent > 16)  	throw new ArgumentOutOfRangeException ("bitsPerComponent");  
Magic Number,BitMiracle.LibJpeg,Sample,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Sample.cs,Sample,The following statement contains a magic number: if (componentCount <= 0 || componentCount > 5)  	throw new ArgumentOutOfRangeException ("componentCount");  
Magic Number,BitMiracle.LibJpeg,Sample,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Sample.cs,Sample,The following statement contains a magic number: if (components.Length == 0 || components.Length > 5)  	throw new ArgumentException ("components must be not empty and contain less than 5 elements");  
Magic Number,BitMiracle.LibJpeg,Sample,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Sample.cs,Sample,The following statement contains a magic number: if (bitsPerComponent <= 0 || bitsPerComponent > 16)  	throw new ArgumentOutOfRangeException ("bitsPerComponent");  
Magic Number,BitMiracle.LibJpeg,SampleRow,C:\repos\b9chris_LibJpeg.Net\LibJpeg\SampleRow.cs,SampleRow,The following statement contains a magic number: if (bitsPerComponent <= 0 || bitsPerComponent > 16)  	throw new ArgumentOutOfRangeException ("bitsPerComponent");  
Magic Number,BitMiracle.LibJpeg,SampleRow,C:\repos\b9chris_LibJpeg.Net\LibJpeg\SampleRow.cs,SampleRow,The following statement contains a magic number: if (componentsPerSample <= 0 || componentsPerSample > 5)  	throw new ArgumentOutOfRangeException ("componentsPerSample");  
Magic Number,BitMiracle.LibJpeg,SampleRow,C:\repos\b9chris_LibJpeg.Net\LibJpeg\SampleRow.cs,SampleRow,The following statement contains a magic number: if (bitsPerComponent <= 0 || bitsPerComponent > 16)  	throw new ArgumentOutOfRangeException ("bitsPerComponent");  
Magic Number,BitMiracle.LibJpeg,SampleRow,C:\repos\b9chris_LibJpeg.Net\LibJpeg\SampleRow.cs,SampleRow,The following statement contains a magic number: if (componentsPerSample <= 0 || componentsPerSample > 5)  	throw new ArgumentOutOfRangeException ("componentsPerSample");  
Magic Number,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CopyStream,The following statement contains a magic number: for (; ;) {  	int bytesRead = stream.Read (block' 0' 2048);  	result.Write (block' 0' bytesRead);  	if (bytesRead < 2048)  		break;  }  
Magic Number,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CopyStream,The following statement contains a magic number: for (; ;) {  	int bytesRead = stream.Read (block' 0' 2048);  	result.Write (block' 0' bytesRead);  	if (bytesRead < 2048)  		break;  }  
Magic Number,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CopyStream,The following statement contains a magic number: if (bytesRead < 2048)  	break;  
Magic Number,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CMYK2RGB,The following statement contains a magic number: red = (byte)(R * 255);  
Magic Number,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CMYK2RGB,The following statement contains a magic number: green = (byte)(G * 255);  
Magic Number,BitMiracle.LibJpeg,Utils,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Utils.cs,CMYK2RGB,The following statement contains a magic number: blue = (byte)(B * 255);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_defaults,The following statement contains a magic number: jpeg_set_quality (75' true);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_defaults,The following statement contains a magic number: if (m_data_precision > 8)  	m_optimize_coding = true;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: switch (colorspace) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 1;  	/* JFIF specifies component ID 1 */jpeg_set_colorspace_SET_COMP (0' 1' 1' 1' 0' 0' 0);  	break;  // Note: Not used. RGB input images map to YCbCr by the time they get here.  case J_COLOR_SPACE.JCS_RGB:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag RGB */m_num_components = 3;  	jpeg_set_colorspace_SET_COMP (0' 0x52/* 'R' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x47/* 'G' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  	break;  // Used to encode RGB and YCbCr source images.  case J_COLOR_SPACE.JCS_YCbCr:  	m_write_JFIF_header = true;  	/* Write a JFIF marker */m_num_components = 3;  	/* JFIF specifies component IDs 1'2'3 *//* We default to 2x2 subsamples of chrominance */jpeg_set_colorspace_SET_COMP (0' 1' yHsamp' yVsamp' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag CMYK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 0x43/* 'C' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 0x4D/* 'M' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	m_write_Adobe_marker = true;  	/* write Adobe marker to flag YCCK */m_num_components = 4;  	jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  	jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  	jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  	break;  case J_COLOR_SPACE.JCS_UNKNOWN:  	m_num_components = m_input_components;  	if (m_num_components < 1 || m_num_components > JpegConstants.MAX_COMPONENTS)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' m_num_components' JpegConstants.MAX_COMPONENTS);  	for (ci = 0; ci < m_num_components; ci++) {  		jpeg_set_colorspace_SET_COMP (ci' ci' 1' 1' 0' 0' 0);  	}  	break;  default:  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: m_num_components = 3;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (2' 0x42/* 'B' */' 1' 1' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: m_num_components = 3;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (1' 2' cbHsamp' cbVsamp' 1' 1' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (2' 3' crHsamp' crVsamp' 1' 1' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: m_num_components = 4;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (2' 0x59/* 'Y' */' 1' 1' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (3' 0x4B/* 'K' */' 1' 1' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: m_num_components = 4;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (0' 1' 2' 2' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (1' 2' 1' 1' 1' 1' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (2' 3' 1' 1' 1' 1' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_set_colorspace,The following statement contains a magic number: jpeg_set_colorspace_SET_COMP (3' 4' 2' 2' 0' 0' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	int temp = (basic_table [i] * scale_factor + 50) / 100;  	/* limit the values to the valid range */if (temp <= 0)  		temp = 1;  	/* max quantizer needed for 12 bits */if (temp > 32767)  		temp = 32767;  	/* limit to baseline range if requested */if (force_baseline && temp > 255)  		temp = 255;  	m_quant_tbl_ptrs [which_tbl].quantval [i] = (short)temp;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	int temp = (basic_table [i] * scale_factor + 50) / 100;  	/* limit the values to the valid range */if (temp <= 0)  		temp = 1;  	/* max quantizer needed for 12 bits */if (temp > 32767)  		temp = 32767;  	/* limit to baseline range if requested */if (force_baseline && temp > 255)  		temp = 255;  	m_quant_tbl_ptrs [which_tbl].quantval [i] = (short)temp;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	int temp = (basic_table [i] * scale_factor + 50) / 100;  	/* limit the values to the valid range */if (temp <= 0)  		temp = 1;  	/* max quantizer needed for 12 bits */if (temp > 32767)  		temp = 32767;  	/* limit to baseline range if requested */if (force_baseline && temp > 255)  		temp = 255;  	m_quant_tbl_ptrs [which_tbl].quantval [i] = (short)temp;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	int temp = (basic_table [i] * scale_factor + 50) / 100;  	/* limit the values to the valid range */if (temp <= 0)  		temp = 1;  	/* max quantizer needed for 12 bits */if (temp > 32767)  		temp = 32767;  	/* limit to baseline range if requested */if (force_baseline && temp > 255)  		temp = 255;  	m_quant_tbl_ptrs [which_tbl].quantval [i] = (short)temp;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	int temp = (basic_table [i] * scale_factor + 50) / 100;  	/* limit the values to the valid range */if (temp <= 0)  		temp = 1;  	/* max quantizer needed for 12 bits */if (temp > 32767)  		temp = 32767;  	/* limit to baseline range if requested */if (force_baseline && temp > 255)  		temp = 255;  	m_quant_tbl_ptrs [which_tbl].quantval [i] = (short)temp;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	int temp = (basic_table [i] * scale_factor + 50) / 100;  	/* limit the values to the valid range */if (temp <= 0)  		temp = 1;  	/* max quantizer needed for 12 bits */if (temp > 32767)  		temp = 32767;  	/* limit to baseline range if requested */if (force_baseline && temp > 255)  		temp = 255;  	m_quant_tbl_ptrs [which_tbl].quantval [i] = (short)temp;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: if (temp > 32767)  	temp = 32767;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: if (temp > 32767)  	temp = 32767;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: temp = 32767;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: if (force_baseline && temp > 255)  	temp = 255;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: if (force_baseline && temp > 255)  	temp = 255;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_add_quant_table,The following statement contains a magic number: temp = 255;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: if (quality > 100)  	quality = 100;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: if (quality > 100)  	quality = 100;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: quality = 100;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: if (quality < 50)  	quality = 5000 / quality;  else  	quality = 200 - quality * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: if (quality < 50)  	quality = 5000 / quality;  else  	quality = 200 - quality * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: if (quality < 50)  	quality = 5000 / quality;  else  	quality = 200 - quality * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: if (quality < 50)  	quality = 5000 / quality;  else  	quality = 200 - quality * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: quality = 5000 / quality;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: quality = 200 - quality * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_quality_scaling,The following statement contains a magic number: quality = 200 - quality * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. */nscans = 10;  }  else {  	/* All-purpose script for other color spaces. */if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  		/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  	}  	else {  		/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. */nscans = 10;  }  else {  	/* All-purpose script for other color spaces. */if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  		/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  	}  	else {  		/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. */nscans = 10;  }  else {  	/* All-purpose script for other color spaces. */if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  		/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  	}  	else {  		/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. */nscans = 10;  }  else {  	/* All-purpose script for other color spaces. */if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  		/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  	}  	else {  		/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. */nscans = 10;  }  else {  	/* All-purpose script for other color spaces. */if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  		/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  	}  	else {  		/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: nscans = 10;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  	/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  }  else {  	/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  	/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  }  else {  	/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components > JpegConstants.MAX_COMPS_IN_SCAN) {  	/* 2 DC + 4 AC scans per component */nscans = 6 * m_num_components;  }  else {  	/* 2 DC scans; 4 AC scans per component */nscans = 2 + 4 * m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: nscans = 6 * m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: nscans = 2 + 4 * m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: nscans = 2 + 4 * m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_script_space == null || m_script_space_size < nscans) {  	m_script_space_size = Math.Max (nscans' 10);  	m_script_space = new jpeg_scan_info[m_script_space_size];  	for (int i = 0; i < m_script_space_size; i++)  		m_script_space [i] = new jpeg_scan_info ();  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: m_script_space_size = Math.Max (nscans' 10);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: if (m_num_components == 3 && m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  	/* Custom script for YCbCr color images. *//* Initial DC scan */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	/* Initial AC scan: get some luma data out in a hurry */fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  	/* Chroma data is too small to be worth expending many scans on */fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  	fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  	/* Complete spectral selection for luma AC */fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  	/* Refine next bit of luma AC */fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  	/* Finish DC successive approximation */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	/* Finish AC successive approximation */fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  	fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  	/* Luma bottom bit comes last since it's usually largest scan */fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  }  else {  	/* All-purpose script for other color spaces. *//* Successive approximation first pass */fill_dc_scans (ref scanIndex' m_num_components' 0' 1);  	fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  	fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  	/* Successive approximation second pass */fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  	/* Successive approximation final pass */fill_dc_scans (ref scanIndex' m_num_components' 1' 0);  	fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 1' 5' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 2' 1' 63' 0' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 1' 1' 63' 0' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 6' 63' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 1' 63' 2' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 2' 1' 63' 1' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 1' 1' 63' 1' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_a_scan (ref scanIndex' 0' 1' 63' 1' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 1' 5' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 6' 63' 0' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 1' 63' 2' 1);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,jpeg_simple_progression,The following statement contains a magic number: fill_scans (ref scanIndex' m_num_components' 1' 63' 1' 0);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The following statement contains a magic number: for (int scanno = 1; scanno <= m_num_scans; scanno++) {  	jpeg_scan_info scanInfo = m_scan_info [scanno - 1];  	/* Validate component indexes */int ncomps = scanInfo.comps_in_scan;  	if (ncomps <= 0 || ncomps > JpegConstants.MAX_COMPS_IN_SCAN)  		ERREXIT (J_MESSAGE_CODE.JERR_COMPONENT_COUNT' ncomps' JpegConstants.MAX_COMPS_IN_SCAN);  	for (int ci = 0; ci < ncomps; ci++) {  		int thisi = scanInfo.component_index [ci];  		if (thisi < 0 || thisi >= m_num_components)  			ERREXIT (J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT' scanno);  		/* Components must appear in SOF order within each scan */if (ci > 0 && thisi <= scanInfo.component_index [ci - 1])  			ERREXIT (J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT' scanno);  	}  	/* Validate progression parameters */int Ss = scanInfo.Ss;  	int Se = scanInfo.Se;  	int Ah = scanInfo.Ah;  	int Al = scanInfo.Al;  	if (m_progressive_mode) {  		/* The JPEG spec simply gives the ranges 0..13 for Ah and Al' but that 					* seems wrong: the upper bound ought to depend on data precision. 					* Perhaps they really meant 0..N+1 for N-bit precision. 					* Here we allow 0..10 for 8-bit data; Al larger than 10 results in 					* out-of-range reconstructed DC values during the first DC scan' 					* which might cause problems for some decoders. 					*/const int MAX_AH_AL = 10;  		if (Ss < 0 || Ss >= JpegConstants.DCTSIZE2 || Se < Ss || Se >= JpegConstants.DCTSIZE2 || Ah < 0 || Ah > MAX_AH_AL || Al < 0 || Al > MAX_AH_AL) {  			ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  		}  		if (Ss == 0) {  			if (Se != 0)  				/* DC and AC together not OK */ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  		}  		else {  			if (ncomps != 1)  				/* AC scans must be for only one component */ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  		}  		for (int ci = 0; ci < ncomps; ci++) {  			int lastBitComponentIndex = scanInfo.component_index [ci];  			if (Ss != 0 && last_bitpos [lastBitComponentIndex] [0] < 0)  				/* AC without prior DC scan */ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  			for (int coefi = Ss; coefi <= Se; coefi++) {  				if (last_bitpos [lastBitComponentIndex] [coefi] < 0) {  					/* first scan of this coefficient */if (Ah != 0)  						ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  				}  				else {  					/* not first scan */if (Ah != last_bitpos [lastBitComponentIndex] [coefi] || Al != Ah - 1)  						ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  				}  				last_bitpos [lastBitComponentIndex] [coefi] = Al;  			}  		}  	}  	else {  		/* For sequential JPEG' all progression parameters must be these: */if (Ss != 0 || Se != JpegConstants.DCTSIZE2 - 1 || Ah != 0 || Al != 0)  			ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  		/* Make sure components are not sent twice */for (int ci = 0; ci < ncomps; ci++) {  			int thisi = scanInfo.component_index [ci];  			if (component_sent [thisi])  				ERREXIT (J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT' scanno);  			component_sent [thisi] = true;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,validate_script,The following statement contains a magic number: if (m_progressive_mode) {  	/* The JPEG spec simply gives the ranges 0..13 for Ah and Al' but that 					* seems wrong: the upper bound ought to depend on data precision. 					* Perhaps they really meant 0..N+1 for N-bit precision. 					* Here we allow 0..10 for 8-bit data; Al larger than 10 results in 					* out-of-range reconstructed DC values during the first DC scan' 					* which might cause problems for some decoders. 					*/const int MAX_AH_AL = 10;  	if (Ss < 0 || Ss >= JpegConstants.DCTSIZE2 || Se < Ss || Se >= JpegConstants.DCTSIZE2 || Ah < 0 || Ah > MAX_AH_AL || Al < 0 || Al > MAX_AH_AL) {  		ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  	}  	if (Ss == 0) {  		if (Se != 0)  			/* DC and AC together not OK */ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  	}  	else {  		if (ncomps != 1)  			/* AC scans must be for only one component */ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  	}  	for (int ci = 0; ci < ncomps; ci++) {  		int lastBitComponentIndex = scanInfo.component_index [ci];  		if (Ss != 0 && last_bitpos [lastBitComponentIndex] [0] < 0)  			/* AC without prior DC scan */ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  		for (int coefi = Ss; coefi <= Se; coefi++) {  			if (last_bitpos [lastBitComponentIndex] [coefi] < 0) {  				/* first scan of this coefficient */if (Ah != 0)  					ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  			}  			else {  				/* not first scan */if (Ah != last_bitpos [lastBitComponentIndex] [coefi] || Al != Ah - 1)  					ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  			}  			last_bitpos [lastBitComponentIndex] [coefi] = Al;  		}  	}  }  else {  	/* For sequential JPEG' all progression parameters must be these: */if (Ss != 0 || Se != JpegConstants.DCTSIZE2 - 1 || Ah != 0 || Al != 0)  		ERREXIT (J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT' scanno);  	/* Make sure components are not sent twice */for (int ci = 0; ci < ncomps; ci++) {  		int thisi = scanInfo.component_index [ci];  		if (component_sent [thisi])  			ERREXIT (J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT' scanno);  		component_sent [thisi] = true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,add_huff_table,The following statement contains a magic number: for (int len = 1; len <= 16; len++)  	nsymbols += bits [len];  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,add_huff_table,The following statement contains a magic number: if (nsymbols < 1 || nsymbols > 256)  	ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 8 <= m_scale_denom) {  	/* Provide 1/8 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  	m_min_DCT_scaled_size = 1;  }  else if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_output_width = JpegUtils.jdiv_round_up (m_image_width' 8);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_output_height = JpegUtils.jdiv_round_up (m_image_height' 8);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 4 <= m_scale_denom) {  	/* Provide 1/4 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  	m_min_DCT_scaled_size = 2;  }  else if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_output_width = JpegUtils.jdiv_round_up (m_image_width' 4);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_output_height = JpegUtils.jdiv_round_up (m_image_height' 4);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_min_DCT_scaled_size = 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: if (m_scale_num * 2 <= m_scale_denom) {  	/* Provide 1/2 scaling */m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  	m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  	m_min_DCT_scaled_size = 4;  }  else {  	/* Provide 1/1 scaling */m_output_width = m_image_width;  	m_output_height = m_image_height;  	m_min_DCT_scaled_size = JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_output_width = JpegUtils.jdiv_round_up (m_image_width' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_output_height = JpegUtils.jdiv_round_up (m_image_height' 2);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_min_DCT_scaled_size = 4;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: for (int ci = 0; ci < m_num_components; ci++) {  	int ssize = m_min_DCT_scaled_size;  	while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) {  		ssize = ssize * 2;  	}  	m_comp_info [ci].DCT_scaled_size = ssize;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: for (int ci = 0; ci < m_num_components; ci++) {  	int ssize = m_min_DCT_scaled_size;  	while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) {  		ssize = ssize * 2;  	}  	m_comp_info [ci].DCT_scaled_size = ssize;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: for (int ci = 0; ci < m_num_components; ci++) {  	int ssize = m_min_DCT_scaled_size;  	while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) {  		ssize = ssize * 2;  	}  	m_comp_info [ci].DCT_scaled_size = ssize;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) {  	ssize = ssize * 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) {  	ssize = ssize * 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: while (ssize < JpegConstants.DCTSIZE && (m_comp_info [ci].H_samp_factor * ssize * 2 <= m_max_h_samp_factor * m_min_DCT_scaled_size) && (m_comp_info [ci].V_samp_factor * ssize * 2 <= m_max_v_samp_factor * m_min_DCT_scaled_size)) {  	ssize = ssize * 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: ssize = ssize * 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: switch (m_out_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_out_color_components = 1;  	break;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	m_out_color_components = 3;  	break;  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  	m_out_color_components = 4;  	break;  default:  	/* else must be same colorspace as in file */m_out_color_components = m_num_components;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: switch (m_out_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	m_out_color_components = 1;  	break;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	m_out_color_components = 3;  	break;  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  	m_out_color_components = 4;  	break;  default:  	/* else must be same colorspace as in file */m_out_color_components = m_num_components;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_out_color_components = 3;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_calc_output_dimensions,The following statement contains a magic number: m_out_color_components = 4;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The following statement contains a magic number: if (m_jpeg_color_space != J_COLOR_SPACE.JCS_YCbCr || m_num_components != 3 || m_out_color_space != J_COLOR_SPACE.JCS_RGB || m_out_color_components != JpegConstants.RGB_PIXELSIZE) {  	return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The following statement contains a magic number: if (m_comp_info [0].H_samp_factor != 2 || m_comp_info [1].H_samp_factor != 1 || m_comp_info [2].H_samp_factor != 1 || m_comp_info [0].V_samp_factor > 2 || m_comp_info [1].V_samp_factor != 1 || m_comp_info [2].V_samp_factor != 1) {  	return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The following statement contains a magic number: if (m_comp_info [0].H_samp_factor != 2 || m_comp_info [1].H_samp_factor != 1 || m_comp_info [2].H_samp_factor != 1 || m_comp_info [0].V_samp_factor > 2 || m_comp_info [1].V_samp_factor != 1 || m_comp_info [2].V_samp_factor != 1) {  	return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The following statement contains a magic number: if (m_comp_info [0].H_samp_factor != 2 || m_comp_info [1].H_samp_factor != 1 || m_comp_info [2].H_samp_factor != 1 || m_comp_info [0].V_samp_factor > 2 || m_comp_info [1].V_samp_factor != 1 || m_comp_info [2].V_samp_factor != 1) {  	return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The following statement contains a magic number: if (m_comp_info [0].H_samp_factor != 2 || m_comp_info [1].H_samp_factor != 1 || m_comp_info [2].H_samp_factor != 1 || m_comp_info [0].V_samp_factor > 2 || m_comp_info [1].V_samp_factor != 1 || m_comp_info [2].V_samp_factor != 1) {  	return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,use_merged_upsample,The following statement contains a magic number: if (m_comp_info [0].DCT_scaled_size != m_min_DCT_scaled_size || m_comp_info [1].DCT_scaled_size != m_min_DCT_scaled_size || m_comp_info [2].DCT_scaled_size != m_min_DCT_scaled_size) {  	return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,transdecode_master_selection,The following statement contains a magic number: if (m_progress != null) {  	int nscans = 1;  	/* Estimate number of scans to set pass_limit. */if (m_progressive_mode) {  		/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_num_components;  	}  	else if (m_inputctl.HasMultipleScans ()) {  		/* For a nonprogressive multiscan file' estimate 1 scan per component. */nscans = m_num_components;  	}  	m_progress.Pass_counter = 0;  	m_progress.Pass_limit = m_total_iMCU_rows * nscans;  	m_progress.Completed_passes = 0;  	m_progress.Total_passes = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,transdecode_master_selection,The following statement contains a magic number: if (m_progress != null) {  	int nscans = 1;  	/* Estimate number of scans to set pass_limit. */if (m_progressive_mode) {  		/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_num_components;  	}  	else if (m_inputctl.HasMultipleScans ()) {  		/* For a nonprogressive multiscan file' estimate 1 scan per component. */nscans = m_num_components;  	}  	m_progress.Pass_counter = 0;  	m_progress.Pass_limit = m_total_iMCU_rows * nscans;  	m_progress.Completed_passes = 0;  	m_progress.Total_passes = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,transdecode_master_selection,The following statement contains a magic number: if (m_progressive_mode) {  	/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_num_components;  }  else if (m_inputctl.HasMultipleScans ()) {  	/* For a nonprogressive multiscan file' estimate 1 scan per component. */nscans = m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,transdecode_master_selection,The following statement contains a magic number: if (m_progressive_mode) {  	/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_num_components;  }  else if (m_inputctl.HasMultipleScans ()) {  	/* For a nonprogressive multiscan file' estimate 1 scan per component. */nscans = m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,transdecode_master_selection,The following statement contains a magic number: nscans = 2 + 3 * m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,transdecode_master_selection,The following statement contains a magic number: nscans = 2 + 3 * m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_num_components) {  case 1:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	m_out_color_space = J_COLOR_SPACE.JCS_GRAYSCALE;  	break;  case 3:  	if (m_saw_JFIF_marker) {  		/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  			break;  		case 1:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  			/* assume it's YCbCr */break;  		}  	}  	else {  		/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  		int cid1 = m_comp_info [1].Component_id;  		int cid2 = m_comp_info [2].Component_id;  		if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  			/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  		else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  			/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		}  		else {  			TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  			/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		}  	}  	/* Always guess RGB is proper output colorspace. */m_out_color_space = J_COLOR_SPACE.JCS_RGB;  	break;  case 4:  	if (m_saw_Adobe_marker) {  		switch (m_Adobe_transform) {  		case 0:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  			break;  		case 2:  			m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		default:  			WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  			/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  			break;  		}  	}  	else {  		/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	}  	m_out_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  default:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	m_out_color_space = J_COLOR_SPACE.JCS_UNKNOWN;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_JFIF_marker) {  	/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_JFIF_marker) {  	/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_JFIF_marker) {  	/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_JFIF_marker) {  	/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_JFIF_marker) {  	/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_JFIF_marker) {  	/* JFIF implies YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  		break;  	case 1:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  		/* assume it's YCbCr */break;  	}  }  else {  	/* Saw no special markers' try to guess from the component IDs */int cid0 = m_comp_info [0].Component_id;  	int cid1 = m_comp_info [1].Component_id;  	int cid2 = m_comp_info [2].Component_id;  	if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  		/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  	else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  		/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  	}  	else {  		TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  		/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  	/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  	/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  	/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  	/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 1 && cid1 == 2 && cid2 == 3) {  	/* assume JFIF w/out marker */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  else if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (cid0 == 82 && cid1 == 71 && cid2 == 66) {  	/* ASCII 'R'' 'G'' 'B' */m_jpeg_color_space = J_COLOR_SPACE.JCS_RGB;  }  else {  	TRACEMS (1' J_MESSAGE_CODE.JTRC_UNKNOWN_IDS' cid0' cid1' cid2);  	/* assume it's YCbCr */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCbCr;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: if (m_saw_Adobe_marker) {  	switch (m_Adobe_transform) {  	case 0:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  		break;  	case 2:  		m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  		break;  	default:  		WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  		/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  		break;  	}  }  else {  	/* No special markers' assume straight CMYK. */m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: switch (m_Adobe_transform) {  case 0:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_CMYK;  	break;  case 2:  	m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  	break;  default:  	WARNMS (J_MESSAGE_CODE.JWRN_ADOBE_XFORM' m_Adobe_transform);  	/* assume it's YCCK */m_jpeg_color_space = J_COLOR_SPACE.JCS_YCCK;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,default_decompress_parms,The following statement contains a magic number: m_desired_number_of_colors = 256;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_error_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_error_mgr.cs,emit_message,The following statement contains a magic number: if (msg_level < 0) {  	/* It's a warning message.  Since corrupt files may generate many warnings'                  * the policy implemented here is to show only the first warning'                  * unless trace_level >= 3.                  */if (m_num_warnings == 0 || m_trace_level >= 3)  		output_message ();  	/* Always count warnings in num_warnings. */m_num_warnings++;  }  else {  	/* It's a trace message.  Show it if trace_level >= msg_level. */if (m_trace_level >= msg_level)  		output_message ();  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_error_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_error_mgr.cs,emit_message,The following statement contains a magic number: if (m_num_warnings == 0 || m_trace_level >= 3)  	output_message ();  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: for (; ;) {  	if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  		/* invalid marker */action = 2;  	}  	else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  		/* valid non-restart marker */action = 3;  	}  	else {  		if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  			/* one of the next two expected restarts */action = 3;  		}  		else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  			/* a prior restart' so advance */action = 2;  		}  		else {  			/* desired restart or too far away */action = 1;  		}  	}  	cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  	switch (action) {  	case 1:  		/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  		return true;  	case 2:  		/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  			return false;  		break;  	case 3:  		/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.SOF0) {  	/* invalid marker */action = 2;  }  else if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: action = 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker < (int)JPEG_MARKER.RST0 || cinfo.m_unread_marker > (int)JPEG_MARKER.RST7) {  	/* valid non-restart marker */action = 3;  }  else {  	if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  		/* one of the next two expected restarts */action = 3;  	}  	else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  		/* a prior restart' so advance */action = 2;  	}  	else {  		/* desired restart or too far away */action = 1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: action = 3;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired + 2) & 7))) {  	/* one of the next two expected restarts */action = 3;  }  else if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: action = 3;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: if (cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 1) & 7)) || cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + ((desired - 2) & 7))) {  	/* a prior restart' so advance */action = 2;  }  else {  	/* desired restart or too far away */action = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: action = 2;  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: cinfo.TRACEMS (4' J_MESSAGE_CODE.JTRC_RECOVERY_ACTION' cinfo.m_unread_marker' action);  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: switch (action) {  case 1:  	/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  	return true;  case 2:  	/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  		return false;  	break;  case 3:  	/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following statement contains a magic number: switch (action) {  case 1:  	/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  	return true;  case 2:  	/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  		return false;  	break;  case 3:  	/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  }  
Magic Number,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,GetTwoBytes,The following statement contains a magic number: V = m_next_input_byte [m_position] << 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	savable_state state = new savable_state ();  	state.Assign (m_saved);  	/* Outer loop handles each block in the MCU */for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  		/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  		if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		if (s != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			int r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  		}  		if (m_dc_needed [blkn]) {  			/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  			s += state.last_dc_val [ci];  			state.last_dc_val [ci] = s;  			/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  		}  		if (m_ac_needed [blkn]) {  			/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (s' get_buffer' ref bits_left);  					s = HUFF_EXTEND (r' s);  					/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  		else {  			/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  				if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  					return false;  				int r = s >> 4;  				s &= 15;  				if (s != 0) {  					k += r;  					if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  						return false;  					DROP_BITS (s' ref bits_left);  				}  				else {  					if (r != 15)  						break;  					k += 15;  				}  			}  		}  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.Assign (state);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int blkn = 0; blkn < m_cinfo.m_blocks_in_MCU; blkn++) {  	/* Decode a single block's worth of coefficients *//* Section F.2.2.1: decode the DC coefficient difference */int s;  	if (!HUFF_DECODE (out s' ref br_state' m_dc_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	if (s != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		int r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  	}  	if (m_dc_needed [blkn]) {  		/* Convert DC difference to actual value' update last_dc_val */int ci = m_cinfo.m_MCU_membership [blkn];  		s += state.last_dc_val [ci];  		state.last_dc_val [ci] = s;  		/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */MCU_data [blkn] [0] = (short)s;  	}  	if (m_ac_needed [blkn]) {  		/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  	else {  		/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  			if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				DROP_BITS (s' ref bits_left);  			}  			else {  				if (r != 15)  					break;  				k += 15;  			}  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (m_ac_needed [blkn]) {  	/* Section F.2.2.2: decode the AC coefficients *//* Since zeroes are skipped' output area must be cleared beforehand */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  else {  	/* Section F.2.2.2: decode the AC coefficients *//* In this path we just discard the values */for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  		if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			DROP_BITS (s' ref bits_left);  		}  		else {  			if (r != 15)  				break;  			k += 15;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: s &= 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (s != 0) {  	k += r;  	if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  		return false;  	r = GET_BITS (s' get_buffer' ref bits_left);  	s = HUFF_EXTEND (r' s);  	/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  }  else {  	if (r != 15)  		break;  	k += 15;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (s != 0) {  	k += r;  	if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  		return false;  	r = GET_BITS (s' get_buffer' ref bits_left);  	s = HUFF_EXTEND (r' s);  	/* Output coefficient in natural (dezigzagged) order.                                    * Note: the extra entries in jpeg_natural_order[] will save us                                    * if k >= DCTSIZE2' which could happen if the data is corrupted.                                    */MCU_data [blkn] [JpegUtils.jpeg_natural_order [k]] = (short)s;  }  else {  	if (r != 15)  		break;  	k += 15;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (r != 15)  	break;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: k += 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		DROP_BITS (s' ref bits_left);  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		DROP_BITS (s' ref bits_left);  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		DROP_BITS (s' ref bits_left);  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	if (!HUFF_DECODE (out s' ref br_state' m_ac_cur_tbls [blkn]' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		DROP_BITS (s' ref bits_left);  	}  	else {  		if (r != 15)  			break;  		k += 15;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: s &= 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (s != 0) {  	k += r;  	if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  		return false;  	DROP_BITS (s' ref bits_left);  }  else {  	if (r != 15)  		break;  	k += 15;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (s != 0) {  	k += r;  	if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  		return false;  	DROP_BITS (s' ref bits_left);  }  else {  	if (r != 15)  		break;  	k += 15;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: if (r != 15)  	break;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,decode_mcu,The following statement contains a magic number: k += 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_decoder.cs,process_restart,The following statement contains a magic number: m_cinfo.m_marker.SkipBytes (m_bitstate.bits_left / 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,The following statement contains a magic number: switch (cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_num_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  default:  	/* JCS_UNKNOWN can be anything */if (cinfo.m_num_components < 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,The following statement contains a magic number: switch (cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_num_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  default:  	/* JCS_UNKNOWN can be anything */if (cinfo.m_num_components < 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,The following statement contains a magic number: if (cinfo.m_num_components != 3)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,The following statement contains a magic number: if (cinfo.m_num_components != 4)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,The following statement contains a magic number: switch (cinfo.m_out_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	cinfo.m_out_color_components = 1;  	if (cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_GRAYSCALE || cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  		m_converter = ColorConverter.grayscale_converter;  		/* For color->grayscale conversion' only the Y (0) component is needed */for (int ci = 1; ci < cinfo.m_num_components; ci++)  			cinfo.Comp_info [ci].component_needed = false;  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_RGB:  	cinfo.m_out_color_components = JpegConstants.RGB_PIXELSIZE;  	if (cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_YCbCr) {  		m_converter = ColorConverter.ycc_rgb_converter;  		build_ycc_rgb_table ();  	}  	else if (cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_GRAYSCALE)  		m_converter = ColorConverter.gray_rgb_converter;  	else if (cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_RGB)  		m_converter = ColorConverter.null_converter;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	cinfo.m_out_color_components = 4;  	if (cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_YCCK) {  		m_converter = ColorConverter.ycck_cmyk_converter;  		build_ycc_rgb_table ();  	}  	else if (cinfo.m_jpeg_color_space == J_COLOR_SPACE.JCS_CMYK)  		m_converter = ColorConverter.null_converter;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  default:  	/* Permit null conversion to same output space */if (cinfo.m_out_color_space == cinfo.m_jpeg_color_space) {  		cinfo.m_out_color_components = cinfo.m_num_components;  		m_converter = ColorConverter.null_converter;  	}  	else {  		/* unsupported non-null conversion */cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	}  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,jpeg_color_deconverter,The following statement contains a magic number: cinfo.m_out_color_components = 4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycc_rgb_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < m_cinfo.m_output_width; col++) {  		int y = input_buf [0] [input_row + component0RowOffset] [col];  		int cb = input_buf [1] [input_row + component1RowOffset] [col];  		int cr = input_buf [2] [input_row + component2RowOffset] [col];  		/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset + JpegConstants.RGB_RED] = limit [limitOffset + y + m_Cr_r_tab [cr]];  		output_buf [output_row + row] [columnOffset + JpegConstants.RGB_GREEN] = limit [limitOffset + y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS)];  		output_buf [output_row + row] [columnOffset + JpegConstants.RGB_BLUE] = limit [limitOffset + y + m_Cb_b_tab [cb]];  		columnOffset += JpegConstants.RGB_PIXELSIZE;  	}  	input_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycc_rgb_convert,The following statement contains a magic number: for (int col = 0; col < m_cinfo.m_output_width; col++) {  	int y = input_buf [0] [input_row + component0RowOffset] [col];  	int cb = input_buf [1] [input_row + component1RowOffset] [col];  	int cr = input_buf [2] [input_row + component2RowOffset] [col];  	/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset + JpegConstants.RGB_RED] = limit [limitOffset + y + m_Cr_r_tab [cr]];  	output_buf [output_row + row] [columnOffset + JpegConstants.RGB_GREEN] = limit [limitOffset + y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS)];  	output_buf [output_row + row] [columnOffset + JpegConstants.RGB_BLUE] = limit [limitOffset + y + m_Cb_b_tab [cb]];  	columnOffset += JpegConstants.RGB_PIXELSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int y = input_buf [0] [input_row + component0RowOffset] [col];  		int cb = input_buf [1] [input_row + component1RowOffset] [col];  		int cr = input_buf [2] [input_row + component2RowOffset] [col];  		/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  		/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  		/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  		/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  		columnOffset += 4;  	}  	input_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int y = input_buf [0] [input_row + component0RowOffset] [col];  		int cb = input_buf [1] [input_row + component1RowOffset] [col];  		int cr = input_buf [2] [input_row + component2RowOffset] [col];  		/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  		/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  		/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  		/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  		columnOffset += 4;  	}  	input_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int y = input_buf [0] [input_row + component0RowOffset] [col];  		int cb = input_buf [1] [input_row + component1RowOffset] [col];  		int cr = input_buf [2] [input_row + component2RowOffset] [col];  		/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  		/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  		/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  		/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  		columnOffset += 4;  	}  	input_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int y = input_buf [0] [input_row + component0RowOffset] [col];  		int cb = input_buf [1] [input_row + component1RowOffset] [col];  		int cr = input_buf [2] [input_row + component2RowOffset] [col];  		/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  		/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  		/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  		/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  		columnOffset += 4;  	}  	input_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int y = input_buf [0] [input_row + component0RowOffset] [col];  		int cb = input_buf [1] [input_row + component1RowOffset] [col];  		int cr = input_buf [2] [input_row + component2RowOffset] [col];  		/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  		/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  		/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  		/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  		columnOffset += 4;  	}  	input_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int y = input_buf [0] [input_row + component0RowOffset] [col];  	int cb = input_buf [1] [input_row + component1RowOffset] [col];  	int cr = input_buf [2] [input_row + component2RowOffset] [col];  	/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  	/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  	/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  	/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  	columnOffset += 4;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int y = input_buf [0] [input_row + component0RowOffset] [col];  	int cb = input_buf [1] [input_row + component1RowOffset] [col];  	int cr = input_buf [2] [input_row + component2RowOffset] [col];  	/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  	/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  	/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  	/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  	columnOffset += 4;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int y = input_buf [0] [input_row + component0RowOffset] [col];  	int cb = input_buf [1] [input_row + component1RowOffset] [col];  	int cr = input_buf [2] [input_row + component2RowOffset] [col];  	/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  	/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  	/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  	/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  	columnOffset += 4;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int y = input_buf [0] [input_row + component0RowOffset] [col];  	int cb = input_buf [1] [input_row + component1RowOffset] [col];  	int cr = input_buf [2] [input_row + component2RowOffset] [col];  	/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  	/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  	/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  	/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  	columnOffset += 4;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int y = input_buf [0] [input_row + component0RowOffset] [col];  	int cb = input_buf [1] [input_row + component1RowOffset] [col];  	int cr = input_buf [2] [input_row + component2RowOffset] [col];  	/* Range-limiting is essential due to noise introduced by DCT losses. */output_buf [output_row + row] [columnOffset] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cr_r_tab [cr])];  	/* red */output_buf [output_row + row] [columnOffset + 1] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS))];  	/* green */output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  	/* blue *//* K passes through unchanged *//* don't need GETJSAMPLE here */output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  	columnOffset += 4;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: output_buf [output_row + row] [columnOffset + 2] = limit [limitOffset + JpegConstants.MAXJSAMPLE - (y + m_Cb_b_tab [cb])];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: output_buf [output_row + row] [columnOffset + 3] = input_buf [3] [input_row + component3RowOffset] [col];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,ycck_cmyk_convert,The following statement contains a magic number: columnOffset += 4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_deconverter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_deconverter.cs,FIX,The following statement contains a magic number: return (int)(x * (1L << SCALEBITS) + 0.5);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_comps_in_scan; ci++) {  	int dctbl = m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Dc_tbl_no;  	int actbl = m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Ac_tbl_no;  	if (m_gather_statistics) {  		/* Check for invalid table indexes *//* (make_c_derived_tbl does this in the other path) */if (dctbl < 0 || dctbl >= JpegConstants.NUM_HUFF_TBLS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' dctbl);  		if (actbl < 0 || actbl >= JpegConstants.NUM_HUFF_TBLS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' actbl);  		/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_dc_count_ptrs [dctbl] == null)  			m_dc_count_ptrs [dctbl] = new long[257];  		Array.Clear (m_dc_count_ptrs [dctbl]' 0' m_dc_count_ptrs [dctbl].Length);  		if (m_ac_count_ptrs [actbl] == null)  			m_ac_count_ptrs [actbl] = new long[257];  		Array.Clear (m_ac_count_ptrs [actbl]' 0' m_ac_count_ptrs [actbl].Length);  	}  	else {  		/* Compute derived values for Huffman tables *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (true' dctbl' ref m_dc_derived_tbls [dctbl]);  		jpeg_make_c_derived_tbl (false' actbl' ref m_ac_derived_tbls [actbl]);  	}  	/* Initialize DC predictions to 0 */m_saved.last_dc_val [ci] = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_comps_in_scan; ci++) {  	int dctbl = m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Dc_tbl_no;  	int actbl = m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]].Ac_tbl_no;  	if (m_gather_statistics) {  		/* Check for invalid table indexes *//* (make_c_derived_tbl does this in the other path) */if (dctbl < 0 || dctbl >= JpegConstants.NUM_HUFF_TBLS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' dctbl);  		if (actbl < 0 || actbl >= JpegConstants.NUM_HUFF_TBLS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' actbl);  		/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_dc_count_ptrs [dctbl] == null)  			m_dc_count_ptrs [dctbl] = new long[257];  		Array.Clear (m_dc_count_ptrs [dctbl]' 0' m_dc_count_ptrs [dctbl].Length);  		if (m_ac_count_ptrs [actbl] == null)  			m_ac_count_ptrs [actbl] = new long[257];  		Array.Clear (m_ac_count_ptrs [actbl]' 0' m_ac_count_ptrs [actbl].Length);  	}  	else {  		/* Compute derived values for Huffman tables *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (true' dctbl' ref m_dc_derived_tbls [dctbl]);  		jpeg_make_c_derived_tbl (false' actbl' ref m_ac_derived_tbls [actbl]);  	}  	/* Initialize DC predictions to 0 */m_saved.last_dc_val [ci] = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_gather_statistics) {  	/* Check for invalid table indexes *//* (make_c_derived_tbl does this in the other path) */if (dctbl < 0 || dctbl >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' dctbl);  	if (actbl < 0 || actbl >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' actbl);  	/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_dc_count_ptrs [dctbl] == null)  		m_dc_count_ptrs [dctbl] = new long[257];  	Array.Clear (m_dc_count_ptrs [dctbl]' 0' m_dc_count_ptrs [dctbl].Length);  	if (m_ac_count_ptrs [actbl] == null)  		m_ac_count_ptrs [actbl] = new long[257];  	Array.Clear (m_ac_count_ptrs [actbl]' 0' m_ac_count_ptrs [actbl].Length);  }  else {  	/* Compute derived values for Huffman tables *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (true' dctbl' ref m_dc_derived_tbls [dctbl]);  	jpeg_make_c_derived_tbl (false' actbl' ref m_ac_derived_tbls [actbl]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_gather_statistics) {  	/* Check for invalid table indexes *//* (make_c_derived_tbl does this in the other path) */if (dctbl < 0 || dctbl >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' dctbl);  	if (actbl < 0 || actbl >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' actbl);  	/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_dc_count_ptrs [dctbl] == null)  		m_dc_count_ptrs [dctbl] = new long[257];  	Array.Clear (m_dc_count_ptrs [dctbl]' 0' m_dc_count_ptrs [dctbl].Length);  	if (m_ac_count_ptrs [actbl] == null)  		m_ac_count_ptrs [actbl] = new long[257];  	Array.Clear (m_ac_count_ptrs [actbl]' 0' m_ac_count_ptrs [actbl].Length);  }  else {  	/* Compute derived values for Huffman tables *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (true' dctbl' ref m_dc_derived_tbls [dctbl]);  	jpeg_make_c_derived_tbl (false' actbl' ref m_ac_derived_tbls [actbl]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_dc_count_ptrs [dctbl] == null)  	m_dc_count_ptrs [dctbl] = new long[257];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: m_dc_count_ptrs [dctbl] = new long[257];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_ac_count_ptrs [actbl] == null)  	m_ac_count_ptrs [actbl] = new long[257];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,start_pass,The following statement contains a magic number: m_ac_count_ptrs [actbl] = new long[257];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_mcu_huff,The following statement contains a magic number: if (m_cinfo.m_restart_interval != 0) {  	if (m_restarts_to_go == 0) {  		m_restarts_to_go = m_cinfo.m_restart_interval;  		m_next_restart_num++;  		m_next_restart_num &= 7;  	}  	m_restarts_to_go--;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_mcu_huff,The following statement contains a magic number: if (m_restarts_to_go == 0) {  	m_restarts_to_go = m_cinfo.m_restart_interval;  	m_next_restart_num++;  	m_next_restart_num &= 7;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_mcu_huff,The following statement contains a magic number: m_next_restart_num &= 7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	temp = block [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  	}  	else {  		/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  			if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  				return false;  			r -= 16;  		}  		temp2 = temp;  		if (temp < 0) {  			temp = -temp;  			/* temp is abs value of input *//* This code assumes we are on a two's complement machine */temp2--;  		}  		/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  		/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  			nbits++;  		/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  		/* Emit Huffman symbol for run length / number of bits */int i = (r << 4) + nbits;  		if (!emit_bits (state' actbl.ehufco [i]' actbl.ehufsi [i]))  			return false;  		/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits))  			return false;  		r = 0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	temp = block [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  	}  	else {  		/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  			if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  				return false;  			r -= 16;  		}  		temp2 = temp;  		if (temp < 0) {  			temp = -temp;  			/* temp is abs value of input *//* This code assumes we are on a two's complement machine */temp2--;  		}  		/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  		/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  			nbits++;  		/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  		/* Emit Huffman symbol for run length / number of bits */int i = (r << 4) + nbits;  		if (!emit_bits (state' actbl.ehufco [i]' actbl.ehufsi [i]))  			return false;  		/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits))  			return false;  		r = 0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	temp = block [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  	}  	else {  		/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  			if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  				return false;  			r -= 16;  		}  		temp2 = temp;  		if (temp < 0) {  			temp = -temp;  			/* temp is abs value of input *//* This code assumes we are on a two's complement machine */temp2--;  		}  		/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  		/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  			nbits++;  		/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  		/* Emit Huffman symbol for run length / number of bits */int i = (r << 4) + nbits;  		if (!emit_bits (state' actbl.ehufco [i]' actbl.ehufsi [i]))  			return false;  		/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits))  			return false;  		r = 0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: if (temp == 0) {  	r++;  }  else {  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  			return false;  		r -= 16;  	}  	temp2 = temp;  	if (temp < 0) {  		temp = -temp;  		/* temp is abs value of input *//* This code assumes we are on a two's complement machine */temp2--;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Emit Huffman symbol for run length / number of bits */int i = (r << 4) + nbits;  	if (!emit_bits (state' actbl.ehufco [i]' actbl.ehufsi [i]))  		return false;  	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits))  		return false;  	r = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: if (temp == 0) {  	r++;  }  else {  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  			return false;  		r -= 16;  	}  	temp2 = temp;  	if (temp < 0) {  		temp = -temp;  		/* temp is abs value of input *//* This code assumes we are on a two's complement machine */temp2--;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Emit Huffman symbol for run length / number of bits */int i = (r << 4) + nbits;  	if (!emit_bits (state' actbl.ehufco [i]' actbl.ehufsi [i]))  		return false;  	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits))  		return false;  	r = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: if (temp == 0) {  	r++;  }  else {  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  			return false;  		r -= 16;  	}  	temp2 = temp;  	if (temp < 0) {  		temp = -temp;  		/* temp is abs value of input *//* This code assumes we are on a two's complement machine */temp2--;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Emit Huffman symbol for run length / number of bits */int i = (r << 4) + nbits;  	if (!emit_bits (state' actbl.ehufco [i]' actbl.ehufsi [i]))  		return false;  	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */if (!emit_bits (state' temp2' nbits))  		return false;  	r = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: while (r > 15) {  	if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  		return false;  	r -= 16;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: while (r > 15) {  	if (!emit_bits (state' actbl.ehufco [0xF0]' actbl.ehufsi [0xF0]))  		return false;  	r -= 16;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,encode_one_block,The following statement contains a magic number: r -= 16;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	temp = block [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  	}  	else {  		/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  			ac_counts [0xF0]++;  			r -= 16;  		}  		/* Find the number of bits needed for the magnitude of the coefficient */if (temp < 0)  			temp = -temp;  		/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  		/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  			nbits++;  		/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  		/* Count Huffman symbol for run length / number of bits */ac_counts [(r << 4) + nbits]++;  		r = 0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	temp = block [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  	}  	else {  		/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  			ac_counts [0xF0]++;  			r -= 16;  		}  		/* Find the number of bits needed for the magnitude of the coefficient */if (temp < 0)  			temp = -temp;  		/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  		/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  			nbits++;  		/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  		/* Count Huffman symbol for run length / number of bits */ac_counts [(r << 4) + nbits]++;  		r = 0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: for (int k = 1; k < JpegConstants.DCTSIZE2; k++) {  	temp = block [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  	}  	else {  		/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  			ac_counts [0xF0]++;  			r -= 16;  		}  		/* Find the number of bits needed for the magnitude of the coefficient */if (temp < 0)  			temp = -temp;  		/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  		/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  			nbits++;  		/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  		/* Count Huffman symbol for run length / number of bits */ac_counts [(r << 4) + nbits]++;  		r = 0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: if (temp == 0) {  	r++;  }  else {  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		ac_counts [0xF0]++;  		r -= 16;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */if (temp < 0)  		temp = -temp;  	/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Count Huffman symbol for run length / number of bits */ac_counts [(r << 4) + nbits]++;  	r = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: if (temp == 0) {  	r++;  }  else {  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		ac_counts [0xF0]++;  		r -= 16;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */if (temp < 0)  		temp = -temp;  	/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Count Huffman symbol for run length / number of bits */ac_counts [(r << 4) + nbits]++;  	r = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: if (temp == 0) {  	r++;  }  else {  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		ac_counts [0xF0]++;  		r -= 16;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */if (temp < 0)  		temp = -temp;  	/* Find the number of bits needed for the magnitude of the coefficient */nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Count Huffman symbol for run length / number of bits */ac_counts [(r << 4) + nbits]++;  	r = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: while (r > 15) {  	ac_counts [0xF0]++;  	r -= 16;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: while (r > 15) {  	ac_counts [0xF0]++;  	r -= 16;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: r -= 16;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,htest_one_block,The following statement contains a magic number: ac_counts [(r << 4) + nbits]++;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: put_buffer <<= 24 - put_bits;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (put_bits >= 8) {  	int c = (put_buffer >> 16) & 0xFF;  	if (!emit_byte (c))  		return false;  	if (c == 0xFF) {  		/* need to stuff a zero byte? */if (!emit_byte (0))  			return false;  	}  	put_buffer <<= 8;  	put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (put_bits >= 8) {  	int c = (put_buffer >> 16) & 0xFF;  	if (!emit_byte (c))  		return false;  	if (c == 0xFF) {  		/* need to stuff a zero byte? */if (!emit_byte (0))  			return false;  	}  	put_buffer <<= 8;  	put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (put_bits >= 8) {  	int c = (put_buffer >> 16) & 0xFF;  	if (!emit_byte (c))  		return false;  	if (c == 0xFF) {  		/* need to stuff a zero byte? */if (!emit_byte (0))  			return false;  	}  	put_buffer <<= 8;  	put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (put_bits >= 8) {  	int c = (put_buffer >> 16) & 0xFF;  	if (!emit_byte (c))  		return false;  	if (c == 0xFF) {  		/* need to stuff a zero byte? */if (!emit_byte (0))  			return false;  	}  	put_buffer <<= 8;  	put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: put_buffer <<= 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: put_bits -= 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,huff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\huff_entropy_encoder.cs,flush_bits,The following statement contains a magic number: if (!emit_bits (state' 0x7F' 7))  	/* fill any partial byte with ones */return false;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: switch (cinfo.m_in_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_input_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_input_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_input_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  default:  	/* JCS_UNKNOWN can be anything */if (cinfo.m_input_components < 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: switch (cinfo.m_in_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_input_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_input_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_input_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  default:  	/* JCS_UNKNOWN can be anything */if (cinfo.m_input_components < 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: if (cinfo.m_input_components != 3)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: if (cinfo.m_input_components != 4)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: switch (cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_num_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_GRAYSCALE)  		m_useGrayscaleConvert = true;  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbGrayConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useGrayscaleConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_RGB:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbYccConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useCmykYcckConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCCK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  default:  	/* allow null conversion of JCS_UNKNOWN */if (cinfo.m_jpeg_color_space != cinfo.m_in_color_space || cinfo.m_num_components != cinfo.m_input_components)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	m_useNullConvert = true;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: switch (cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_num_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_GRAYSCALE)  		m_useGrayscaleConvert = true;  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbGrayConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useGrayscaleConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_RGB:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbYccConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useCmykYcckConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCCK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  default:  	/* allow null conversion of JCS_UNKNOWN */if (cinfo.m_jpeg_color_space != cinfo.m_in_color_space || cinfo.m_num_components != cinfo.m_input_components)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	m_useNullConvert = true;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: switch (cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_num_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_GRAYSCALE)  		m_useGrayscaleConvert = true;  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbGrayConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useGrayscaleConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_RGB:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbYccConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useCmykYcckConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCCK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  default:  	/* allow null conversion of JCS_UNKNOWN */if (cinfo.m_jpeg_color_space != cinfo.m_in_color_space || cinfo.m_num_components != cinfo.m_input_components)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	m_useNullConvert = true;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: switch (cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  	if (cinfo.m_num_components != 1)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_GRAYSCALE)  		m_useGrayscaleConvert = true;  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbGrayConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useGrayscaleConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_RGB:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCbCr:  	if (cinfo.m_num_components != 3)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_RGB) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useRgbYccConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCbCr)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_CMYK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  case J_COLOR_SPACE.JCS_YCCK:  	if (cinfo.m_num_components != 4)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  	if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_CMYK) {  		m_useNullStart = false;  		// use rgb_ycc_start  		m_useCmykYcckConvert = true;  	}  	else if (cinfo.m_in_color_space == J_COLOR_SPACE.JCS_YCCK)  		m_useNullConvert = true;  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	break;  default:  	/* allow null conversion of JCS_UNKNOWN */if (cinfo.m_jpeg_color_space != cinfo.m_in_color_space || cinfo.m_num_components != cinfo.m_input_components)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL);  	m_useNullConvert = true;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: if (cinfo.m_num_components != 3)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: if (cinfo.m_num_components != 3)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: if (cinfo.m_num_components != 4)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,jpeg_color_converter,The following statement contains a magic number: if (cinfo.m_num_components != 4)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: for (int i = 0; i <= JpegConstants.MAXJSAMPLE; i++) {  	m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  	m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  	m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  	m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  	m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  	/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.                  * This ensures that the maximum output will round to MAXJSAMPLE                  * not MAXJSAMPLE+1' and thus that we don't have to range-limit.                  */m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  	/*  B=>Cb and R=>Cr tables are the same                     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;                 */m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  	m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + R_Y_OFF] = FIX (0.29900) * i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + G_Y_OFF] = FIX (0.58700) * i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + B_Y_OFF] = FIX (0.11400) * i + ONE_HALF;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + R_CB_OFF] = (-FIX (0.16874)) * i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + G_CB_OFF] = (-FIX (0.33126)) * i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + B_CB_OFF] = FIX (0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + G_CR_OFF] = (-FIX (0.41869)) * i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_start,The following statement contains a magic number: m_rgb_ycc_tab [i + B_CR_OFF] = (-FIX (0.08131)) * i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,FIX,The following statement contains a magic number: return (int)(x * (1L << SCALEBITS) + 0.5);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int r = input_buf [input_row + row] [columnOffset + JpegConstants.RGB_RED];  		int g = input_buf [input_row + row] [columnOffset + JpegConstants.RGB_GREEN];  		int b = input_buf [input_row + row] [columnOffset + JpegConstants.RGB_BLUE];  		columnOffset += JpegConstants.RGB_PIXELSIZE;  		/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  		/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  		/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  	}  	output_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int r = input_buf [input_row + row] [columnOffset + JpegConstants.RGB_RED];  	int g = input_buf [input_row + row] [columnOffset + JpegConstants.RGB_GREEN];  	int b = input_buf [input_row + row] [columnOffset + JpegConstants.RGB_BLUE];  	columnOffset += JpegConstants.RGB_PIXELSIZE;  	/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  	/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  	/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,rgb_ycc_convert,The following statement contains a magic number: output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  		int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  		int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  		/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  		columnOffset += 4;  		/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  		/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  		/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  	}  	output_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  		int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  		int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  		/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  		columnOffset += 4;  		/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  		/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  		/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  	}  	output_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  		int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  		int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  		/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  		columnOffset += 4;  		/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  		/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  		/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  	}  	output_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  		int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  		int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  		/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  		columnOffset += 4;  		/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  		/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  		/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  	}  	output_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int columnOffset = 0;  	for (int col = 0; col < num_cols; col++) {  		int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  		int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  		int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  		/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  		columnOffset += 4;  		/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  		/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  		/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  	}  	output_row++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  	int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  	int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  	/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  	columnOffset += 4;  	/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  	/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  	/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  	int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  	int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  	/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  	columnOffset += 4;  	/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  	/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  	/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  	int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  	int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  	/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  	columnOffset += 4;  	/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  	/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  	/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  	int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  	int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  	/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  	columnOffset += 4;  	/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  	/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  	/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: for (int col = 0; col < num_cols; col++) {  	int r = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset];  	int g = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 1];  	int b = JpegConstants.MAXJSAMPLE - input_buf [input_row + row] [columnOffset + 2];  	/* K passes through as-is *//* don't need GETJSAMPLE here */output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  	columnOffset += 4;  	/* If the inputs are 0..MAXJSAMPLE' the outputs of these equations                      * must be too; we do not need an explicit range-limiting operation.                      * Hence the value being shifted is never negative' and we don't                      * need the general RIGHT_SHIFT macro.                      *//* Y */output_buf [0] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_Y_OFF] + m_rgb_ycc_tab [g + G_Y_OFF] + m_rgb_ycc_tab [b + B_Y_OFF]) >> SCALEBITS);  	/* Cb */output_buf [1] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CB_OFF] + m_rgb_ycc_tab [g + G_CB_OFF] + m_rgb_ycc_tab [b + B_CB_OFF]) >> SCALEBITS);  	/* Cr */output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: output_buf [3] [output_row] [col] = input_buf [input_row + row] [columnOffset + 3];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: columnOffset += 4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_color_converter,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_color_converter.cs,cmyk_ycck_convert,The following statement contains a magic number: output_buf [2] [output_row] [col] = (byte)((m_rgb_ycc_tab [r + R_CR_OFF] + m_rgb_ycc_tab [g + G_CR_OFF] + m_rgb_ycc_tab [b + B_CR_OFF]) >> SCALEBITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,jpeg_comp_master,The following statement contains a magic number: if (cinfo.m_optimize_coding)  	m_total_passes = cinfo.m_num_scans * 2;  else  	m_total_passes = cinfo.m_num_scans;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,jpeg_comp_master,The following statement contains a magic number: m_total_passes = cinfo.m_num_scans * 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The following statement contains a magic number: if (m_cinfo.m_restart_in_rows > 0) {  	int nominal = m_cinfo.m_restart_in_rows * m_cinfo.m_MCUs_per_row;  	m_cinfo.m_restart_interval = Math.Min (nominal' 65535);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,per_scan_setup,The following statement contains a magic number: m_cinfo.m_restart_interval = Math.Min (nominal' 65535);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,start_pass,The following statement contains a magic number: m_next_buf_stop = 2 * m_cinfo.m_max_v_samp_factor;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor;  	byte[][] fake_buffer = new byte[5 * rgroup_height][];  	for (int i = 1; i < 4 * rgroup_height; i++)  		fake_buffer [i] = new byte[samplesPerRow];  	/* Allocate the actual buffer space (3 row groups) for this component.                  * We make the buffer wide enough to allow the downsampler to edge-expand                  * horizontally within the buffer' if it so chooses.                  */byte[][] true_buffer = jpeg_common_struct.AllocJpegSamples (samplesPerRow' 3 * rgroup_height);  	/* Copy true buffer row pointers into the middle of the fake row array */for (int i = 0; i < 3 * rgroup_height; i++)  		fake_buffer [rgroup_height + i] = true_buffer [i];  	/* Fill in the above and below wraparound pointers */for (int i = 0; i < rgroup_height; i++) {  		fake_buffer [i] = true_buffer [2 * rgroup_height + i];  		fake_buffer [4 * rgroup_height + i] = true_buffer [i];  	}  	m_color_buf [ci] = fake_buffer;  	m_colorBufRowsOffset = rgroup_height;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor;  	byte[][] fake_buffer = new byte[5 * rgroup_height][];  	for (int i = 1; i < 4 * rgroup_height; i++)  		fake_buffer [i] = new byte[samplesPerRow];  	/* Allocate the actual buffer space (3 row groups) for this component.                  * We make the buffer wide enough to allow the downsampler to edge-expand                  * horizontally within the buffer' if it so chooses.                  */byte[][] true_buffer = jpeg_common_struct.AllocJpegSamples (samplesPerRow' 3 * rgroup_height);  	/* Copy true buffer row pointers into the middle of the fake row array */for (int i = 0; i < 3 * rgroup_height; i++)  		fake_buffer [rgroup_height + i] = true_buffer [i];  	/* Fill in the above and below wraparound pointers */for (int i = 0; i < rgroup_height; i++) {  		fake_buffer [i] = true_buffer [2 * rgroup_height + i];  		fake_buffer [4 * rgroup_height + i] = true_buffer [i];  	}  	m_color_buf [ci] = fake_buffer;  	m_colorBufRowsOffset = rgroup_height;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor;  	byte[][] fake_buffer = new byte[5 * rgroup_height][];  	for (int i = 1; i < 4 * rgroup_height; i++)  		fake_buffer [i] = new byte[samplesPerRow];  	/* Allocate the actual buffer space (3 row groups) for this component.                  * We make the buffer wide enough to allow the downsampler to edge-expand                  * horizontally within the buffer' if it so chooses.                  */byte[][] true_buffer = jpeg_common_struct.AllocJpegSamples (samplesPerRow' 3 * rgroup_height);  	/* Copy true buffer row pointers into the middle of the fake row array */for (int i = 0; i < 3 * rgroup_height; i++)  		fake_buffer [rgroup_height + i] = true_buffer [i];  	/* Fill in the above and below wraparound pointers */for (int i = 0; i < rgroup_height; i++) {  		fake_buffer [i] = true_buffer [2 * rgroup_height + i];  		fake_buffer [4 * rgroup_height + i] = true_buffer [i];  	}  	m_color_buf [ci] = fake_buffer;  	m_colorBufRowsOffset = rgroup_height;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor;  	byte[][] fake_buffer = new byte[5 * rgroup_height][];  	for (int i = 1; i < 4 * rgroup_height; i++)  		fake_buffer [i] = new byte[samplesPerRow];  	/* Allocate the actual buffer space (3 row groups) for this component.                  * We make the buffer wide enough to allow the downsampler to edge-expand                  * horizontally within the buffer' if it so chooses.                  */byte[][] true_buffer = jpeg_common_struct.AllocJpegSamples (samplesPerRow' 3 * rgroup_height);  	/* Copy true buffer row pointers into the middle of the fake row array */for (int i = 0; i < 3 * rgroup_height; i++)  		fake_buffer [rgroup_height + i] = true_buffer [i];  	/* Fill in the above and below wraparound pointers */for (int i = 0; i < rgroup_height; i++) {  		fake_buffer [i] = true_buffer [2 * rgroup_height + i];  		fake_buffer [4 * rgroup_height + i] = true_buffer [i];  	}  	m_color_buf [ci] = fake_buffer;  	m_colorBufRowsOffset = rgroup_height;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor;  	byte[][] fake_buffer = new byte[5 * rgroup_height][];  	for (int i = 1; i < 4 * rgroup_height; i++)  		fake_buffer [i] = new byte[samplesPerRow];  	/* Allocate the actual buffer space (3 row groups) for this component.                  * We make the buffer wide enough to allow the downsampler to edge-expand                  * horizontally within the buffer' if it so chooses.                  */byte[][] true_buffer = jpeg_common_struct.AllocJpegSamples (samplesPerRow' 3 * rgroup_height);  	/* Copy true buffer row pointers into the middle of the fake row array */for (int i = 0; i < 3 * rgroup_height; i++)  		fake_buffer [rgroup_height + i] = true_buffer [i];  	/* Fill in the above and below wraparound pointers */for (int i = 0; i < rgroup_height; i++) {  		fake_buffer [i] = true_buffer [2 * rgroup_height + i];  		fake_buffer [4 * rgroup_height + i] = true_buffer [i];  	}  	m_color_buf [ci] = fake_buffer;  	m_colorBufRowsOffset = rgroup_height;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int samplesPerRow = (m_cinfo.Component_info [ci].Width_in_blocks * JpegConstants.DCTSIZE * m_cinfo.m_max_h_samp_factor) / m_cinfo.Component_info [ci].H_samp_factor;  	byte[][] fake_buffer = new byte[5 * rgroup_height][];  	for (int i = 1; i < 4 * rgroup_height; i++)  		fake_buffer [i] = new byte[samplesPerRow];  	/* Allocate the actual buffer space (3 row groups) for this component.                  * We make the buffer wide enough to allow the downsampler to edge-expand                  * horizontally within the buffer' if it so chooses.                  */byte[][] true_buffer = jpeg_common_struct.AllocJpegSamples (samplesPerRow' 3 * rgroup_height);  	/* Copy true buffer row pointers into the middle of the fake row array */for (int i = 0; i < 3 * rgroup_height; i++)  		fake_buffer [rgroup_height + i] = true_buffer [i];  	/* Fill in the above and below wraparound pointers */for (int i = 0; i < rgroup_height; i++) {  		fake_buffer [i] = true_buffer [2 * rgroup_height + i];  		fake_buffer [4 * rgroup_height + i] = true_buffer [i];  	}  	m_color_buf [ci] = fake_buffer;  	m_colorBufRowsOffset = rgroup_height;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int i = 1; i < 4 * rgroup_height; i++)  	fake_buffer [i] = new byte[samplesPerRow];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int i = 0; i < 3 * rgroup_height; i++)  	fake_buffer [rgroup_height + i] = true_buffer [i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int i = 0; i < rgroup_height; i++) {  	fake_buffer [i] = true_buffer [2 * rgroup_height + i];  	fake_buffer [4 * rgroup_height + i] = true_buffer [i];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: for (int i = 0; i < rgroup_height; i++) {  	fake_buffer [i] = true_buffer [2 * rgroup_height + i];  	fake_buffer [4 * rgroup_height + i] = true_buffer [i];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: fake_buffer [i] = true_buffer [2 * rgroup_height + i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,create_context_buffer,The following statement contains a magic number: fake_buffer [4 * rgroup_height + i] = true_buffer [i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_context,The following statement contains a magic number: while (out_row_group_ctr < out_row_groups_avail) {  	if (in_row_ctr < in_rows_avail) {  		/* Do color conversion to fill the conversion buffer. */int inrows = in_rows_avail - in_row_ctr;  		int numrows = m_next_buf_stop - m_next_buf_row;  		numrows = Math.Min (numrows' inrows);  		m_cinfo.m_cconvert.color_convert (input_buf' in_row_ctr' m_color_buf' m_colorBufRowsOffset + m_next_buf_row' numrows);  		/* Pad at top of image' if first time through */if (m_rows_to_go == m_cinfo.m_image_height) {  			for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  				for (int row = 1; row <= m_cinfo.m_max_v_samp_factor; row++)  					JpegUtils.jcopy_sample_rows (m_color_buf [ci]' m_colorBufRowsOffset' m_color_buf [ci]' m_colorBufRowsOffset - row' 1' m_cinfo.m_image_width);  			}  		}  		in_row_ctr += numrows;  		m_next_buf_row += numrows;  		m_rows_to_go -= numrows;  	}  	else {  		/* Return for more data' unless we are at the bottom of the image. */if (m_rows_to_go != 0)  			break;  		/* When at bottom of image' pad to fill the conversion buffer. */if (m_next_buf_row < m_next_buf_stop) {  			for (int ci = 0; ci < m_cinfo.m_num_components; ci++)  				expand_bottom_edge (m_color_buf [ci]' m_colorBufRowsOffset' m_cinfo.m_image_width' m_next_buf_row' m_next_buf_stop);  			m_next_buf_row = m_next_buf_stop;  		}  	}  	/* If we've gotten enough data' downsample a row group. */if (m_next_buf_row == m_next_buf_stop) {  		m_cinfo.m_downsample.downsample (m_color_buf' m_colorBufRowsOffset + m_this_row_group' output_buf' out_row_group_ctr);  		out_row_group_ctr++;  		/* Advance pointers with wraparound as necessary. */m_this_row_group += m_cinfo.m_max_v_samp_factor;  		int buf_height = m_cinfo.m_max_v_samp_factor * 3;  		if (m_this_row_group >= buf_height)  			m_this_row_group = 0;  		if (m_next_buf_row >= buf_height)  			m_next_buf_row = 0;  		m_next_buf_stop = m_next_buf_row + m_cinfo.m_max_v_samp_factor;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_c_prep_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_c_prep_controller.cs,pre_process_context,The following statement contains a magic number: if (m_next_buf_row == m_next_buf_stop) {  	m_cinfo.m_downsample.downsample (m_color_buf' m_colorBufRowsOffset + m_this_row_group' output_buf' out_row_group_ctr);  	out_row_group_ctr++;  	/* Advance pointers with wraparound as necessary. */m_this_row_group += m_cinfo.m_max_v_samp_factor;  	int buf_height = m_cinfo.m_max_v_samp_factor * 3;  	if (m_this_row_group >= buf_height)  		m_this_row_group = 0;  	if (m_next_buf_row >= buf_height)  		m_next_buf_row = 0;  	m_next_buf_stop = m_next_buf_row + m_cinfo.m_max_v_samp_factor;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_for_output_pass,The following statement contains a magic number: if (m_cinfo.m_progress != null) {  	m_cinfo.m_progress.Completed_passes = m_pass_number;  	m_cinfo.m_progress.Total_passes = m_pass_number + (m_is_dummy_pass ? 2 : 1);  	/* In buffered-image mode' we assume one more output pass if EOI not                  * yet reached' but no more passes if EOI has been reached.                  */if (m_cinfo.m_buffered_image && !m_cinfo.m_inputctl.EOIReached ())  		m_cinfo.m_progress.Total_passes += (m_cinfo.m_enable_2pass_quant ? 2 : 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_for_output_pass,The following statement contains a magic number: if (m_cinfo.m_progress != null) {  	m_cinfo.m_progress.Completed_passes = m_pass_number;  	m_cinfo.m_progress.Total_passes = m_pass_number + (m_is_dummy_pass ? 2 : 1);  	/* In buffered-image mode' we assume one more output pass if EOI not                  * yet reached' but no more passes if EOI has been reached.                  */if (m_cinfo.m_buffered_image && !m_cinfo.m_inputctl.EOIReached ())  		m_cinfo.m_progress.Total_passes += (m_cinfo.m_enable_2pass_quant ? 2 : 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_for_output_pass,The following statement contains a magic number: m_cinfo.m_progress.Total_passes = m_pass_number + (m_is_dummy_pass ? 2 : 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_for_output_pass,The following statement contains a magic number: if (m_cinfo.m_buffered_image && !m_cinfo.m_inputctl.EOIReached ())  	m_cinfo.m_progress.Total_passes += (m_cinfo.m_enable_2pass_quant ? 2 : 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_for_output_pass,The following statement contains a magic number: m_cinfo.m_progress.Total_passes += (m_cinfo.m_enable_2pass_quant ? 2 : 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_quantize_colors) {  	if (m_cinfo.m_raw_data_out)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOTIMPL);  	/* 2-pass quantizer only works in 3-component color space. */if (m_cinfo.m_out_color_components != 3) {  		m_cinfo.m_enable_1pass_quant = true;  		m_cinfo.m_enable_external_quant = false;  		m_cinfo.m_enable_2pass_quant = false;  		m_cinfo.m_colormap = null;  	}  	else if (m_cinfo.m_colormap != null)  		m_cinfo.m_enable_external_quant = true;  	else if (m_cinfo.m_two_pass_quantize)  		m_cinfo.m_enable_2pass_quant = true;  	else  		m_cinfo.m_enable_1pass_quant = true;  	if (m_cinfo.m_enable_1pass_quant) {  		m_cinfo.m_cquantize = new my_1pass_cquantizer (m_cinfo);  		m_quantizer_1pass = m_cinfo.m_cquantize;  	}  	/* We use the 2-pass code to map to external colormaps. */if (m_cinfo.m_enable_2pass_quant || m_cinfo.m_enable_external_quant) {  		m_cinfo.m_cquantize = new my_2pass_cquantizer (m_cinfo);  		m_quantizer_2pass = m_cinfo.m_cquantize;  	}  	/* If both quantizers are initialized' the 2-pass one is left active;                  * this is necessary for starting with quantization to an external map.                  */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_out_color_components != 3) {  	m_cinfo.m_enable_1pass_quant = true;  	m_cinfo.m_enable_external_quant = false;  	m_cinfo.m_enable_2pass_quant = false;  	m_cinfo.m_colormap = null;  }  else if (m_cinfo.m_colormap != null)  	m_cinfo.m_enable_external_quant = true;  else if (m_cinfo.m_two_pass_quantize)  	m_cinfo.m_enable_2pass_quant = true;  else  	m_cinfo.m_enable_1pass_quant = true;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_progress != null && !m_cinfo.m_buffered_image && m_cinfo.m_inputctl.HasMultipleScans ()) {  	/* Estimate number of scans to set pass_limit. */int nscans;  	if (m_cinfo.m_progressive_mode) {  		/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_cinfo.m_num_components;  	}  	else {  		/* For a non progressive multiscan file' estimate 1 scan per component. */nscans = m_cinfo.m_num_components;  	}  	m_cinfo.m_progress.Pass_counter = 0;  	m_cinfo.m_progress.Pass_limit = m_cinfo.m_total_iMCU_rows * nscans;  	m_cinfo.m_progress.Completed_passes = 0;  	m_cinfo.m_progress.Total_passes = (m_cinfo.m_enable_2pass_quant ? 3 : 2);  	/* Count the input pass as done */m_pass_number++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_progress != null && !m_cinfo.m_buffered_image && m_cinfo.m_inputctl.HasMultipleScans ()) {  	/* Estimate number of scans to set pass_limit. */int nscans;  	if (m_cinfo.m_progressive_mode) {  		/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_cinfo.m_num_components;  	}  	else {  		/* For a non progressive multiscan file' estimate 1 scan per component. */nscans = m_cinfo.m_num_components;  	}  	m_cinfo.m_progress.Pass_counter = 0;  	m_cinfo.m_progress.Pass_limit = m_cinfo.m_total_iMCU_rows * nscans;  	m_cinfo.m_progress.Completed_passes = 0;  	m_cinfo.m_progress.Total_passes = (m_cinfo.m_enable_2pass_quant ? 3 : 2);  	/* Count the input pass as done */m_pass_number++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_progress != null && !m_cinfo.m_buffered_image && m_cinfo.m_inputctl.HasMultipleScans ()) {  	/* Estimate number of scans to set pass_limit. */int nscans;  	if (m_cinfo.m_progressive_mode) {  		/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_cinfo.m_num_components;  	}  	else {  		/* For a non progressive multiscan file' estimate 1 scan per component. */nscans = m_cinfo.m_num_components;  	}  	m_cinfo.m_progress.Pass_counter = 0;  	m_cinfo.m_progress.Pass_limit = m_cinfo.m_total_iMCU_rows * nscans;  	m_cinfo.m_progress.Completed_passes = 0;  	m_cinfo.m_progress.Total_passes = (m_cinfo.m_enable_2pass_quant ? 3 : 2);  	/* Count the input pass as done */m_pass_number++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_progress != null && !m_cinfo.m_buffered_image && m_cinfo.m_inputctl.HasMultipleScans ()) {  	/* Estimate number of scans to set pass_limit. */int nscans;  	if (m_cinfo.m_progressive_mode) {  		/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_cinfo.m_num_components;  	}  	else {  		/* For a non progressive multiscan file' estimate 1 scan per component. */nscans = m_cinfo.m_num_components;  	}  	m_cinfo.m_progress.Pass_counter = 0;  	m_cinfo.m_progress.Pass_limit = m_cinfo.m_total_iMCU_rows * nscans;  	m_cinfo.m_progress.Completed_passes = 0;  	m_cinfo.m_progress.Total_passes = (m_cinfo.m_enable_2pass_quant ? 3 : 2);  	/* Count the input pass as done */m_pass_number++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_progressive_mode) {  	/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_cinfo.m_num_components;  }  else {  	/* For a non progressive multiscan file' estimate 1 scan per component. */nscans = m_cinfo.m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: if (m_cinfo.m_progressive_mode) {  	/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */nscans = 2 + 3 * m_cinfo.m_num_components;  }  else {  	/* For a non progressive multiscan file' estimate 1 scan per component. */nscans = m_cinfo.m_num_components;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: nscans = 2 + 3 * m_cinfo.m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: nscans = 2 + 3 * m_cinfo.m_num_components;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: m_cinfo.m_progress.Total_passes = (m_cinfo.m_enable_2pass_quant ? 3 : 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,master_selection,The following statement contains a magic number: m_cinfo.m_progress.Total_passes = (m_cinfo.m_enable_2pass_quant ? 3 : 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The following statement contains a magic number: for (int i = JpegConstants.CENTERJSAMPLE; i < 2 * (JpegConstants.MAXJSAMPLE + 1); i++)  	table [tableOffset + i] = JpegConstants.MAXJSAMPLE;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The following statement contains a magic number: Array.Clear (table' tableOffset + 2 * (JpegConstants.MAXJSAMPLE + 1)' 2 * (JpegConstants.MAXJSAMPLE + 1) - JpegConstants.CENTERJSAMPLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The following statement contains a magic number: Array.Clear (table' tableOffset + 2 * (JpegConstants.MAXJSAMPLE + 1)' 2 * (JpegConstants.MAXJSAMPLE + 1) - JpegConstants.CENTERJSAMPLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_decomp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_decomp_master.cs,prepare_range_limit_table,The following statement contains a magic number: Buffer.BlockCopy (m_cinfo.m_sample_range_limit' 0' table' tableOffset + 4 * (JpegConstants.MAXJSAMPLE + 1) - JpegConstants.CENTERJSAMPLE' JpegConstants.CENTERJSAMPLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Component_info [ci];  	if (componentInfo.H_samp_factor == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  		if (cinfo.m_smoothing_factor != 0) {  			m_downSamplers [ci] = downSampleMethod.fullsize_smooth_downsampler;  			m_need_context_rows = true;  		}  		else {  			m_downSamplers [ci] = downSampleMethod.fullsize_downsampler;  		}  	}  	else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  		smoothok = false;  		m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  	}  	else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  		if (cinfo.m_smoothing_factor != 0) {  			m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  			m_need_context_rows = true;  		}  		else {  			m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  		}  	}  	else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  		smoothok = false;  		m_downSamplers [ci] = downSampleMethod.int_downsampler;  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Component_info [ci];  	if (componentInfo.H_samp_factor == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  		if (cinfo.m_smoothing_factor != 0) {  			m_downSamplers [ci] = downSampleMethod.fullsize_smooth_downsampler;  			m_need_context_rows = true;  		}  		else {  			m_downSamplers [ci] = downSampleMethod.fullsize_downsampler;  		}  	}  	else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  		smoothok = false;  		m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  	}  	else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  		if (cinfo.m_smoothing_factor != 0) {  			m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  			m_need_context_rows = true;  		}  		else {  			m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  		}  	}  	else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  		smoothok = false;  		m_downSamplers [ci] = downSampleMethod.int_downsampler;  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Component_info [ci];  	if (componentInfo.H_samp_factor == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  		if (cinfo.m_smoothing_factor != 0) {  			m_downSamplers [ci] = downSampleMethod.fullsize_smooth_downsampler;  			m_need_context_rows = true;  		}  		else {  			m_downSamplers [ci] = downSampleMethod.fullsize_downsampler;  		}  	}  	else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  		smoothok = false;  		m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  	}  	else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  		if (cinfo.m_smoothing_factor != 0) {  			m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  			m_need_context_rows = true;  		}  		else {  			m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  		}  	}  	else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  		smoothok = false;  		m_downSamplers [ci] = downSampleMethod.int_downsampler;  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.fullsize_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.fullsize_downsampler;  	}  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.fullsize_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.fullsize_downsampler;  	}  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.fullsize_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.fullsize_downsampler;  	}  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor == cinfo.m_max_v_samp_factor) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.h2v1_downsampler;  }  else if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,jpeg_downsampler,The following statement contains a magic number: if (componentInfo.H_samp_factor * 2 == cinfo.m_max_h_samp_factor && componentInfo.V_samp_factor * 2 == cinfo.m_max_v_samp_factor) {  	if (cinfo.m_smoothing_factor != 0) {  		m_downSamplers [ci] = downSampleMethod.h2v2_smooth_downsampler;  		m_need_context_rows = true;  	}  	else {  		m_downSamplers [ci] = downSampleMethod.h2v2_downsampler;  	}  }  else if ((cinfo.m_max_h_samp_factor % componentInfo.H_samp_factor) == 0 && (cinfo.m_max_v_samp_factor % componentInfo.V_samp_factor) == 0) {  	smoothok = false;  	m_downSamplers [ci] = downSampleMethod.int_downsampler;  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v1_downsample,The following statement contains a magic number: expand_right_edge (input_data' startInputRow' m_cinfo.m_max_v_samp_factor' m_cinfo.m_image_width' output_cols * 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v1_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	/* bias = 0'1'0'1'... for successive samples */int bias = 0;  	int inputColumn = 0;  	for (int outcol = 0; outcol < output_cols; outcol++) {  		output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + outrow] [inputColumn] + (int)input_data [startInputRow + outrow] [inputColumn + 1] + bias) >> 1);  		bias ^= 1;  		/* 0=>1' 1=>0 */inputColumn += 2;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v1_downsample,The following statement contains a magic number: for (int outcol = 0; outcol < output_cols; outcol++) {  	output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + outrow] [inputColumn] + (int)input_data [startInputRow + outrow] [inputColumn + 1] + bias) >> 1);  	bias ^= 1;  	/* 0=>1' 1=>0 */inputColumn += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v1_downsample,The following statement contains a magic number: inputColumn += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: expand_right_edge (input_data' startInputRow' m_cinfo.m_max_v_samp_factor' m_cinfo.m_image_width' output_cols * 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	/* bias = 1'2'1'2'... for successive samples */int bias = 1;  	int inputColumn = 0;  	for (int outcol = 0; outcol < output_cols; outcol++) {  		output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  		bias ^= 3;  		/* 1=>2' 2=>1 */inputColumn += 2;  	}  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	/* bias = 1'2'1'2'... for successive samples */int bias = 1;  	int inputColumn = 0;  	for (int outcol = 0; outcol < output_cols; outcol++) {  		output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  		bias ^= 3;  		/* 1=>2' 2=>1 */inputColumn += 2;  	}  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	/* bias = 1'2'1'2'... for successive samples */int bias = 1;  	int inputColumn = 0;  	for (int outcol = 0; outcol < output_cols; outcol++) {  		output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  		bias ^= 3;  		/* 1=>2' 2=>1 */inputColumn += 2;  	}  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	/* bias = 1'2'1'2'... for successive samples */int bias = 1;  	int inputColumn = 0;  	for (int outcol = 0; outcol < output_cols; outcol++) {  		output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  		bias ^= 3;  		/* 1=>2' 2=>1 */inputColumn += 2;  	}  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outcol = 0; outcol < output_cols; outcol++) {  	output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  	bias ^= 3;  	/* 1=>2' 2=>1 */inputColumn += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outcol = 0; outcol < output_cols; outcol++) {  	output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  	bias ^= 3;  	/* 1=>2' 2=>1 */inputColumn += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: for (int outcol = 0; outcol < output_cols; outcol++) {  	output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  	bias ^= 3;  	/* 1=>2' 2=>1 */inputColumn += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outcol] = (byte)(((int)input_data [startInputRow + inrow] [inputColumn] + (int)input_data [startInputRow + inrow] [inputColumn + 1] + (int)input_data [startInputRow + inrow + 1] [inputColumn] + (int)input_data [startInputRow + inrow + 1] [inputColumn + 1] + bias) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: bias ^= 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: inputColumn += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_downsample,The following statement contains a magic number: inrow += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: expand_right_edge (input_data' startInputRow - 1' m_cinfo.m_max_v_samp_factor + 2' m_cinfo.m_image_width' output_cols * 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: expand_right_edge (input_data' startInputRow - 1' m_cinfo.m_max_v_samp_factor + 2' m_cinfo.m_image_width' output_cols * 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int inrow = 0' outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex0 = 0;  	int inIndex1 = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column: pretend column -1 is same as column 0 */int membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	int neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  		/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  		/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  		/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  		/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  		/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		inIndex0 += 2;  		inIndex1 += 2;  		aboveIndex += 2;  		belowIndex += 2;  	}  	/* Special case for last column */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	neighsum += neighsum;  	neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	inrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: inIndex0 += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: inIndex1 += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: aboveIndex += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: belowIndex += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	/* sum of pixels directly mapped to this output element */membersum = input_data [startInputRow + inrow] [inIndex0] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  	/* sum of edge-neighbor pixels */neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  	/* The edge-neighbors count twice as much as corner-neighbors */neighsum += neighsum;  	/* Add in the corner-neighbors */neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  	/* form final output scaled up by 2^16 */membersum = membersum * memberscale + neighsum * neighscale;  	/* round' descale and output it */output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	inIndex0 += 2;  	inIndex1 += 2;  	aboveIndex += 2;  	belowIndex += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 2] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 2] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: inIndex0 += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: inIndex1 += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: aboveIndex += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: belowIndex += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum = input_data [startInputRow + inrow - 1] [aboveIndex] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex] + input_data [startInputRow + inrow + 2] [belowIndex + 1] + input_data [startInputRow + inrow] [inIndex0 - 1] + input_data [startInputRow + inrow] [inIndex0 + 1] + input_data [startInputRow + inrow + 1] [inIndex1 - 1] + input_data [startInputRow + inrow + 1] [inIndex1 + 1];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: neighsum += input_data [startInputRow + inrow - 1] [aboveIndex - 1] + input_data [startInputRow + inrow - 1] [aboveIndex + 1] + input_data [startInputRow + inrow + 2] [belowIndex - 1] + input_data [startInputRow + inrow + 2] [belowIndex + 1];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,h2v2_smooth_downsample,The following statement contains a magic number: inrow += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: expand_right_edge (input_data' startInputRow - 1' m_cinfo.m_max_v_samp_factor + 2' m_cinfo.m_image_width' output_cols);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int outrow = 0; outrow < m_cinfo.Component_info [componentIndex].V_samp_factor; outrow++) {  	int outIndex = 0;  	int inIndex = 0;  	int aboveIndex = 0;  	int belowIndex = 0;  	/* Special case for first column */int colsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	aboveIndex++;  	belowIndex++;  	int membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	int nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	int neighsum = colsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	int lastcolsum = colsum;  	colsum = nextcolsum;  	for (int colctr = output_cols - 2; colctr > 0; colctr--) {  		membersum = input_data [startInputRow + outrow] [inIndex];  		inIndex++;  		aboveIndex++;  		belowIndex++;  		nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  		neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  		membersum = membersum * memberscale + neighsum * neighscale;  		output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  		outIndex++;  		lastcolsum = colsum;  		colsum = nextcolsum;  	}  	/* Special case for last column */membersum = input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + colsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	aboveIndex++;  	belowIndex++;  	nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	lastcolsum = colsum;  	colsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	aboveIndex++;  	belowIndex++;  	nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	lastcolsum = colsum;  	colsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: for (int colctr = output_cols - 2; colctr > 0; colctr--) {  	membersum = input_data [startInputRow + outrow] [inIndex];  	inIndex++;  	aboveIndex++;  	belowIndex++;  	nextcolsum = input_data [startInputRow + outrow - 1] [aboveIndex] + input_data [startInputRow + outrow + 1] [belowIndex] + input_data [startInputRow + outrow] [inIndex];  	neighsum = lastcolsum + (colsum - membersum) + nextcolsum;  	membersum = membersum * memberscale + neighsum * neighscale;  	output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  	outIndex++;  	lastcolsum = colsum;  	colsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,fullsize_smooth_downsample,The following statement contains a magic number: output_data [startOutRow + outrow] [outIndex] = (byte)((membersum + 32768) >> 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,jpeg_d_coef_controller,The following statement contains a magic number: if (need_full_buffer) {  	/* Allocate a full-image virtual array for each component' *//* padded to a multiple of samp_factor DCT blocks in each direction. *//* Note we ask for a pre-zeroed array. */for (int ci = 0; ci < cinfo.m_num_components; ci++) {  		m_whole_image [ci] = jpeg_common_struct.CreateBlocksArray (JpegUtils.jround_up (cinfo.Comp_info [ci].Width_in_blocks' cinfo.Comp_info [ci].H_samp_factor)' JpegUtils.jround_up (cinfo.Comp_info [ci].height_in_blocks' cinfo.Comp_info [ci].V_samp_factor));  		m_whole_image [ci].ErrorProcessor = cinfo;  	}  	m_useDummyConsumeData = false;  	m_decompressor = DecompressorType.Ordinary;  	m_coef_arrays = m_whole_image;  	/* link to virtual arrays */}  else {  	/* We only need a single-MCU buffer. */JBLOCK[] buffer = new JBLOCK[JpegConstants.D_MAX_BLOCKS_IN_MCU];  	for (int i = 0; i < JpegConstants.D_MAX_BLOCKS_IN_MCU; i++) {  		buffer [i] = new JBLOCK ();  		for (int ii = 0; ii < buffer [i].data.Length; ii++)  			buffer [i].data [ii] = -12851;  		m_MCU_buffer [i] = buffer [i];  	}  	m_useDummyConsumeData = true;  	m_decompressor = DecompressorType.OnePass;  	m_coef_arrays = null;  	/* flag for no virtual arrays */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,jpeg_d_coef_controller,The following statement contains a magic number: for (int i = 0; i < JpegConstants.D_MAX_BLOCKS_IN_MCU; i++) {  	buffer [i] = new JBLOCK ();  	for (int ii = 0; ii < buffer [i].data.Length; ii++)  		buffer [i].data [ii] = -12851;  	m_MCU_buffer [i] = buffer [i];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,jpeg_d_coef_controller,The following statement contains a magic number: for (int ii = 0; ii < buffer [i].data.Length; ii++)  	buffer [i].data [ii] = -12851;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,jpeg_d_coef_controller,The following statement contains a magic number: buffer [i].data [ii] = -12851;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	/* Don't bother to IDCT an uninteresting component. */if (!componentInfo.component_needed)  		continue;  	int block_rows;  	int access_rows;  	bool last_row;  	/* Count non-dummy DCT block rows in this iMCU row. */if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  		block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows * 2;  		/* this and next iMCU row */last_row = false;  	}  	else {  		/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  		if (block_rows == 0)  			block_rows = componentInfo.V_samp_factor;  		access_rows = block_rows;  		/* this iMCU row only */last_row = true;  	}  	/* Align the virtual buffer for this component. */JBLOCK[][] buffer = null;  	bool first_row;  	int bufferRowOffset = 0;  	if (m_cinfo.m_output_iMCU_row > 0) {  		access_rows += componentInfo.V_samp_factor;  		/* prior iMCU row too */buffer = m_whole_image [ci].Access ((m_cinfo.m_output_iMCU_row - 1) * componentInfo.V_samp_factor' access_rows);  		bufferRowOffset = componentInfo.V_samp_factor;  		/* point to current iMCU row */first_row = false;  	}  	else {  		buffer = m_whole_image [ci].Access (0' access_rows);  		first_row = true;  	}  	/* Fetch component-dependent info */int coefBitsOffset = ci * SAVED_COEFS;  	int Q00 = componentInfo.quant_table.quantval [0];  	int Q01 = componentInfo.quant_table.quantval [Q01_POS];  	int Q10 = componentInfo.quant_table.quantval [Q10_POS];  	int Q20 = componentInfo.quant_table.quantval [Q20_POS];  	int Q11 = componentInfo.quant_table.quantval [Q11_POS];  	int Q02 = componentInfo.quant_table.quantval [Q02_POS];  	int outputIndex = ci;  	/* Loop over all DCT blocks to be processed. */for (int block_row = 0; block_row < block_rows; block_row++) {  		int bufferIndex = bufferRowOffset + block_row;  		int prev_block_row = 0;  		if (first_row && block_row == 0)  			prev_block_row = bufferIndex;  		else  			prev_block_row = bufferIndex - 1;  		int next_block_row = 0;  		if (last_row && block_row == block_rows - 1)  			next_block_row = bufferIndex;  		else  			next_block_row = bufferIndex + 1;  		/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  		int DC2 = DC1;  		int DC3 = DC1;  		int DC4 = buffer [bufferIndex] [0] [0];  		int DC5 = DC4;  		int DC6 = DC4;  		int DC7 = buffer [next_block_row] [0] [0];  		int DC8 = DC7;  		int DC9 = DC7;  		int output_col = 0;  		int last_block_column = componentInfo.Width_in_blocks - 1;  		for (int block_num = 0; block_num <= last_block_column; block_num++) {  			/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  			Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  			/* Update DC values */if (block_num < last_block_column) {  				DC3 = buffer [prev_block_row] [1] [0];  				DC6 = buffer [bufferIndex] [1] [0];  				DC9 = buffer [next_block_row] [1] [0];  			}  			/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  			if (Al != 0 && workspace [1] == 0) {  				int pred;  				int num = 36 * Q00 * (DC4 - DC6);  				if (num >= 0) {  					pred = ((Q01 << 7) + num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q01 << 7) - num) / (Q01 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [1] = (short)pred;  			}  			/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  			if (Al != 0 && workspace [8] == 0) {  				int pred;  				int num = 36 * Q00 * (DC2 - DC8);  				if (num >= 0) {  					pred = ((Q10 << 7) + num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q10 << 7) - num) / (Q10 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [8] = (short)pred;  			}  			/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  			if (Al != 0 && workspace [16] == 0) {  				int pred;  				int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q20 << 7) + num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q20 << 7) - num) / (Q20 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [16] = (short)pred;  			}  			/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  			if (Al != 0 && workspace [9] == 0) {  				int pred;  				int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  				if (num >= 0) {  					pred = ((Q11 << 7) + num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q11 << 7) - num) / (Q11 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [9] = (short)pred;  			}  			/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  			if (Al != 0 && workspace [2] == 0) {  				int pred;  				int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  				if (num >= 0) {  					pred = ((Q02 << 7) + num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  				}  				else {  					pred = ((Q02 << 7) - num) / (Q02 << 8);  					if (Al > 0 && pred >= (1 << Al))  						pred = (1 << Al) - 1;  					pred = -pred;  				}  				workspace [2] = (short)pred;  			}  			/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  			/* Advance for next column */DC1 = DC2;  			DC2 = DC3;  			DC4 = DC5;  			DC5 = DC6;  			DC7 = DC8;  			DC8 = DC9;  			bufferIndex++;  			prev_block_row++;  			next_block_row++;  			output_col += componentInfo.DCT_scaled_size;  		}  		outputIndex += componentInfo.DCT_scaled_size;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (m_cinfo.m_output_iMCU_row < last_iMCU_row) {  	block_rows = componentInfo.V_samp_factor;  	access_rows = block_rows * 2;  	/* this and next iMCU row */last_row = false;  }  else {  	/* NB: can't use last_row_height here; it is input-side-dependent! */block_rows = componentInfo.height_in_blocks % componentInfo.V_samp_factor;  	if (block_rows == 0)  		block_rows = componentInfo.V_samp_factor;  	access_rows = block_rows;  	/* this iMCU row only */last_row = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: access_rows = block_rows * 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_row = 0; block_row < block_rows; block_row++) {  	int bufferIndex = bufferRowOffset + block_row;  	int prev_block_row = 0;  	if (first_row && block_row == 0)  		prev_block_row = bufferIndex;  	else  		prev_block_row = bufferIndex - 1;  	int next_block_row = 0;  	if (last_row && block_row == block_rows - 1)  		next_block_row = bufferIndex;  	else  		next_block_row = bufferIndex + 1;  	/* We fetch the surrounding DC values using a sliding-register approach.                      * Initialize all nine here so as to do the right thing on narrow pics.                      */int DC1 = buffer [prev_block_row] [0] [0];  	int DC2 = DC1;  	int DC3 = DC1;  	int DC4 = buffer [bufferIndex] [0] [0];  	int DC5 = DC4;  	int DC6 = DC4;  	int DC7 = buffer [next_block_row] [0] [0];  	int DC8 = DC7;  	int DC9 = DC7;  	int output_col = 0;  	int last_block_column = componentInfo.Width_in_blocks - 1;  	for (int block_num = 0; block_num <= last_block_column; block_num++) {  		/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  		Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  		/* Update DC values */if (block_num < last_block_column) {  			DC3 = buffer [prev_block_row] [1] [0];  			DC6 = buffer [bufferIndex] [1] [0];  			DC9 = buffer [next_block_row] [1] [0];  		}  		/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  		if (Al != 0 && workspace [1] == 0) {  			int pred;  			int num = 36 * Q00 * (DC4 - DC6);  			if (num >= 0) {  				pred = ((Q01 << 7) + num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q01 << 7) - num) / (Q01 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [1] = (short)pred;  		}  		/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  		if (Al != 0 && workspace [8] == 0) {  			int pred;  			int num = 36 * Q00 * (DC2 - DC8);  			if (num >= 0) {  				pred = ((Q10 << 7) + num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q10 << 7) - num) / (Q10 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [8] = (short)pred;  		}  		/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  		if (Al != 0 && workspace [16] == 0) {  			int pred;  			int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q20 << 7) + num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q20 << 7) - num) / (Q20 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [16] = (short)pred;  		}  		/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  		if (Al != 0 && workspace [9] == 0) {  			int pred;  			int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  			if (num >= 0) {  				pred = ((Q11 << 7) + num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q11 << 7) - num) / (Q11 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [9] = (short)pred;  		}  		/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  		if (Al != 0 && workspace [2] == 0) {  			int pred;  			int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  			if (num >= 0) {  				pred = ((Q02 << 7) + num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  			}  			else {  				pred = ((Q02 << 7) - num) / (Q02 << 8);  				if (Al > 0 && pred >= (1 << Al))  					pred = (1 << Al) - 1;  				pred = -pred;  			}  			workspace [2] = (short)pred;  		}  		/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  		/* Advance for next column */DC1 = DC2;  		DC2 = DC3;  		DC4 = DC5;  		DC5 = DC6;  		DC7 = DC8;  		DC8 = DC9;  		bufferIndex++;  		prev_block_row++;  		next_block_row++;  		output_col += componentInfo.DCT_scaled_size;  	}  	outputIndex += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: for (int block_num = 0; block_num <= last_block_column; block_num++) {  	/* Fetch current DCT block into workspace so we can modify it. */JBLOCK workspace = new JBLOCK ();  	Buffer.BlockCopy (buffer [bufferIndex] [0].data' 0' workspace.data' 0' workspace.data.Length * sizeof(short));  	/* Update DC values */if (block_num < last_block_column) {  		DC3 = buffer [prev_block_row] [1] [0];  		DC6 = buffer [bufferIndex] [1] [0];  		DC9 = buffer [next_block_row] [1] [0];  	}  	/* Compute coefficient estimates per K.8.                          * An estimate is applied only if coefficient is still zero'                          * and is not known to be fully accurate.                          *//* AC01 */int Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 1];  	if (Al != 0 && workspace [1] == 0) {  		int pred;  		int num = 36 * Q00 * (DC4 - DC6);  		if (num >= 0) {  			pred = ((Q01 << 7) + num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q01 << 7) - num) / (Q01 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [1] = (short)pred;  	}  	/* AC10 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  	if (Al != 0 && workspace [8] == 0) {  		int pred;  		int num = 36 * Q00 * (DC2 - DC8);  		if (num >= 0) {  			pred = ((Q10 << 7) + num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q10 << 7) - num) / (Q10 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [8] = (short)pred;  	}  	/* AC20 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  	if (Al != 0 && workspace [16] == 0) {  		int pred;  		int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q20 << 7) + num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q20 << 7) - num) / (Q20 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [16] = (short)pred;  	}  	/* AC11 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  	if (Al != 0 && workspace [9] == 0) {  		int pred;  		int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  		if (num >= 0) {  			pred = ((Q11 << 7) + num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q11 << 7) - num) / (Q11 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [9] = (short)pred;  	}  	/* AC02 */Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  	if (Al != 0 && workspace [2] == 0) {  		int pred;  		int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  		if (num >= 0) {  			pred = ((Q02 << 7) + num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  		}  		else {  			pred = ((Q02 << 7) - num) / (Q02 << 8);  			if (Al > 0 && pred >= (1 << Al))  				pred = (1 << Al) - 1;  			pred = -pred;  		}  		workspace [2] = (short)pred;  	}  	/* OK' do the IDCT */m_cinfo.m_idct.inverse (componentInfo.Component_index' workspace.data' output_buf [outputIndex]' 0' output_col);  	/* Advance for next column */DC1 = DC2;  	DC2 = DC3;  	DC4 = DC5;  	DC5 = DC6;  	DC7 = DC8;  	DC8 = DC9;  	bufferIndex++;  	prev_block_row++;  	next_block_row++;  	output_col += componentInfo.DCT_scaled_size;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [1] == 0) {  	int pred;  	int num = 36 * Q00 * (DC4 - DC6);  	if (num >= 0) {  		pred = ((Q01 << 7) + num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q01 << 7) - num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [1] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [1] == 0) {  	int pred;  	int num = 36 * Q00 * (DC4 - DC6);  	if (num >= 0) {  		pred = ((Q01 << 7) + num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q01 << 7) - num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [1] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [1] == 0) {  	int pred;  	int num = 36 * Q00 * (DC4 - DC6);  	if (num >= 0) {  		pred = ((Q01 << 7) + num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q01 << 7) - num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [1] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [1] == 0) {  	int pred;  	int num = 36 * Q00 * (DC4 - DC6);  	if (num >= 0) {  		pred = ((Q01 << 7) + num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q01 << 7) - num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [1] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [1] == 0) {  	int pred;  	int num = 36 * Q00 * (DC4 - DC6);  	if (num >= 0) {  		pred = ((Q01 << 7) + num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q01 << 7) - num) / (Q01 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [1] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q01 << 7) + num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q01 << 7) - num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q01 << 7) + num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q01 << 7) - num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q01 << 7) + num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q01 << 7) - num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q01 << 7) + num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q01 << 7) - num) / (Q01 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q01 << 7) + num) / (Q01 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q01 << 7) + num) / (Q01 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q01 << 7) - num) / (Q01 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q01 << 7) - num) / (Q01 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [8] == 0) {  	int pred;  	int num = 36 * Q00 * (DC2 - DC8);  	if (num >= 0) {  		pred = ((Q10 << 7) + num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q10 << 7) - num) / (Q10 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [8] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q10 << 7) + num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q10 << 7) - num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q10 << 7) + num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q10 << 7) - num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q10 << 7) + num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q10 << 7) - num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q10 << 7) + num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q10 << 7) - num) / (Q10 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q10 << 7) + num) / (Q10 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q10 << 7) + num) / (Q10 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q10 << 7) - num) / (Q10 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q10 << 7) - num) / (Q10 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: workspace [8] = (short)pred;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 3];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [16] == 0) {  	int pred;  	int num = 9 * Q00 * (DC2 + DC8 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q20 << 7) + num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q20 << 7) - num) / (Q20 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [16] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q20 << 7) + num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q20 << 7) - num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q20 << 7) + num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q20 << 7) - num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q20 << 7) + num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q20 << 7) - num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q20 << 7) + num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q20 << 7) - num) / (Q20 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q20 << 7) + num) / (Q20 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q20 << 7) + num) / (Q20 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q20 << 7) - num) / (Q20 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q20 << 7) - num) / (Q20 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: workspace [16] = (short)pred;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 4];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [9] == 0) {  	int pred;  	int num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);  	if (num >= 0) {  		pred = ((Q11 << 7) + num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q11 << 7) - num) / (Q11 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [9] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q11 << 7) + num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q11 << 7) - num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q11 << 7) + num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q11 << 7) - num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q11 << 7) + num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q11 << 7) - num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q11 << 7) + num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q11 << 7) - num) / (Q11 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q11 << 7) + num) / (Q11 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q11 << 7) + num) / (Q11 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q11 << 7) - num) / (Q11 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q11 << 7) - num) / (Q11 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: workspace [9] = (short)pred;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: Al = m_coef_bits_latch [m_coef_bits_savedOffset + coefBitsOffset + 5];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (Al != 0 && workspace [2] == 0) {  	int pred;  	int num = 9 * Q00 * (DC4 + DC6 - 2 * DC5);  	if (num >= 0) {  		pred = ((Q02 << 7) + num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  	}  	else {  		pred = ((Q02 << 7) - num) / (Q02 << 8);  		if (Al > 0 && pred >= (1 << Al))  			pred = (1 << Al) - 1;  		pred = -pred;  	}  	workspace [2] = (short)pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q02 << 7) + num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q02 << 7) - num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q02 << 7) + num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q02 << 7) - num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q02 << 7) + num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q02 << 7) - num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: if (num >= 0) {  	pred = ((Q02 << 7) + num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  }  else {  	pred = ((Q02 << 7) - num) / (Q02 << 8);  	if (Al > 0 && pred >= (1 << Al))  		pred = (1 << Al) - 1;  	pred = -pred;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q02 << 7) + num) / (Q02 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q02 << 7) + num) / (Q02 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q02 << 7) - num) / (Q02 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: pred = ((Q02 << 7) - num) / (Q02 << 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_smooth_data,The following statement contains a magic number: workspace [2] = (short)pred;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,smoothing_ok,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* All components' quantization values must already be latched. */JQUANT_TBL qtable = m_cinfo.Comp_info [ci].quant_table;  	if (qtable == null)  		return false;  	/* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */if (qtable.quantval [0] == 0 || qtable.quantval [Q01_POS] == 0 || qtable.quantval [Q10_POS] == 0 || qtable.quantval [Q20_POS] == 0 || qtable.quantval [Q11_POS] == 0 || qtable.quantval [Q02_POS] == 0) {  		return false;  	}  	/* DC values must be at least partly known for all components. */if (m_cinfo.m_coef_bits [ci] [0] < 0)  		return false;  	/* Block smoothing is helpful if some AC coefficients remain inaccurate. */for (int coefi = 1; coefi <= 5; coefi++) {  		m_coef_bits_latch [m_coef_bits_savedOffset + coefi] = m_cinfo.m_coef_bits [ci] [coefi];  		if (m_cinfo.m_coef_bits [ci] [coefi] != 0)  			smoothing_useful = true;  	}  	m_coef_bits_savedOffset += SAVED_COEFS;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,smoothing_ok,The following statement contains a magic number: for (int coefi = 1; coefi <= 5; coefi++) {  	m_coef_bits_latch [m_coef_bits_savedOffset + coefi] = m_cinfo.m_coef_bits [ci] [coefi];  	if (m_cinfo.m_coef_bits [ci] [coefi] != 0)  		smoothing_useful = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,jpeg_d_main_controller,The following statement contains a magic number: if (cinfo.m_upsample.NeedContextRows ()) {  	if (cinfo.m_min_DCT_scaled_size < 2)  		/* unsupported' see comments above */cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOTIMPL);  	alloc_funny_pointers ();  	/* Alloc space for xbuffer[] lists */ngroups = cinfo.m_min_DCT_scaled_size + 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,jpeg_d_main_controller,The following statement contains a magic number: if (cinfo.m_upsample.NeedContextRows ()) {  	if (cinfo.m_min_DCT_scaled_size < 2)  		/* unsupported' see comments above */cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOTIMPL);  	alloc_funny_pointers ();  	/* Alloc space for xbuffer[] lists */ngroups = cinfo.m_min_DCT_scaled_size + 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,jpeg_d_main_controller,The following statement contains a magic number: if (cinfo.m_min_DCT_scaled_size < 2)  	/* unsupported' see comments above */cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,jpeg_d_main_controller,The following statement contains a magic number: ngroups = cinfo.m_min_DCT_scaled_size + 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_context_main,The following statement contains a magic number: if (m_context_state == CTX_PROCESS_IMCU) {  	/* Call postprocessor using previously set pointers */m_cinfo.m_post.post_process_data (cb' ref m_rowgroup_ctr' m_rowgroups_avail' output_buf' ref out_row_ctr' out_rows_avail);  	if (m_rowgroup_ctr < m_rowgroups_avail) {  		/* Need to suspend */return;  	}  	/* After the first iMCU' change wraparound pointers to normal state */if (m_iMCU_row_ctr == 1)  		set_wraparound_pointers ();  	/* Prepare to load new iMCU row using other xbuffer list */m_whichFunny ^= 1;  	/* 0=>1 or 1=>0 */m_buffer_full = false;  	/* Still need to process last row group of this iMCU row' *//* which is saved at index M+1 of the other xbuffer */m_rowgroup_ctr = m_cinfo.m_min_DCT_scaled_size + 1;  	m_rowgroups_avail = m_cinfo.m_min_DCT_scaled_size + 2;  	m_context_state = CTX_POSTPONED_ROW;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,process_data_context_main,The following statement contains a magic number: m_rowgroups_avail = m_cinfo.m_min_DCT_scaled_size + 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,alloc_funny_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	/* Get space for pointer lists --- M+4 row groups in each list.                  */m_funnyIndices [0] [ci] = new int[rgroup * (M + 4)];  	m_funnyIndices [1] [ci] = new int[rgroup * (M + 4)];  	m_funnyOffsets [ci] = rgroup;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,alloc_funny_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	/* Get space for pointer lists --- M+4 row groups in each list.                  */m_funnyIndices [0] [ci] = new int[rgroup * (M + 4)];  	m_funnyIndices [1] [ci] = new int[rgroup * (M + 4)];  	m_funnyOffsets [ci] = rgroup;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,alloc_funny_pointers,The following statement contains a magic number: m_funnyIndices [0] [ci] = new int[rgroup * (M + 4)];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,alloc_funny_pointers,The following statement contains a magic number: m_funnyIndices [1] [ci] = new int[rgroup * (M + 4)];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	/* First copy the workspace pointers as-is */for (int i = 0; i < rgroup * (M + 2); i++) {  		ind0 [i + rgroup] = i;  		ind1 [i + rgroup] = i;  	}  	/* In the second list' put the last four row groups in swapped order */for (int i = 0; i < rgroup * 2; i++) {  		ind1 [rgroup * (M - 1) + i] = rgroup * M + i;  		ind1 [rgroup * (M + 1) + i] = rgroup * (M - 2) + i;  	}  	/* The wraparound pointers at top and bottom will be filled later                  * (see set_wraparound_pointers' below).  Initially we want the "above"                  * pointers to duplicate the first actual data line.  This only needs                  * to happen in xbuffer[0].                  */for (int i = 0; i < rgroup; i++)  		ind0 [i] = ind0 [rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	/* First copy the workspace pointers as-is */for (int i = 0; i < rgroup * (M + 2); i++) {  		ind0 [i + rgroup] = i;  		ind1 [i + rgroup] = i;  	}  	/* In the second list' put the last four row groups in swapped order */for (int i = 0; i < rgroup * 2; i++) {  		ind1 [rgroup * (M - 1) + i] = rgroup * M + i;  		ind1 [rgroup * (M + 1) + i] = rgroup * (M - 2) + i;  	}  	/* The wraparound pointers at top and bottom will be filled later                  * (see set_wraparound_pointers' below).  Initially we want the "above"                  * pointers to duplicate the first actual data line.  This only needs                  * to happen in xbuffer[0].                  */for (int i = 0; i < rgroup; i++)  		ind0 [i] = ind0 [rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	/* First copy the workspace pointers as-is */for (int i = 0; i < rgroup * (M + 2); i++) {  		ind0 [i + rgroup] = i;  		ind1 [i + rgroup] = i;  	}  	/* In the second list' put the last four row groups in swapped order */for (int i = 0; i < rgroup * 2; i++) {  		ind1 [rgroup * (M - 1) + i] = rgroup * M + i;  		ind1 [rgroup * (M + 1) + i] = rgroup * (M - 2) + i;  	}  	/* The wraparound pointers at top and bottom will be filled later                  * (see set_wraparound_pointers' below).  Initially we want the "above"                  * pointers to duplicate the first actual data line.  This only needs                  * to happen in xbuffer[0].                  */for (int i = 0; i < rgroup; i++)  		ind0 [i] = ind0 [rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup * (M + 2); i++) {  	ind0 [i + rgroup] = i;  	ind1 [i + rgroup] = i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup * 2; i++) {  	ind1 [rgroup * (M - 1) + i] = rgroup * M + i;  	ind1 [rgroup * (M + 1) + i] = rgroup * (M - 2) + i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup * 2; i++) {  	ind1 [rgroup * (M - 1) + i] = rgroup * M + i;  	ind1 [rgroup * (M + 1) + i] = rgroup * (M - 2) + i;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,make_funny_pointers,The following statement contains a magic number: ind1 [rgroup * (M + 1) + i] = rgroup * (M - 2) + i;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	for (int i = 0; i < rgroup; i++) {  		ind0 [i] = ind0 [rgroup * (M + 2) + i];  		ind1 [i] = ind1 [rgroup * (M + 2) + i];  		ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  		ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	for (int i = 0; i < rgroup; i++) {  		ind0 [i] = ind0 [rgroup * (M + 2) + i];  		ind1 [i] = ind1 [rgroup * (M + 2) + i];  		ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  		ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	for (int i = 0; i < rgroup; i++) {  		ind0 [i] = ind0 [rgroup * (M + 2) + i];  		ind1 [i] = ind1 [rgroup * (M + 2) + i];  		ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  		ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* height of a row group of component */int rgroup = (m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size) / m_cinfo.m_min_DCT_scaled_size;  	int[] ind0 = m_funnyIndices [0] [ci];  	int[] ind1 = m_funnyIndices [1] [ci];  	for (int i = 0; i < rgroup; i++) {  		ind0 [i] = ind0 [rgroup * (M + 2) + i];  		ind1 [i] = ind1 [rgroup * (M + 2) + i];  		ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  		ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup; i++) {  	ind0 [i] = ind0 [rgroup * (M + 2) + i];  	ind1 [i] = ind1 [rgroup * (M + 2) + i];  	ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  	ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup; i++) {  	ind0 [i] = ind0 [rgroup * (M + 2) + i];  	ind1 [i] = ind1 [rgroup * (M + 2) + i];  	ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  	ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup; i++) {  	ind0 [i] = ind0 [rgroup * (M + 2) + i];  	ind1 [i] = ind1 [rgroup * (M + 2) + i];  	ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  	ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup; i++) {  	ind0 [i] = ind0 [rgroup * (M + 2) + i];  	ind1 [i] = ind1 [rgroup * (M + 2) + i];  	ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  	ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: ind0 [i] = ind0 [rgroup * (M + 2) + i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: ind1 [i] = ind1 [rgroup * (M + 2) + i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: ind0 [rgroup * (M + 3) + i] = ind0 [i + rgroup];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_wraparound_pointers,The following statement contains a magic number: ind1 [rgroup * (M + 3) + i] = ind1 [i + rgroup];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_bottom_pointers,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	/* Count sample rows in one iMCU row and in one row group */int iMCUheight = m_cinfo.Comp_info [ci].V_samp_factor * m_cinfo.Comp_info [ci].DCT_scaled_size;  	int rgroup = iMCUheight / m_cinfo.m_min_DCT_scaled_size;  	/* Count nondummy sample rows remaining for this component */int rows_left = m_cinfo.Comp_info [ci].downsampled_height % iMCUheight;  	if (rows_left == 0)  		rows_left = iMCUheight;  	/* Count nondummy row groups.  Should get same answer for each component'                  * so we need only do it once.                  */if (ci == 0)  		m_rowgroups_avail = (rows_left - 1) / rgroup + 1;  	/* Duplicate the last real sample row rgroup*2 times; this pads out the                  * last partial rowgroup and ensures at least one full rowgroup of context.                  */for (int i = 0; i < rgroup * 2; i++)  		m_funnyIndices [m_whichFunny] [ci] [rows_left + i + rgroup] = m_funnyIndices [m_whichFunny] [ci] [rows_left - 1 + rgroup];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_main_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_main_controller.cs,set_bottom_pointers,The following statement contains a magic number: for (int i = 0; i < rgroup * 2; i++)  	m_funnyIndices [m_whichFunny] [ci] [rows_left + i + rgroup] = m_funnyIndices [m_whichFunny] [ci] [rows_left - 1 + rgroup];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: for (int l = 1; l <= 16; l++) {  	int i = htbl.Bits [l];  	if (i < 0 || p + i > 256)  		/* protect against table overrun */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	while ((i--) != 0)  		huffsize [p++] = (char)l;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: for (int l = 1; l <= 16; l++) {  	int i = htbl.Bits [l];  	if (i < 0 || p + i > 256)  		/* protect against table overrun */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	while ((i--) != 0)  		huffsize [p++] = (char)l;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: if (i < 0 || p + i > 256)  	/* protect against table overrun */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: for (int l = 1; l <= 16; l++) {  	if (htbl.Bits [l] != 0) {  		/* valoffset[l] = huffval[] index of 1st symbol of code length l'                     * minus the minimum code of length l                     */dtbl.valoffset [l] = p - huffcode [p];  		p += htbl.Bits [l];  		dtbl.maxcode [l] = huffcode [p - 1];  		/* maximum code of length l */}  	else {  		/* -1 if no codes of this length */dtbl.maxcode [l] = -1;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: dtbl.maxcode [17] = 0xFFFFF;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: if (isDC) {  	for (int i = 0; i < numsymbols; i++) {  		int sym = htbl.Huffval [i];  		if (sym < 0 || sym > 15)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: for (int i = 0; i < numsymbols; i++) {  	int sym = htbl.Huffval [i];  	if (sym < 0 || sym > 15)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_make_d_derived_tbl,The following statement contains a magic number: if (sym < 0 || sym > 15)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The following statement contains a magic number: if (state.cinfo.m_unread_marker == 0) {  	/* cannot advance past a marker */while (bits_left < MIN_GET_BITS) {  		int c;  		state.cinfo.m_src.GetByte (out c);  		/* If it's 0xFF' check and discard stuffed zero byte */if (c == 0xFF) {  			/* Loop here to discard any padding FF's on terminating marker'                         * so that we can save a valid unread_marker value.  NOTE: we will                         * accept multiple FF's followed by a 0 as meaning a single FF data                         * byte.  This data pattern is not valid according to the standard.                         */do {  				state.cinfo.m_src.GetByte (out c);  			}  			while (c == 0xFF);  			if (c == 0) {  				/* Found FF/00' which represents an FF data byte */c = 0xFF;  			}  			else {  				/* Oops' it's actually a marker indicating end of compressed data.                             * Save the marker code for later use.                             * Fine point: it might appear that we should save the marker into                             * bitread working state' not straight into permanent state.  But                             * once we have hit a marker' we cannot need to suspend within the                             * current MCU' because we will read no more bytes from the data                             * source.  So it is OK to update permanent state right away.                             */state.cinfo.m_unread_marker = c;  				/* See if we need to insert some fake zero bits. */noMoreBytes = true;  				break;  			}  		}  		/* OK' load c into get_buffer */get_buffer = (get_buffer << 8) | c;  		bits_left += 8;  	}  	/* end while */}  else  	noMoreBytes = true;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The following statement contains a magic number: if (state.cinfo.m_unread_marker == 0) {  	/* cannot advance past a marker */while (bits_left < MIN_GET_BITS) {  		int c;  		state.cinfo.m_src.GetByte (out c);  		/* If it's 0xFF' check and discard stuffed zero byte */if (c == 0xFF) {  			/* Loop here to discard any padding FF's on terminating marker'                         * so that we can save a valid unread_marker value.  NOTE: we will                         * accept multiple FF's followed by a 0 as meaning a single FF data                         * byte.  This data pattern is not valid according to the standard.                         */do {  				state.cinfo.m_src.GetByte (out c);  			}  			while (c == 0xFF);  			if (c == 0) {  				/* Found FF/00' which represents an FF data byte */c = 0xFF;  			}  			else {  				/* Oops' it's actually a marker indicating end of compressed data.                             * Save the marker code for later use.                             * Fine point: it might appear that we should save the marker into                             * bitread working state' not straight into permanent state.  But                             * once we have hit a marker' we cannot need to suspend within the                             * current MCU' because we will read no more bytes from the data                             * source.  So it is OK to update permanent state right away.                             */state.cinfo.m_unread_marker = c;  				/* See if we need to insert some fake zero bits. */noMoreBytes = true;  				break;  			}  		}  		/* OK' load c into get_buffer */get_buffer = (get_buffer << 8) | c;  		bits_left += 8;  	}  	/* end while */}  else  	noMoreBytes = true;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The following statement contains a magic number: while (bits_left < MIN_GET_BITS) {  	int c;  	state.cinfo.m_src.GetByte (out c);  	/* If it's 0xFF' check and discard stuffed zero byte */if (c == 0xFF) {  		/* Loop here to discard any padding FF's on terminating marker'                         * so that we can save a valid unread_marker value.  NOTE: we will                         * accept multiple FF's followed by a 0 as meaning a single FF data                         * byte.  This data pattern is not valid according to the standard.                         */do {  			state.cinfo.m_src.GetByte (out c);  		}  		while (c == 0xFF);  		if (c == 0) {  			/* Found FF/00' which represents an FF data byte */c = 0xFF;  		}  		else {  			/* Oops' it's actually a marker indicating end of compressed data.                             * Save the marker code for later use.                             * Fine point: it might appear that we should save the marker into                             * bitread working state' not straight into permanent state.  But                             * once we have hit a marker' we cannot need to suspend within the                             * current MCU' because we will read no more bytes from the data                             * source.  So it is OK to update permanent state right away.                             */state.cinfo.m_unread_marker = c;  			/* See if we need to insert some fake zero bits. */noMoreBytes = true;  			break;  		}  	}  	/* OK' load c into get_buffer */get_buffer = (get_buffer << 8) | c;  	bits_left += 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The following statement contains a magic number: while (bits_left < MIN_GET_BITS) {  	int c;  	state.cinfo.m_src.GetByte (out c);  	/* If it's 0xFF' check and discard stuffed zero byte */if (c == 0xFF) {  		/* Loop here to discard any padding FF's on terminating marker'                         * so that we can save a valid unread_marker value.  NOTE: we will                         * accept multiple FF's followed by a 0 as meaning a single FF data                         * byte.  This data pattern is not valid according to the standard.                         */do {  			state.cinfo.m_src.GetByte (out c);  		}  		while (c == 0xFF);  		if (c == 0) {  			/* Found FF/00' which represents an FF data byte */c = 0xFF;  		}  		else {  			/* Oops' it's actually a marker indicating end of compressed data.                             * Save the marker code for later use.                             * Fine point: it might appear that we should save the marker into                             * bitread working state' not straight into permanent state.  But                             * once we have hit a marker' we cannot need to suspend within the                             * current MCU' because we will read no more bytes from the data                             * source.  So it is OK to update permanent state right away.                             */state.cinfo.m_unread_marker = c;  			/* See if we need to insert some fake zero bits. */noMoreBytes = true;  			break;  		}  	}  	/* OK' load c into get_buffer */get_buffer = (get_buffer << 8) | c;  	bits_left += 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The following statement contains a magic number: get_buffer = (get_buffer << 8) | c;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_fill_bit_buffer,The following statement contains a magic number: bits_left += 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_decoder.cs,jpeg_huff_decode,The following statement contains a magic number: if (l > 16) {  	state.cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  	/* fake a zero as the safest result */return 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_make_c_derived_tbl,The following statement contains a magic number: for (int l = 1; l <= 16; l++) {  	int i = htbl.Bits [l];  	if (i < 0 || p + i > 256)  		/* protect against table overrun */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	while ((i--) != 0)  		huffsize [p++] = (char)l;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_make_c_derived_tbl,The following statement contains a magic number: for (int l = 1; l <= 16; l++) {  	int i = htbl.Bits [l];  	if (i < 0 || p + i > 256)  		/* protect against table overrun */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	while ((i--) != 0)  		huffsize [p++] = (char)l;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_make_c_derived_tbl,The following statement contains a magic number: if (i < 0 || p + i > 256)  	/* protect against table overrun */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = 0; i < 257; i++)  	others [i] = -1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: freq [256] = 1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (; ;) {  	/* Find the smallest nonzero frequency' set c1 = its symbol *//* In case of ties' take the larger symbol number */c1 = -1;  	v = 1000000000L;  	for (i = 0; i <= 256; i++) {  		if (freq [i] != 0 && freq [i] <= v) {  			v = freq [i];  			c1 = i;  		}  	}  	/* Find the next smallest nonzero frequency' set c2 = its symbol *//* In case of ties' take the larger symbol number */c2 = -1;  	v = 1000000000L;  	for (i = 0; i <= 256; i++) {  		if (freq [i] != 0 && freq [i] <= v && i != c1) {  			v = freq [i];  			c2 = i;  		}  	}  	/* Done if we've merged everything into one frequency */if (c2 < 0)  		break;  	/* Else merge the two counts/trees */freq [c1] += freq [c2];  	freq [c2] = 0;  	/* Increment the codesize of everything in c1's tree branch */codesize [c1]++;  	while (others [c1] >= 0) {  		c1 = others [c1];  		codesize [c1]++;  	}  	others [c1] = c2;  	/* chain c2 onto c1's tree branch *//* Increment the codesize of everything in c2's tree branch */codesize [c2]++;  	while (others [c2] >= 0) {  		c2 = others [c2];  		codesize [c2]++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (; ;) {  	/* Find the smallest nonzero frequency' set c1 = its symbol *//* In case of ties' take the larger symbol number */c1 = -1;  	v = 1000000000L;  	for (i = 0; i <= 256; i++) {  		if (freq [i] != 0 && freq [i] <= v) {  			v = freq [i];  			c1 = i;  		}  	}  	/* Find the next smallest nonzero frequency' set c2 = its symbol *//* In case of ties' take the larger symbol number */c2 = -1;  	v = 1000000000L;  	for (i = 0; i <= 256; i++) {  		if (freq [i] != 0 && freq [i] <= v && i != c1) {  			v = freq [i];  			c2 = i;  		}  	}  	/* Done if we've merged everything into one frequency */if (c2 < 0)  		break;  	/* Else merge the two counts/trees */freq [c1] += freq [c2];  	freq [c2] = 0;  	/* Increment the codesize of everything in c1's tree branch */codesize [c1]++;  	while (others [c1] >= 0) {  		c1 = others [c1];  		codesize [c1]++;  	}  	others [c1] = c2;  	/* chain c2 onto c1's tree branch *//* Increment the codesize of everything in c2's tree branch */codesize [c2]++;  	while (others [c2] >= 0) {  		c2 = others [c2];  		codesize [c2]++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = 0; i <= 256; i++) {  	if (freq [i] != 0 && freq [i] <= v) {  		v = freq [i];  		c1 = i;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = 0; i <= 256; i++) {  	if (freq [i] != 0 && freq [i] <= v && i != c1) {  		v = freq [i];  		c2 = i;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = 0; i <= 256; i++) {  	if (codesize [i] != 0) {  		/* The JPEG standard seems to think that this can't happen' *//* but I'm paranoid... */if (codesize [i] > MAX_CLEN)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_HUFF_CLEN_OVERFLOW);  		bits [codesize [i]]++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = MAX_CLEN; i > 16; i--) {  	while (bits [i] > 0) {  		j = i - 2;  		/* find length of new prefix to be used */while (bits [j] == 0)  			j--;  		bits [i] -= 2;  		/* remove two symbols */bits [i - 1]++;  		/* one goes in this length */bits [j + 1] += 2;  		/* two new symbols in this length */bits [j]--;  		/* symbol of this length is now a prefix */}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = MAX_CLEN; i > 16; i--) {  	while (bits [i] > 0) {  		j = i - 2;  		/* find length of new prefix to be used */while (bits [j] == 0)  			j--;  		bits [i] -= 2;  		/* remove two symbols */bits [i - 1]++;  		/* one goes in this length */bits [j + 1] += 2;  		/* two new symbols in this length */bits [j]--;  		/* symbol of this length is now a prefix */}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = MAX_CLEN; i > 16; i--) {  	while (bits [i] > 0) {  		j = i - 2;  		/* find length of new prefix to be used */while (bits [j] == 0)  			j--;  		bits [i] -= 2;  		/* remove two symbols */bits [i - 1]++;  		/* one goes in this length */bits [j + 1] += 2;  		/* two new symbols in this length */bits [j]--;  		/* symbol of this length is now a prefix */}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = MAX_CLEN; i > 16; i--) {  	while (bits [i] > 0) {  		j = i - 2;  		/* find length of new prefix to be used */while (bits [j] == 0)  			j--;  		bits [i] -= 2;  		/* remove two symbols */bits [i - 1]++;  		/* one goes in this length */bits [j + 1] += 2;  		/* two new symbols in this length */bits [j]--;  		/* symbol of this length is now a prefix */}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: while (bits [i] > 0) {  	j = i - 2;  	/* find length of new prefix to be used */while (bits [j] == 0)  		j--;  	bits [i] -= 2;  	/* remove two symbols */bits [i - 1]++;  	/* one goes in this length */bits [j + 1] += 2;  	/* two new symbols in this length */bits [j]--;  	/* symbol of this length is now a prefix */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: while (bits [i] > 0) {  	j = i - 2;  	/* find length of new prefix to be used */while (bits [j] == 0)  		j--;  	bits [i] -= 2;  	/* remove two symbols */bits [i - 1]++;  	/* one goes in this length */bits [j + 1] += 2;  	/* two new symbols in this length */bits [j]--;  	/* symbol of this length is now a prefix */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: while (bits [i] > 0) {  	j = i - 2;  	/* find length of new prefix to be used */while (bits [j] == 0)  		j--;  	bits [i] -= 2;  	/* remove two symbols */bits [i - 1]++;  	/* one goes in this length */bits [j + 1] += 2;  	/* two new symbols in this length */bits [j]--;  	/* symbol of this length is now a prefix */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: j = i - 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: bits [i] -= 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: bits [j + 1] += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (i = 1; i <= MAX_CLEN; i++) {  	for (j = 0; j <= 255; j++) {  		if (codesize [j] == i) {  			htbl.Huffval [p] = (byte)j;  			p++;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_entropy_encoder.cs,jpeg_gen_optimal_table,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	if (codesize [j] == i) {  		htbl.Huffval [p] = (byte)j;  		p++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int qtblno = m_cinfo.Component_info [ci].Quant_tbl_no;  	/* Make sure specified quantization table is present */if (qtblno < 0 || qtblno >= JpegConstants.NUM_QUANT_TBLS || m_cinfo.m_quant_tbl_ptrs [qtblno] == null)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_QUANT_TABLE' qtblno);  	JQUANT_TBL qtbl = m_cinfo.m_quant_tbl_ptrs [qtblno];  	/* Compute divisors for this quant table *//* We may do this more than once for same table' but it's not a big deal */int i = 0;  	switch (m_cinfo.m_dct_method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		/* For LL&M IDCT method' divisors are equal to raw quantization                          * coefficients multiplied by 8 (to counteract scaling).                          */if (m_divisors [qtblno] == null)  			m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  		for (i = 0; i < JpegConstants.DCTSIZE2; i++)  			m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		if (m_divisors [qtblno] == null)  			m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  		for (i = 0; i < JpegConstants.DCTSIZE2; i++)  			m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		if (m_float_divisors [qtblno] == null)  			m_float_divisors [qtblno] = new float[JpegConstants.DCTSIZE2];  		float[] fdtbl = m_float_divisors [qtblno];  		i = 0;  		for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  			for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  				fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  				i++;  			}  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int qtblno = m_cinfo.Component_info [ci].Quant_tbl_no;  	/* Make sure specified quantization table is present */if (qtblno < 0 || qtblno >= JpegConstants.NUM_QUANT_TBLS || m_cinfo.m_quant_tbl_ptrs [qtblno] == null)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_QUANT_TABLE' qtblno);  	JQUANT_TBL qtbl = m_cinfo.m_quant_tbl_ptrs [qtblno];  	/* Compute divisors for this quant table *//* We may do this more than once for same table' but it's not a big deal */int i = 0;  	switch (m_cinfo.m_dct_method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		/* For LL&M IDCT method' divisors are equal to raw quantization                          * coefficients multiplied by 8 (to counteract scaling).                          */if (m_divisors [qtblno] == null)  			m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  		for (i = 0; i < JpegConstants.DCTSIZE2; i++)  			m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		if (m_divisors [qtblno] == null)  			m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  		for (i = 0; i < JpegConstants.DCTSIZE2; i++)  			m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		if (m_float_divisors [qtblno] == null)  			m_float_divisors [qtblno] = new float[JpegConstants.DCTSIZE2];  		float[] fdtbl = m_float_divisors [qtblno];  		i = 0;  		for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  			for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  				fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  				i++;  			}  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	int qtblno = m_cinfo.Component_info [ci].Quant_tbl_no;  	/* Make sure specified quantization table is present */if (qtblno < 0 || qtblno >= JpegConstants.NUM_QUANT_TBLS || m_cinfo.m_quant_tbl_ptrs [qtblno] == null)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_QUANT_TABLE' qtblno);  	JQUANT_TBL qtbl = m_cinfo.m_quant_tbl_ptrs [qtblno];  	/* Compute divisors for this quant table *//* We may do this more than once for same table' but it's not a big deal */int i = 0;  	switch (m_cinfo.m_dct_method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		/* For LL&M IDCT method' divisors are equal to raw quantization                          * coefficients multiplied by 8 (to counteract scaling).                          */if (m_divisors [qtblno] == null)  			m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  		for (i = 0; i < JpegConstants.DCTSIZE2; i++)  			m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		if (m_divisors [qtblno] == null)  			m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  		for (i = 0; i < JpegConstants.DCTSIZE2; i++)  			m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		if (m_float_divisors [qtblno] == null)  			m_float_divisors [qtblno] = new float[JpegConstants.DCTSIZE2];  		float[] fdtbl = m_float_divisors [qtblno];  		i = 0;  		for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  			for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  				fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  				i++;  			}  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: switch (m_cinfo.m_dct_method) {  case J_DCT_METHOD.JDCT_ISLOW:  	/* For LL&M IDCT method' divisors are equal to raw quantization                          * coefficients multiplied by 8 (to counteract scaling).                          */if (m_divisors [qtblno] == null)  		m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  	for (i = 0; i < JpegConstants.DCTSIZE2; i++)  		m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  	break;  case J_DCT_METHOD.JDCT_IFAST:  	if (m_divisors [qtblno] == null)  		m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  	for (i = 0; i < JpegConstants.DCTSIZE2; i++)  		m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  	break;  case J_DCT_METHOD.JDCT_FLOAT:  	if (m_float_divisors [qtblno] == null)  		m_float_divisors [qtblno] = new float[JpegConstants.DCTSIZE2];  	float[] fdtbl = m_float_divisors [qtblno];  	i = 0;  	for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  		for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  			fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  			i++;  		}  	}  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: switch (m_cinfo.m_dct_method) {  case J_DCT_METHOD.JDCT_ISLOW:  	/* For LL&M IDCT method' divisors are equal to raw quantization                          * coefficients multiplied by 8 (to counteract scaling).                          */if (m_divisors [qtblno] == null)  		m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  	for (i = 0; i < JpegConstants.DCTSIZE2; i++)  		m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  	break;  case J_DCT_METHOD.JDCT_IFAST:  	if (m_divisors [qtblno] == null)  		m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  	for (i = 0; i < JpegConstants.DCTSIZE2; i++)  		m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  	break;  case J_DCT_METHOD.JDCT_FLOAT:  	if (m_float_divisors [qtblno] == null)  		m_float_divisors [qtblno] = new float[JpegConstants.DCTSIZE2];  	float[] fdtbl = m_float_divisors [qtblno];  	i = 0;  	for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  		for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  			fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  			i++;  		}  	}  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: switch (m_cinfo.m_dct_method) {  case J_DCT_METHOD.JDCT_ISLOW:  	/* For LL&M IDCT method' divisors are equal to raw quantization                          * coefficients multiplied by 8 (to counteract scaling).                          */if (m_divisors [qtblno] == null)  		m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  	for (i = 0; i < JpegConstants.DCTSIZE2; i++)  		m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  	break;  case J_DCT_METHOD.JDCT_IFAST:  	if (m_divisors [qtblno] == null)  		m_divisors [qtblno] = new int[JpegConstants.DCTSIZE2];  	for (i = 0; i < JpegConstants.DCTSIZE2; i++)  		m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  	break;  case J_DCT_METHOD.JDCT_FLOAT:  	if (m_float_divisors [qtblno] == null)  		m_float_divisors [qtblno] = new float[JpegConstants.DCTSIZE2];  	float[] fdtbl = m_float_divisors [qtblno];  	i = 0;  	for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  		for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  			fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  			i++;  		}  	}  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (i = 0; i < JpegConstants.DCTSIZE2; i++)  	m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: m_divisors [qtblno] [i] = ((int)qtbl.quantval [i]) << 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (i = 0; i < JpegConstants.DCTSIZE2; i++)  	m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: m_divisors [qtblno] [i] = JpegUtils.DESCALE ((int)qtbl.quantval [i] * (int)aanscales [i]' CONST_BITS - 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  	for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  		fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  		i++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  	fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  	i++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,start_pass,The following statement contains a magic number: fdtbl [i] = (float)(1.0 / (((double)qtbl.quantval [i] * aanscalefactor [row] * aanscalefactor [col] * 8.0)));  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The following statement contains a magic number: for (int bi = 0; bi < num_blocks; bi++' start_col += JpegConstants.DCTSIZE) {  	/* Load data into workspace' applying unsigned->signed conversion */int workspaceIndex = 0;  	for (int elemr = 0; elemr < JpegConstants.DCTSIZE; elemr++) {  		for (int column = 0; column < JpegConstants.DCTSIZE; column++) {  			workspace [workspaceIndex] = (float)((int)sample_data [start_row + elemr] [start_col + column] - JpegConstants.CENTERJSAMPLE);  			workspaceIndex++;  		}  	}  	/* Perform the DCT */jpeg_fdct_float (workspace);  	/* Quantize/descale the coefficients' and store into coef_blocks[] */for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* Apply the quantization and scaling factor */float temp = workspace [i] * m_float_divisors [quant_tbl_no] [i];  		/* Round to nearest integer.                      * Since C does not specify the direction of rounding for negative                      * quotients' we have to force the dividend positive for portability.                      * The maximum coefficient size is +-16K (for 12-bit data)' so this                      * code should work for either 16-bit or 32-bit ints.                      */coef_blocks [bi] [i] = (short)((int)(temp + (float)16384.5) - 16384);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The following statement contains a magic number: for (int bi = 0; bi < num_blocks; bi++' start_col += JpegConstants.DCTSIZE) {  	/* Load data into workspace' applying unsigned->signed conversion */int workspaceIndex = 0;  	for (int elemr = 0; elemr < JpegConstants.DCTSIZE; elemr++) {  		for (int column = 0; column < JpegConstants.DCTSIZE; column++) {  			workspace [workspaceIndex] = (float)((int)sample_data [start_row + elemr] [start_col + column] - JpegConstants.CENTERJSAMPLE);  			workspaceIndex++;  		}  	}  	/* Perform the DCT */jpeg_fdct_float (workspace);  	/* Quantize/descale the coefficients' and store into coef_blocks[] */for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* Apply the quantization and scaling factor */float temp = workspace [i] * m_float_divisors [quant_tbl_no] [i];  		/* Round to nearest integer.                      * Since C does not specify the direction of rounding for negative                      * quotients' we have to force the dividend positive for portability.                      * The maximum coefficient size is +-16K (for 12-bit data)' so this                      * code should work for either 16-bit or 32-bit ints.                      */coef_blocks [bi] [i] = (short)((int)(temp + (float)16384.5) - 16384);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	/* Apply the quantization and scaling factor */float temp = workspace [i] * m_float_divisors [quant_tbl_no] [i];  	/* Round to nearest integer.                      * Since C does not specify the direction of rounding for negative                      * quotients' we have to force the dividend positive for portability.                      * The maximum coefficient size is +-16K (for 12-bit data)' so this                      * code should work for either 16-bit or 32-bit ints.                      */coef_blocks [bi] [i] = (short)((int)(temp + (float)16384.5) - 16384);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	/* Apply the quantization and scaling factor */float temp = workspace [i] * m_float_divisors [quant_tbl_no] [i];  	/* Round to nearest integer.                      * Since C does not specify the direction of rounding for negative                      * quotients' we have to force the dividend positive for portability.                      * The maximum coefficient size is +-16K (for 12-bit data)' so this                      * code should work for either 16-bit or 32-bit ints.                      */coef_blocks [bi] [i] = (short)((int)(temp + (float)16384.5) - 16384);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The following statement contains a magic number: coef_blocks [bi] [i] = (short)((int)(temp + (float)16384.5) - 16384);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,forwardDCTFloatImpl,The following statement contains a magic number: coef_blocks [bi] [i] = (short)((int)(temp + (float)16384.5) - 16384);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	float tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	float tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	float tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	float tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	float tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	float tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	float tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + 4] = tmp10 - tmp11;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + 2] = tmp13 + z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + 6] = tmp13 - z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + 5] = z13 + z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + 3] = z13 - z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + 7] = z11 - z4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	float tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	float tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	float tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	float tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	float tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */float tmp10 = tmp0 + tmp3;  	/* phase 2 */float tmp13 = tmp0 - tmp3;  	float tmp11 = tmp1 + tmp2;  	float tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	float z1 = (tmp12 + tmp13) * ((float)0.707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */float z5 = (tmp10 - tmp12) * ((float)0.382683433);  	/* c6 */float z2 = ((float)0.541196100) * tmp10 + z5;  	/* c2-c6 */float z4 = ((float)1.306562965) * tmp12 + z5;  	/* c2+c6 */float z3 = tmp11 * ((float)0.707106781);  	/* c4 */float z11 = tmp7 + z3;  	/* phase 5 */float z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_float,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + 5] = z13 + z2;  	/* phase 6 */data [dataIndex + 3] = z13 - z2;  	data [dataIndex + 1] = z11 + z4;  	data [dataIndex + 7] = z11 - z4;  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + 4] = tmp10 - tmp11;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + 2] = tmp13 + z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + 6] = tmp13 - z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + 5] = z13 + z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + 3] = z13 - z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + 7] = z11 - z4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part */int tmp10 = tmp0 + tmp3;  	/* phase 2 */int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = tmp10 + tmp11;  	/* phase 3 */data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  	int z1 = FAST_INTEGER_MULTIPLY (tmp12 + tmp13' FAST_INTEGER_FIX_0_707106781);  	/* c4 */data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  	/* phase 5 */data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  	/* Odd part */tmp10 = tmp4 + tmp5;  	/* phase 2 */tmp11 = tmp5 + tmp6;  	tmp12 = tmp6 + tmp7;  	/* The rotator is modified from fig 4-8 to avoid extra negations. */int z5 = FAST_INTEGER_MULTIPLY (tmp10 - tmp12' FAST_INTEGER_FIX_0_382683433);  	/* c6 */int z2 = FAST_INTEGER_MULTIPLY (tmp10' FAST_INTEGER_FIX_0_541196100) + z5;  	/* c2-c6 */int z4 = FAST_INTEGER_MULTIPLY (tmp12' FAST_INTEGER_FIX_1_306562965) + z5;  	/* c2+c6 */int z3 = FAST_INTEGER_MULTIPLY (tmp11' FAST_INTEGER_FIX_0_707106781);  	/* c4 */int z11 = tmp7 + z3;  	/* phase 5 */int z13 = tmp7 - z3;  	data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  	/* phase 6 */data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  	data [dataIndex + JpegConstants.DCTSIZE * 1] = z11 + z4;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 4] = tmp10 - tmp11;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 2] = tmp13 + z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 6] = tmp13 - z1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 5] = z13 + z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 3] = z13 - z2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_ifast,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 7] = z11 - z4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + 0] + data [dataIndex + 7];  	int tmp7 = data [dataIndex + 0] - data [dataIndex + 7];  	int tmp1 = data [dataIndex + 1] + data [dataIndex + 6];  	int tmp6 = data [dataIndex + 1] - data [dataIndex + 6];  	int tmp2 = data [dataIndex + 2] + data [dataIndex + 5];  	int tmp5 = data [dataIndex + 2] - data [dataIndex + 5];  	int tmp3 = data [dataIndex + 3] + data [dataIndex + 4];  	int tmp4 = data [dataIndex + 3] - data [dataIndex + 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + 0] = (tmp10 + tmp11) << SLOW_INTEGER_PASS1_BITS;  	data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	dataIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + 4] = (tmp10 - tmp11) << SLOW_INTEGER_PASS1_BITS;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE - 1; ctr >= 0; ctr--) {  	int tmp0 = data [dataIndex + JpegConstants.DCTSIZE * 0] + data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp7 = data [dataIndex + JpegConstants.DCTSIZE * 0] - data [dataIndex + JpegConstants.DCTSIZE * 7];  	int tmp1 = data [dataIndex + JpegConstants.DCTSIZE * 1] + data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp6 = data [dataIndex + JpegConstants.DCTSIZE * 1] - data [dataIndex + JpegConstants.DCTSIZE * 6];  	int tmp2 = data [dataIndex + JpegConstants.DCTSIZE * 2] + data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp5 = data [dataIndex + JpegConstants.DCTSIZE * 2] - data [dataIndex + JpegConstants.DCTSIZE * 5];  	int tmp3 = data [dataIndex + JpegConstants.DCTSIZE * 3] + data [dataIndex + JpegConstants.DCTSIZE * 4];  	int tmp4 = data [dataIndex + JpegConstants.DCTSIZE * 3] - data [dataIndex + JpegConstants.DCTSIZE * 4];  	/* Even part per LL&M figure 1 --- note that published figure is faulty;                 * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".                 */int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	data [dataIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp11' SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  	int z1 = (tmp12 + tmp13) * SLOW_INTEGER_FIX_0_541196100;  	data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	/* Odd part per figure 8 --- note paper omits factor of sqrt(2).                 * cK represents cos(K*pi/16).                 * i0..i3 in the paper are tmp4..tmp7 here.                 */z1 = tmp4 + tmp7;  	int z2 = tmp5 + tmp6;  	int z3 = tmp4 + tmp6;  	int z4 = tmp5 + tmp7;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp4 = tmp4 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp5 = tmp5 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp6 = tmp6 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp7 = tmp7 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	data [dataIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp7 + z1 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  	dataIndex++;  	/* advance pointer to next column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp10 - tmp11' SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (z1 + tmp13 * SLOW_INTEGER_FIX_0_765366865' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (z1 + tmp12 * (-SLOW_INTEGER_FIX_1_847759065)' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp4 + z1 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp5 + z2 + z4' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_forward_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_forward_dct.cs,jpeg_fdct_islow,The following statement contains a magic number: data [dataIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp6 + z2 + z3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	InverseMethod im = InverseMethod.Unknown;  	int method = 0;  	/* Select the proper IDCT routine for this component's scaling */switch (componentInfo.DCT_scaled_size) {  	case 1:  		im = InverseMethod.idct_1x1_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		/* jidctred uses islow-style table */break;  	case 2:  		im = InverseMethod.idct_2x2_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		/* jidctred uses islow-style table */break;  	case 4:  		im = InverseMethod.idct_4x4_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		/* jidctred uses islow-style table */break;  	case JpegConstants.DCTSIZE:  		switch (m_cinfo.m_dct_method) {  		case J_DCT_METHOD.JDCT_ISLOW:  			im = InverseMethod.idct_islow_method;  			method = (int)J_DCT_METHOD.JDCT_ISLOW;  			break;  		case J_DCT_METHOD.JDCT_IFAST:  			im = InverseMethod.idct_ifast_method;  			method = (int)J_DCT_METHOD.JDCT_IFAST;  			break;  		case J_DCT_METHOD.JDCT_FLOAT:  			im = InverseMethod.idct_float_method;  			method = (int)J_DCT_METHOD.JDCT_FLOAT;  			break;  		default:  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  			break;  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCTSIZE' componentInfo.DCT_scaled_size);  		break;  	}  	m_inverse_DCT_method [ci] = im;  	/* Create multiplier table from quant table.                  * However' we can skip this if the component is uninteresting                  * or if we already built the table.  Also' if no quant table                  * has yet been saved for the component' we leave the                  * multiplier table all-zero; we'll be reading zeroes from the                  * coefficient controller's buffer anyway.                  */if (!componentInfo.component_needed || m_cur_method [ci] == method)  		continue;  	if (componentInfo.quant_table == null) {  		/* happens if no data yet for component */continue;  	}  	m_cur_method [ci] = method;  	switch ((J_DCT_METHOD)method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		/* For LL&M IDCT method' multipliers are equal to raw quantization                          * coefficients' but are stored as ints to ensure access efficiency.                          */int[] ismtbl = m_dctTables [ci].int_array;  		for (int i = 0; i < JpegConstants.DCTSIZE2; i++)  			ismtbl [i] = componentInfo.quant_table.quantval [i];  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		/* For AA&N IDCT method' multipliers are equal to quantization                          * coefficients scaled by scalefactor[row]*scalefactor[col]' where                          *   scalefactor[0] = 1                          *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7                          * For integer operation' the multiplier table is to be scaled by                          * IFAST_SCALE_BITS.                          */int[] ifmtbl = m_dctTables [ci].int_array;  		for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  			ifmtbl [i] = JpegUtils.DESCALE ((int)componentInfo.quant_table.quantval [i] * (int)aanscales [i]' CONST_BITS - IFAST_SCALE_BITS);  		}  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		/* For float AA&N IDCT method' multipliers are equal to quantization                          * coefficients scaled by scalefactor[row]*scalefactor[col]' where                          *   scalefactor[0] = 1                          *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7                          */float[] fmtbl = m_dctTables [ci].float_array;  		int ii = 0;  		for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  			for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  				fmtbl [ii] = (float)((double)componentInfo.quant_table.quantval [ii] * aanscalefactor [row] * aanscalefactor [col]);  				ii++;  			}  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Comp_info [ci];  	InverseMethod im = InverseMethod.Unknown;  	int method = 0;  	/* Select the proper IDCT routine for this component's scaling */switch (componentInfo.DCT_scaled_size) {  	case 1:  		im = InverseMethod.idct_1x1_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		/* jidctred uses islow-style table */break;  	case 2:  		im = InverseMethod.idct_2x2_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		/* jidctred uses islow-style table */break;  	case 4:  		im = InverseMethod.idct_4x4_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		/* jidctred uses islow-style table */break;  	case JpegConstants.DCTSIZE:  		switch (m_cinfo.m_dct_method) {  		case J_DCT_METHOD.JDCT_ISLOW:  			im = InverseMethod.idct_islow_method;  			method = (int)J_DCT_METHOD.JDCT_ISLOW;  			break;  		case J_DCT_METHOD.JDCT_IFAST:  			im = InverseMethod.idct_ifast_method;  			method = (int)J_DCT_METHOD.JDCT_IFAST;  			break;  		case J_DCT_METHOD.JDCT_FLOAT:  			im = InverseMethod.idct_float_method;  			method = (int)J_DCT_METHOD.JDCT_FLOAT;  			break;  		default:  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  			break;  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCTSIZE' componentInfo.DCT_scaled_size);  		break;  	}  	m_inverse_DCT_method [ci] = im;  	/* Create multiplier table from quant table.                  * However' we can skip this if the component is uninteresting                  * or if we already built the table.  Also' if no quant table                  * has yet been saved for the component' we leave the                  * multiplier table all-zero; we'll be reading zeroes from the                  * coefficient controller's buffer anyway.                  */if (!componentInfo.component_needed || m_cur_method [ci] == method)  		continue;  	if (componentInfo.quant_table == null) {  		/* happens if no data yet for component */continue;  	}  	m_cur_method [ci] = method;  	switch ((J_DCT_METHOD)method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		/* For LL&M IDCT method' multipliers are equal to raw quantization                          * coefficients' but are stored as ints to ensure access efficiency.                          */int[] ismtbl = m_dctTables [ci].int_array;  		for (int i = 0; i < JpegConstants.DCTSIZE2; i++)  			ismtbl [i] = componentInfo.quant_table.quantval [i];  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		/* For AA&N IDCT method' multipliers are equal to quantization                          * coefficients scaled by scalefactor[row]*scalefactor[col]' where                          *   scalefactor[0] = 1                          *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7                          * For integer operation' the multiplier table is to be scaled by                          * IFAST_SCALE_BITS.                          */int[] ifmtbl = m_dctTables [ci].int_array;  		for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  			ifmtbl [i] = JpegUtils.DESCALE ((int)componentInfo.quant_table.quantval [i] * (int)aanscales [i]' CONST_BITS - IFAST_SCALE_BITS);  		}  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		/* For float AA&N IDCT method' multipliers are equal to quantization                          * coefficients scaled by scalefactor[row]*scalefactor[col]' where                          *   scalefactor[0] = 1                          *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7                          */float[] fmtbl = m_dctTables [ci].float_array;  		int ii = 0;  		for (int row = 0; row < JpegConstants.DCTSIZE; row++) {  			for (int col = 0; col < JpegConstants.DCTSIZE; col++) {  				fmtbl [ii] = (float)((double)componentInfo.quant_table.quantval [ii] * aanscalefactor [row] * aanscalefactor [col]);  				ii++;  			}  		}  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,start_pass,The following statement contains a magic number: switch (componentInfo.DCT_scaled_size) {  case 1:  	im = InverseMethod.idct_1x1_method;  	method = (int)J_DCT_METHOD.JDCT_ISLOW;  	/* jidctred uses islow-style table */break;  case 2:  	im = InverseMethod.idct_2x2_method;  	method = (int)J_DCT_METHOD.JDCT_ISLOW;  	/* jidctred uses islow-style table */break;  case 4:  	im = InverseMethod.idct_4x4_method;  	method = (int)J_DCT_METHOD.JDCT_ISLOW;  	/* jidctred uses islow-style table */break;  case JpegConstants.DCTSIZE:  	switch (m_cinfo.m_dct_method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		im = InverseMethod.idct_islow_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		im = InverseMethod.idct_ifast_method;  		method = (int)J_DCT_METHOD.JDCT_IFAST;  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		im = InverseMethod.idct_float_method;  		method = (int)J_DCT_METHOD.JDCT_FLOAT;  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCTSIZE' componentInfo.DCT_scaled_size);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,start_pass,The following statement contains a magic number: switch (componentInfo.DCT_scaled_size) {  case 1:  	im = InverseMethod.idct_1x1_method;  	method = (int)J_DCT_METHOD.JDCT_ISLOW;  	/* jidctred uses islow-style table */break;  case 2:  	im = InverseMethod.idct_2x2_method;  	method = (int)J_DCT_METHOD.JDCT_ISLOW;  	/* jidctred uses islow-style table */break;  case 4:  	im = InverseMethod.idct_4x4_method;  	method = (int)J_DCT_METHOD.JDCT_ISLOW;  	/* jidctred uses islow-style table */break;  case JpegConstants.DCTSIZE:  	switch (m_cinfo.m_dct_method) {  	case J_DCT_METHOD.JDCT_ISLOW:  		im = InverseMethod.idct_islow_method;  		method = (int)J_DCT_METHOD.JDCT_ISLOW;  		break;  	case J_DCT_METHOD.JDCT_IFAST:  		im = InverseMethod.idct_ifast_method;  		method = (int)J_DCT_METHOD.JDCT_IFAST;  		break;  	case J_DCT_METHOD.JDCT_FLOAT:  		im = InverseMethod.idct_float_method;  		method = (int)J_DCT_METHOD.JDCT_FLOAT;  		break;  	default:  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  		break;  	}  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCTSIZE' componentInfo.DCT_scaled_size);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	z2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp0 = (z2 + z3) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (z2 - z3) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << SLOW_INTEGER_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: z3 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp0 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp1 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp2 = SLOW_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS - SLOW_INTEGER_PASS1_BITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */int currentOutRow = output_row + ctr;  	if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part: reverse the even part of the forward DCT. *//* The rotator is sqrt(2)*c(-6). */int z2 = workspace [workspaceIndex + 2];  	int z3 = workspace [workspaceIndex + 6];  	int z1 = (z2 + z3) * SLOW_INTEGER_FIX_0_541196100;  	int tmp2 = z1 + z3 * (-SLOW_INTEGER_FIX_1_847759065);  	int tmp3 = z1 + z2 * SLOW_INTEGER_FIX_0_765366865;  	int tmp0 = (workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp1 = (workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4]) << SLOW_INTEGER_CONST_BITS;  	int tmp10 = tmp0 + tmp3;  	int tmp13 = tmp0 - tmp3;  	int tmp11 = tmp1 + tmp2;  	int tmp12 = tmp1 - tmp2;  	/* Odd part per figure 8; the matrix is unitary and hence its                 * transpose is its inverse.  i0..i3 are y7'y5'y3'y1 respectively.                 */tmp0 = workspace [workspaceIndex + 7];  	tmp1 = workspace [workspaceIndex + 5];  	tmp2 = workspace [workspaceIndex + 3];  	tmp3 = workspace [workspaceIndex + 1];  	z1 = tmp0 + tmp3;  	z2 = tmp1 + tmp2;  	z3 = tmp0 + tmp2;  	int z4 = tmp1 + tmp3;  	int z5 = (z3 + z4) * SLOW_INTEGER_FIX_1_175875602;  	/* sqrt(2) * c3 */tmp0 = tmp0 * SLOW_INTEGER_FIX_0_298631336;  	/* sqrt(2) * (-c1+c3+c5-c7) */tmp1 = tmp1 * SLOW_INTEGER_FIX_2_053119869;  	/* sqrt(2) * ( c1+c3-c5+c7) */tmp2 = tmp2 * SLOW_INTEGER_FIX_3_072711026;  	/* sqrt(2) * ( c1+c3+c5-c7) */tmp3 = tmp3 * SLOW_INTEGER_FIX_1_501321110;  	/* sqrt(2) * ( c1+c3-c5-c7) */z1 = z1 * (-SLOW_INTEGER_FIX_0_899976223);  	/* sqrt(2) * (c7-c3) */z2 = z2 * (-SLOW_INTEGER_FIX_2_562915447);  	/* sqrt(2) * (-c1-c3) */z3 = z3 * (-SLOW_INTEGER_FIX_1_961570560);  	/* sqrt(2) * (-c3-c5) */z4 = z4 * (-SLOW_INTEGER_FIX_0_390180644);  	/* sqrt(2) * (c5-c3) */z3 += z5;  	z4 += z5;  	tmp0 += z1 + z3;  	tmp1 += z2 + z4;  	tmp2 += z2 + z3;  	tmp3 += z1 + z4;  	/* Final output stage: inputs are tmp10..tmp13' tmp0..tmp3 */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp0 = workspace [workspaceIndex + 7];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp1 = workspace [workspaceIndex + 5];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: tmp2 = workspace [workspaceIndex + 3];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp3' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp11 + tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE (tmp11 - tmp2' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp1' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp13 + tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_islow,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE (tmp13 - tmp0' SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		/* advance pointers to next column */coefBlockIndex++;  		quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */int tmp0 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp1 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int tmp2 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	int tmp3 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp10 = tmp0 + tmp2;  	/* phase 3 */int tmp11 = tmp0 - tmp2;  	int tmp13 = tmp1 + tmp3;  	/* phases 5-3 */int tmp12 = FAST_INTEGER_MULTIPLY (tmp1 - tmp3' FAST_INTEGER_FIX_1_414213562) - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */int tmp4 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	int tmp5 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int tmp6 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	int tmp7 = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int z13 = tmp6 + tmp5;  	/* phase 6 */int z10 = tmp6 - tmp5;  	int z11 = tmp4 + tmp7;  	int z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */int dcval = FAST_INTEGER_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	/* advance pointers to next column */coefBlockIndex++;  	quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	int currentOutRow = output_row + ctr;  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * On machines with very fast multiplication' it's possible that the                 * test takes more time than it's worth.  In that case this section                 * may be commented out.                 */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  		/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  		continue;  	}  	/* Even part */int tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	int tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	int tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	int tmp12 = FAST_INTEGER_MULTIPLY (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]' FAST_INTEGER_FIX_1_414213562) - tmp13;  	int tmp0 = tmp10 + tmp13;  	int tmp3 = tmp10 - tmp13;  	int tmp1 = tmp11 + tmp12;  	int tmp2 = tmp11 - tmp12;  	/* Odd part */int z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	int z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	int z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	int z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	int tmp7 = z11 + z13;  	/* phase 5 */tmp11 = FAST_INTEGER_MULTIPLY (z11 - z13' FAST_INTEGER_FIX_1_414213562);  	/* 2*c4 */int z5 = FAST_INTEGER_MULTIPLY (z10 + z12' FAST_INTEGER_FIX_1_847759065);  	/* 2*c2 */tmp10 = FAST_INTEGER_MULTIPLY (z12' FAST_INTEGER_FIX_1_082392200) - z5;  	/* 2*(c2-c6) */tmp12 = FAST_INTEGER_MULTIPLY (z10' -FAST_INTEGER_FIX_2_613125930) + z5;  	/* -2*(c2+c6) */int tmp6 = tmp12 - tmp7;  	/* phase 2 */int tmp5 = tmp11 - tmp6;  	int tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 4] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + FAST_INTEGER_IDESCALE (workspace [workspaceIndex + 0]' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  	/* advance pointer to next row */workspaceIndex += JpegConstants.DCTSIZE;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 + tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp0 - tmp7' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 + tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp1 - tmp6' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 + tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp2 - tmp5' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 + tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_ifast,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + FAST_INTEGER_IDESCALE (tmp3 - tmp4' FAST_INTEGER_PASS1_BITS + 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; ctr--) {  	/* Due to quantization' we will usually find that many of the input                 * coefficients are zero' especially the AC terms.  We can exploit this                 * by short-circuiting the IDCT calculation for any column in which all                 * the AC terms are zero.  In that case each output is equal to the                 * DC coefficient (with scale factor as needed).                 * With typical images and quantization tables' half or more of the                 * column DCT calculations can be simplified this way.                 */if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  		coefBlockIndex++;  		/* advance pointers to next column */quantTableIndex++;  		workspaceIndex++;  		continue;  	}  	/* Even part */float tmp0 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	float tmp1 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	float tmp2 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 4]);  	float tmp3 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	float tmp10 = tmp0 + tmp2;  	/* phase 3 */float tmp11 = tmp0 - tmp2;  	float tmp13 = tmp1 + tmp3;  	/* phases 5-3 */float tmp12 = (tmp1 - tmp3) * 1.414213562f - tmp13;  	/* 2*c4 */tmp0 = tmp10 + tmp13;  	/* phase 2 */tmp3 = tmp10 - tmp13;  	tmp1 = tmp11 + tmp12;  	tmp2 = tmp11 - tmp12;  	/* Odd part */float tmp4 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	float tmp5 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	float tmp6 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	float tmp7 = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	float z13 = tmp6 + tmp5;  	/* phase 6 */float z10 = tmp6 - tmp5;  	float z11 = tmp4 + tmp7;  	float z12 = tmp4 - tmp7;  	tmp7 = z11 + z13;  	/* phase 5 */tmp11 = (z11 - z13) * 1.414213562f;  	/* 2*c4 */float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */tmp6 = tmp12 - tmp7;  	/* phase 2 */tmp5 = tmp11 - tmp6;  	tmp4 = tmp10 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = tmp0 + tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = tmp1 + tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 4] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero */float dcval = FLOAT_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  	coefBlockIndex++;  	/* advance pointers to next column */quantTableIndex++;  	workspaceIndex++;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 7] = tmp0 - tmp7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 6] = tmp1 - tmp6;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = tmp2 + tmp5;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 5] = tmp2 - tmp5;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 4] = tmp3 + tmp4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = tmp3 - tmp4;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: for (int ctr = 0; ctr < JpegConstants.DCTSIZE; ctr++) {  	/* Rows of zeroes can be exploited in the same way as we did with columns.                 * However' the column calculation has created many nonzero AC terms' so                 * the simplification applies less often (typically 5% to 10% of the time).                 * And testing floats for zero is relatively expensive' so we don't bother.                 *//* Even part */float tmp10 = workspace [workspaceIndex + 0] + workspace [workspaceIndex + 4];  	float tmp11 = workspace [workspaceIndex + 0] - workspace [workspaceIndex + 4];  	float tmp13 = workspace [workspaceIndex + 2] + workspace [workspaceIndex + 6];  	float tmp12 = (workspace [workspaceIndex + 2] - workspace [workspaceIndex + 6]) * 1.414213562f - tmp13;  	float tmp0 = tmp10 + tmp13;  	float tmp3 = tmp10 - tmp13;  	float tmp1 = tmp11 + tmp12;  	float tmp2 = tmp11 - tmp12;  	/* Odd part */float z13 = workspace [workspaceIndex + 5] + workspace [workspaceIndex + 3];  	float z10 = workspace [workspaceIndex + 5] - workspace [workspaceIndex + 3];  	float z11 = workspace [workspaceIndex + 1] + workspace [workspaceIndex + 7];  	float z12 = workspace [workspaceIndex + 1] - workspace [workspaceIndex + 7];  	float tmp7 = z11 + z13;  	tmp11 = (z11 - z13) * 1.414213562f;  	float z5 = (z10 + z12) * 1.847759065f;  	/* 2*c2 */tmp10 = 1.082392200f * z12 - z5;  	/* 2*(c2-c6) */tmp12 = -2.613125930f * z10 + z5;  	/* -2*(c2+c6) */float tmp6 = tmp12 - tmp7;  	float tmp5 = tmp11 - tmp6;  	float tmp4 = tmp10 + tmp5;  	/* Final output stage: scale down by a factor of 8 and range-limit */int currentOutRow = output_row + ctr;  	m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 + tmp7)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 7] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp0 - tmp7)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 + tmp6)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 6] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp1 - tmp6)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 + tmp5)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 5] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp2 - tmp5)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 4] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 + tmp4)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_float,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE ((int)(tmp3 - tmp4)' 3) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process column 4' because second pass won't use it */if (ctr == JpegConstants.DCTSIZE - 4)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  		continue;  	}  	/* Even part */int tmp0 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	tmp0 <<= (REDUCED_CONST_BITS + 1);  	int z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 2]);  	int z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 6]);  	int tmp2 = z2 * REDUCED_FIX_1_847759065 + z3 * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	int z4 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (ctr == JpegConstants.DCTSIZE - 4)  	continue;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 2] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 6] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine term 4 for 4x4 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: z2 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: z3 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 3] = JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 2] = JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: for (int ctr = 0; ctr < 4; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp0 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 1);  	int tmp2 = workspace [workspaceIndex + 2] * REDUCED_FIX_1_847759065 + workspace [workspaceIndex + 6] * (-REDUCED_FIX_0_765366865);  	int tmp10 = tmp0 + tmp2;  	int tmp12 = tmp0 - tmp2;  	/* Odd part */int z1 = workspace [workspaceIndex + 7];  	int z2 = workspace [workspaceIndex + 5];  	int z3 = workspace [workspaceIndex + 3];  	int z4 = workspace [workspaceIndex + 1];  	tmp0 = z1 * (-REDUCED_FIX_0_211164243) /* sqrt(2) * (c3-c1) */+ z2 * REDUCED_FIX_1_451774981 /* sqrt(2) * (c3+c7) */+ z3 * (-REDUCED_FIX_2_172734803) /* sqrt(2) * (-c1-c5) */+ z4 * REDUCED_FIX_1_061594337;  	/* sqrt(2) * (c5+c7) */tmp2 = z1 * (-REDUCED_FIX_0_509795579) /* sqrt(2) * (c7-c5) */+ z2 * (-REDUCED_FIX_0_601344887) /* sqrt(2) * (c5-c1) */+ z3 * REDUCED_FIX_0_899976223 /* sqrt(2) * (c3-c7) */+ z4 * REDUCED_FIX_2_562915447;  	/* sqrt(2) * (c1+c3) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 2] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 6] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = dcval;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 3] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp2' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp12 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_4x4,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 2] = limit [limitOffset + JpegUtils.DESCALE (tmp12 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 1) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = JpegConstants.DCTSIZE; ctr > 0; coefBlockIndex++' quantTableIndex++' workspaceIndex++' ctr--) {  	/* Don't bother to process columns 2'4'6 */if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  		continue;  	if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  		/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  		workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  		continue;  	}  	/* Even part */int z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]);  	int tmp10 = z1 << (REDUCED_CONST_BITS + 2);  	/* Odd part */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  	int tmp0 = z1 * -REDUCED_FIX_0_720959822;  	/* sqrt(2) * (c7-c5+c3-c1) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  	tmp0 += z1 * REDUCED_FIX_0_850430095;  	/* sqrt(2) * (-c1+c3+c5+c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  	tmp0 += z1 * (-REDUCED_FIX_1_272758580);  	/* sqrt(2) * (-c1+c3-c5-c7) */z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 1]);  	tmp0 += z1 * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  	continue;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  	continue;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (ctr == JpegConstants.DCTSIZE - 2 || ctr == JpegConstants.DCTSIZE - 4 || ctr == JpegConstants.DCTSIZE - 6)  	continue;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 1] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5] == 0 && coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7] == 0) {  	/* AC terms all zero; we need not examine terms 2'4'6 for 2x2 output */int dcval = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 0]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 0]) << REDUCED_PASS1_BITS;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = dcval;  	workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = dcval;  	continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 7]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 5]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 5]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: z1 = REDUCED_DEQUANTIZE (coef_block [coefBlockIndex + JpegConstants.DCTSIZE * 3]' quantTable [quantTableIndex + JpegConstants.DCTSIZE * 3]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 0] = JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: workspace [workspaceIndex + JpegConstants.DCTSIZE * 1] = JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS - REDUCED_PASS1_BITS + 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: for (int ctr = 0; ctr < 2; ctr++) {  	int currentOutRow = output_row + ctr;  	/* It's not clear whether a zero row test is worthwhile here ... */if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  		/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  		m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  		m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  		workspaceIndex += JpegConstants.DCTSIZE;  		/* advance pointer to next row */continue;  	}  	/* Even part */int tmp10 = (workspace [workspaceIndex + 0]) << (REDUCED_CONST_BITS + 2);  	/* Odd part */int tmp0 = workspace [workspaceIndex + 7] * (-REDUCED_FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */+ workspace [workspaceIndex + 5] * REDUCED_FIX_0_850430095 /* sqrt(2) * (-c1+c3+c5+c7) */+ workspace [workspaceIndex + 3] * (-REDUCED_FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */+ workspace [workspaceIndex + 1] * REDUCED_FIX_3_624509785;  	/* sqrt(2) * (c1+c3+c5+c7) *//* Final output stage */m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: if (workspace [workspaceIndex + 1] == 0 && workspace [workspaceIndex + 3] == 0 && workspace [workspaceIndex + 5] == 0 && workspace [workspaceIndex + 7] == 0) {  	/* AC terms all zero */byte dcval = limit [limitOffset + JpegUtils.DESCALE (workspace [workspaceIndex + 0]' REDUCED_PASS1_BITS + 3) & RANGE_MASK];  	m_componentBuffer [currentOutRow] [output_col + 0] = dcval;  	m_componentBuffer [currentOutRow] [output_col + 1] = dcval;  	workspaceIndex += JpegConstants.DCTSIZE;  	/* advance pointer to next row */continue;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 0] = limit [limitOffset + JpegUtils.DESCALE (tmp10 + tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_2x2,The following statement contains a magic number: m_componentBuffer [currentOutRow] [output_col + 1] = limit [limitOffset + JpegUtils.DESCALE (tmp10 - tmp0' REDUCED_CONST_BITS + REDUCED_PASS1_BITS + 3 + 2) & RANGE_MASK];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_inverse_dct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_inverse_dct.cs,jpeg_idct_1x1,The following statement contains a magic number: dcval = JpegUtils.DESCALE (dcval' 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,jpeg_marker_reader,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	m_process_APPn [i] = skip_variable;  	m_length_limit_APPn [i] = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,jpeg_marker_reader,The following statement contains a magic number: m_process_APPn [14] = get_interesting_appn;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_restart_marker,The following statement contains a magic number: if (m_cinfo.m_unread_marker == ((int)JPEG_MARKER.RST0 + m_cinfo.m_marker.m_next_restart_num)) {  	/* Normal case --- swallow the marker and let entropy decoder continue */m_cinfo.TRACEMS (3' J_MESSAGE_CODE.JTRC_RST' m_cinfo.m_marker.m_next_restart_num);  	m_cinfo.m_unread_marker = 0;  }  else {  	/* Uh-oh' the restart markers have been messed up. *//* Let the data source manager determine how to resync. */if (!m_cinfo.m_src.resync_to_restart (m_cinfo' m_cinfo.m_marker.m_next_restart_num))  		return false;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_restart_marker,The following statement contains a magic number: m_cinfo.TRACEMS (3' J_MESSAGE_CODE.JTRC_RST' m_cinfo.m_marker.m_next_restart_num);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,read_restart_marker,The following statement contains a magic number: m_cinfo.m_marker.m_next_restart_num = (m_cinfo.m_marker.m_next_restart_num + 1) & 7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,next_marker,The following statement contains a magic number: for (; ;) {  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	/* Skip any non-FF bytes.                  * This may look a bit inefficient' but it will not occur in a valid file.                  * We sync after each discarded byte so that a suspending data source                  * can discard the byte from its buffer.                  */while (c != 0xFF) {  		m_cinfo.m_marker.m_discarded_bytes++;  		if (!m_cinfo.m_src.GetByte (out c))  			return false;  	}  	/* This loop swallows any duplicate FF bytes.  Extra FFs are legal as                  * pad bytes' so don't count them in discarded_bytes.  We assume there                  * will not be so many consecutive FF bytes as to overflow a suspending                  * data source's input buffer.                  */do {  		if (!m_cinfo.m_src.GetByte (out c))  			return false;  	}  	while (c == 0xFF);  	if (c != 0) {  		/* found a valid marker' exit loop */break;  	}  	/* Reach here if we found a stuffed-zero data sequence (FF/00).                  * Discard it and loop back to try again.                  */m_cinfo.m_marker.m_discarded_bytes += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,next_marker,The following statement contains a magic number: m_cinfo.m_marker.m_discarded_bytes += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,save_marker,The following statement contains a magic number: if (cur_marker == null) {  	/* begin reading a marker */if (!cinfo.m_src.GetTwoBytes (out length))  		return false;  	length -= 2;  	if (length >= 0) {  		/* watch out for bogus length word *//* figure out how much we want to save */int limit;  		if (cinfo.m_unread_marker == (int)JPEG_MARKER.COM)  			limit = cinfo.m_marker.m_length_limit_COM;  		else  			limit = cinfo.m_marker.m_length_limit_APPn [cinfo.m_unread_marker - (int)JPEG_MARKER.APP0];  		if (length < limit)  			limit = length;  		/* allocate and initialize the marker item */cur_marker = new jpeg_marker_struct ((byte)cinfo.m_unread_marker' length' limit);  		/* data area is just beyond the jpeg_marker_struct */data = cur_marker.Data;  		cinfo.m_marker.m_cur_marker = cur_marker;  		cinfo.m_marker.m_bytes_read = 0;  		bytes_read = 0;  		data_length = limit;  	}  	else {  		/* deal with bogus length word */bytes_read = data_length = 0;  		data = null;  	}  }  else {  	/* resume reading a marker */bytes_read = cinfo.m_marker.m_bytes_read;  	data_length = cur_marker.Data.Length;  	data = cur_marker.Data;  	dataOffset = bytes_read;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,save_marker,The following statement contains a magic number: length -= 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,skip_variable,The following statement contains a magic number: length -= 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_interesting_appn,The following statement contains a magic number: length -= 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= APP0_DATA_LEN && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x49 && data [3] == 0x46 && data [4] == 0) {  	/* Found JFIF APP0 marker: save info */cinfo.m_saw_JFIF_marker = true;  	cinfo.m_JFIF_major_version = data [5];  	cinfo.m_JFIF_minor_version = data [6];  	cinfo.m_density_unit = (DensityUnit)data [7];  	cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  	cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  	/* Check version.                  * Major version must be 1' anything else signals an incompatible change.                  * (We used to treat this as an error' but now it's a nonfatal warning'                  * because some bozo at Hijaak couldn't read the spec.)                  * Minor version should be 0..2' but process anyway if newer.                  */if (cinfo.m_JFIF_major_version != 1)  		cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JFIF_MAJOR' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version);  	/* Generate trace messages */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF' cinfo.m_JFIF_major_version' cinfo.m_JFIF_minor_version' cinfo.m_X_density' cinfo.m_Y_density' cinfo.m_density_unit);  	/* Validate thumbnail dimensions and issue appropriate messages */if ((data [12] | data [13]) != 0)  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  	totallen -= APP0_DATA_LEN;  	if (totallen != ((int)data [12] * (int)data [13] * 3))  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  }  else if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_JFIF_major_version = data [5];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_JFIF_minor_version = data [6];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_density_unit = (DensityUnit)data [7];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_X_density = (short)((data [8] << 8) + data [9]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.m_Y_density = (short)((data [10] << 8) + data [11]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if ((data [12] | data [13]) != 0)  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if ((data [12] | data [13]) != 0)  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if ((data [12] | data [13]) != 0)  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if ((data [12] | data [13]) != 0)  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL' data [12]' data [13]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (totallen != ((int)data [12] * (int)data [13] * 3))  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (totallen != ((int)data [12] * (int)data [13] * 3))  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (totallen != ((int)data [12] * (int)data [13] * 3))  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE' totallen);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: if (datalen >= 6 && data [0] == 0x4A && data [1] == 0x46 && data [2] == 0x58 && data [3] == 0x58 && data [4] == 0) {  	/* Found JFIF "JFXX" extension APP0 marker *//* The library doesn't actually do anything with these'                  * but we try to produce a helpful trace message.                  */switch (data [5]) {  	case 0x10:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  		break;  	case 0x11:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  		break;  	case 0x13:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  		break;  	default:  		cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  		break;  	}  }  else {  	/* Start of APP0 does not match "JFIF" or "JFXX"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP0' totallen);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: switch (data [5]) {  case 0x10:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  	break;  case 0x11:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  	break;  case 0x13:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  	break;  default:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: switch (data [5]) {  case 0x10:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_JPEG' totallen);  	break;  case 0x11:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_PALETTE' totallen);  	break;  case 0x13:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_THUMB_RGB' totallen);  	break;  default:  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app0,The following statement contains a magic number: cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_JFIF_EXTENSION' data [5]' totallen);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,examine_app14,The following statement contains a magic number: if (datalen >= APP14_DATA_LEN && data [0] == 0x41 && data [1] == 0x64 && data [2] == 0x6F && data [3] == 0x62 && data [4] == 0x65) {  	/* Found Adobe APP14 marker */int version = (data [5] << 8) + data [6];  	int flags0 = (data [7] << 8) + data [8];  	int flags1 = (data [9] << 8) + data [10];  	int transform = data [11];  	cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_ADOBE' version' flags0' flags1' transform);  	cinfo.m_saw_Adobe_marker = true;  	cinfo.m_Adobe_transform = (byte)transform;  }  else {  	/* Start of APP14 does not match "Adobe"' or too short */cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_APP14' datalen + remaining);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: length -= 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: if (length != (m_cinfo.m_num_components * 3))  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_LENGTH);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	m_cinfo.Comp_info [ci].Component_index = ci;  	int component_id;  	if (!m_cinfo.m_src.GetByte (out component_id))  		return false;  	m_cinfo.Comp_info [ci].Component_id = component_id;  	int c;  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	m_cinfo.Comp_info [ci].H_samp_factor = (c >> 4) & 15;  	m_cinfo.Comp_info [ci].V_samp_factor = (c) & 15;  	int quant_tbl_no;  	if (!m_cinfo.m_src.GetByte (out quant_tbl_no))  		return false;  	m_cinfo.Comp_info [ci].Quant_tbl_no = quant_tbl_no;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOF_COMPONENT' m_cinfo.Comp_info [ci].Component_id' m_cinfo.Comp_info [ci].H_samp_factor' m_cinfo.Comp_info [ci].V_samp_factor' m_cinfo.Comp_info [ci].Quant_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	m_cinfo.Comp_info [ci].Component_index = ci;  	int component_id;  	if (!m_cinfo.m_src.GetByte (out component_id))  		return false;  	m_cinfo.Comp_info [ci].Component_id = component_id;  	int c;  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	m_cinfo.Comp_info [ci].H_samp_factor = (c >> 4) & 15;  	m_cinfo.Comp_info [ci].V_samp_factor = (c) & 15;  	int quant_tbl_no;  	if (!m_cinfo.m_src.GetByte (out quant_tbl_no))  		return false;  	m_cinfo.Comp_info [ci].Quant_tbl_no = quant_tbl_no;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOF_COMPONENT' m_cinfo.Comp_info [ci].Component_id' m_cinfo.Comp_info [ci].H_samp_factor' m_cinfo.Comp_info [ci].V_samp_factor' m_cinfo.Comp_info [ci].Quant_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	m_cinfo.Comp_info [ci].Component_index = ci;  	int component_id;  	if (!m_cinfo.m_src.GetByte (out component_id))  		return false;  	m_cinfo.Comp_info [ci].Component_id = component_id;  	int c;  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	m_cinfo.Comp_info [ci].H_samp_factor = (c >> 4) & 15;  	m_cinfo.Comp_info [ci].V_samp_factor = (c) & 15;  	int quant_tbl_no;  	if (!m_cinfo.m_src.GetByte (out quant_tbl_no))  		return false;  	m_cinfo.Comp_info [ci].Quant_tbl_no = quant_tbl_no;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOF_COMPONENT' m_cinfo.Comp_info [ci].Component_id' m_cinfo.Comp_info [ci].H_samp_factor' m_cinfo.Comp_info [ci].V_samp_factor' m_cinfo.Comp_info [ci].Quant_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: m_cinfo.Comp_info [ci].H_samp_factor = (c >> 4) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: m_cinfo.Comp_info [ci].H_samp_factor = (c >> 4) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sof,The following statement contains a magic number: m_cinfo.Comp_info [ci].V_samp_factor = (c) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: if (length != (n * 2 + 6) || n < 1 || n > JpegConstants.MAX_COMPS_IN_SCAN)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_LENGTH);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: if (length != (n * 2 + 6) || n < 1 || n > JpegConstants.MAX_COMPS_IN_SCAN)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_LENGTH);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int cc;  	if (!m_cinfo.m_src.GetByte (out cc))  		return false;  	int c;  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	bool idFound = false;  	int foundIndex = -1;  	for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  		if (cc == m_cinfo.Comp_info [ci].Component_id) {  			foundIndex = ci;  			idFound = true;  			break;  		}  	}  	if (!idFound)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID' cc);  	m_cinfo.m_cur_comp_info [i] = foundIndex;  	m_cinfo.Comp_info [foundIndex].Dc_tbl_no = (c >> 4) & 15;  	m_cinfo.Comp_info [foundIndex].Ac_tbl_no = (c) & 15;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOS_COMPONENT' cc' m_cinfo.Comp_info [foundIndex].Dc_tbl_no' m_cinfo.Comp_info [foundIndex].Ac_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int cc;  	if (!m_cinfo.m_src.GetByte (out cc))  		return false;  	int c;  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	bool idFound = false;  	int foundIndex = -1;  	for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  		if (cc == m_cinfo.Comp_info [ci].Component_id) {  			foundIndex = ci;  			idFound = true;  			break;  		}  	}  	if (!idFound)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID' cc);  	m_cinfo.m_cur_comp_info [i] = foundIndex;  	m_cinfo.Comp_info [foundIndex].Dc_tbl_no = (c >> 4) & 15;  	m_cinfo.Comp_info [foundIndex].Ac_tbl_no = (c) & 15;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOS_COMPONENT' cc' m_cinfo.Comp_info [foundIndex].Dc_tbl_no' m_cinfo.Comp_info [foundIndex].Ac_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int cc;  	if (!m_cinfo.m_src.GetByte (out cc))  		return false;  	int c;  	if (!m_cinfo.m_src.GetByte (out c))  		return false;  	bool idFound = false;  	int foundIndex = -1;  	for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  		if (cc == m_cinfo.Comp_info [ci].Component_id) {  			foundIndex = ci;  			idFound = true;  			break;  		}  	}  	if (!idFound)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID' cc);  	m_cinfo.m_cur_comp_info [i] = foundIndex;  	m_cinfo.Comp_info [foundIndex].Dc_tbl_no = (c >> 4) & 15;  	m_cinfo.Comp_info [foundIndex].Ac_tbl_no = (c) & 15;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_SOS_COMPONENT' cc' m_cinfo.Comp_info [foundIndex].Dc_tbl_no' m_cinfo.Comp_info [foundIndex].Ac_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: m_cinfo.Comp_info [foundIndex].Dc_tbl_no = (c >> 4) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: m_cinfo.Comp_info [foundIndex].Dc_tbl_no = (c >> 4) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: m_cinfo.Comp_info [foundIndex].Ac_tbl_no = (c) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: m_cinfo.m_Ah = (temp >> 4) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: m_cinfo.m_Ah = (temp >> 4) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_sos,The following statement contains a magic number: m_cinfo.m_Al = (temp) & 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: length -= 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: while (length > 16) {  	int index;  	if (!m_cinfo.m_src.GetByte (out index))  		return false;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DHT' index);  	bits [0] = 0;  	int count = 0;  	for (int i = 1; i <= 16; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		bits [i] = (byte)temp;  		count += bits [i];  	}  	length -= 1 + 16;  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  	/* Here we just do minimal validation of the counts to avoid walking                  * off the end of our table space. huff_entropy_decoder will check more carefully.                  */if (count > 256 || count > length)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  	for (int i = 0; i < count; i++) {  		int temp = 0;  		if (!m_cinfo.m_src.GetByte (out temp))  			return false;  		huffval [i] = (byte)temp;  	}  	length -= count;  	JHUFF_TBL htblptr = null;  	if ((index & 0x10) != 0) {  		/* AC table definition */index -= 0x10;  		if (m_cinfo.m_ac_huff_tbl_ptrs [index] == null)  			m_cinfo.m_ac_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_ac_huff_tbl_ptrs [index];  	}  	else {  		/* DC table definition */if (m_cinfo.m_dc_huff_tbl_ptrs [index] == null)  			m_cinfo.m_dc_huff_tbl_ptrs [index] = new JHUFF_TBL ();  		htblptr = m_cinfo.m_dc_huff_tbl_ptrs [index];  	}  	if (index < 0 || index >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DHT_INDEX' index);  	Buffer.BlockCopy (bits' 0' htblptr.Bits' 0' htblptr.Bits.Length);  	Buffer.BlockCopy (huffval' 0' htblptr.Huffval' 0' htblptr.Huffval.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: for (int i = 1; i <= 16; i++) {  	int temp = 0;  	if (!m_cinfo.m_src.GetByte (out temp))  		return false;  	bits [i] = (byte)temp;  	count += bits [i];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: length -= 1 + 16;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [1]' bits [2]' bits [3]' bits [4]' bits [5]' bits [6]' bits [7]' bits [8]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_HUFFBITS' bits [9]' bits [10]' bits [11]' bits [12]' bits [13]' bits [14]' bits [15]' bits [16]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dht,The following statement contains a magic number: if (count > 256 || count > length)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: length -= 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: while (length > 0) {  	int n;  	if (!m_cinfo.m_src.GetByte (out n))  		return false;  	int prec = n >> 4;  	n &= 0x0F;  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_DQT' n' prec);  	if (n >= JpegConstants.NUM_QUANT_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_DQT_INDEX' n);  	if (m_cinfo.m_quant_tbl_ptrs [n] == null)  		m_cinfo.m_quant_tbl_ptrs [n] = new JQUANT_TBL ();  	JQUANT_TBL quant_ptr = m_cinfo.m_quant_tbl_ptrs [n];  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		int tmp;  		if (prec != 0) {  			int temp = 0;  			if (!m_cinfo.m_src.GetTwoBytes (out temp))  				return false;  			tmp = temp;  		}  		else {  			int temp = 0;  			if (!m_cinfo.m_src.GetByte (out temp))  				return false;  			tmp = temp;  		}  		/* We convert the zigzag-order table to natural array order. */quant_ptr.quantval [JpegUtils.jpeg_natural_order [i]] = (short)tmp;  	}  	if (m_cinfo.m_err.m_trace_level >= 2) {  		for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  			m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  		}  	}  	length -= JpegConstants.DCTSIZE2 + 1;  	if (prec != 0)  		length -= JpegConstants.DCTSIZE2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: if (m_cinfo.m_err.m_trace_level >= 2) {  	for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  		m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i += 8) {  	m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: i += 8
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dqt,The following statement contains a magic number: m_cinfo.TRACEMS (2' J_MESSAGE_CODE.JTRC_QUANTVALS' quant_ptr.quantval [i]' quant_ptr.quantval [i + 1]' quant_ptr.quantval [i + 2]' quant_ptr.quantval [i + 3]' quant_ptr.quantval [i + 4]' quant_ptr.quantval [i + 5]' quant_ptr.quantval [i + 6]' quant_ptr.quantval [i + 7]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_reader,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_reader.cs,get_dri,The following statement contains a magic number: if (length != 4)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_LENGTH);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,write_frame_header,The following statement contains a magic number: if (m_cinfo.m_progressive_mode || m_cinfo.m_data_precision != 8) {  	is_baseline = false;  }  else {  	is_baseline = true;  	for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  		if (m_cinfo.Component_info [ci].Dc_tbl_no > 1 || m_cinfo.Component_info [ci].Ac_tbl_no > 1)  			is_baseline = false;  	}  	if (prec != 0 && is_baseline) {  		is_baseline = false;  		/* If it's baseline except for quantizer size' warn the user */m_cinfo.TRACEMS (0' J_MESSAGE_CODE.JTRC_16BIT_TABLES);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,write_marker_header,The following statement contains a magic number: if (datalen > 65533)  	/* safety check */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_LENGTH);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,write_marker_header,The following statement contains a magic number: emit_2bytes (datalen + 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sos,The following statement contains a magic number: emit_2bytes (2 * m_cinfo.m_comps_in_scan + 2 + 1 + 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sos,The following statement contains a magic number: emit_2bytes (2 * m_cinfo.m_comps_in_scan + 2 + 1 + 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sos,The following statement contains a magic number: emit_2bytes (2 * m_cinfo.m_comps_in_scan + 2 + 1 + 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sos,The following statement contains a magic number: for (int i = 0; i < m_cinfo.m_comps_in_scan; i++) {  	int componentIndex = m_cinfo.m_cur_comp_info [i];  	emit_byte (m_cinfo.Component_info [componentIndex].Component_id);  	int td = m_cinfo.Component_info [componentIndex].Dc_tbl_no;  	int ta = m_cinfo.Component_info [componentIndex].Ac_tbl_no;  	if (m_cinfo.m_progressive_mode) {  		/* Progressive mode: only DC or only AC tables are used in one scan;                      * furthermore' Huffman coding of DC refinement uses no table at all.                      * We emit 0 for unused field(s); this is recommended by the P&M text                      * but does not seem to be specified in the standard.                      */if (m_cinfo.m_Ss == 0) {  			/* DC scan */ta = 0;  			if (m_cinfo.m_Ah != 0) {  				/* no DC table either */td = 0;  			}  		}  		else {  			/* AC scan */td = 0;  		}  	}  	emit_byte ((td << 4) + ta);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sos,The following statement contains a magic number: emit_byte ((td << 4) + ta);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sos,The following statement contains a magic number: emit_byte ((m_cinfo.m_Ah << 4) + m_cinfo.m_Al);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: emit_2bytes (3 * m_cinfo.m_num_components + 2 + 5 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: emit_2bytes (3 * m_cinfo.m_num_components + 2 + 5 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: emit_2bytes (3 * m_cinfo.m_num_components + 2 + 5 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: if (m_cinfo.m_image_height > 65535 || m_cinfo.m_image_width > 65535)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG' 65535);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: if (m_cinfo.m_image_height > 65535 || m_cinfo.m_image_width > 65535)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG' 65535);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: if (m_cinfo.m_image_height > 65535 || m_cinfo.m_image_width > 65535)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG' 65535);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG' 65535);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Component_info [ci];  	emit_byte (componentInfo.Component_id);  	emit_byte ((componentInfo.H_samp_factor << 4) + componentInfo.V_samp_factor);  	emit_byte (componentInfo.Quant_tbl_no);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_sof,The following statement contains a magic number: emit_byte ((componentInfo.H_samp_factor << 4) + componentInfo.V_samp_factor);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_2bytes (2 + 5 + 2 + 2 + 2 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_2bytes (2 + 5 + 2 + 2 + 2 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_2bytes (2 + 5 + 2 + 2 + 2 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_2bytes (2 + 5 + 2 + 2 + 2 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_2bytes (2 + 5 + 2 + 2 + 2 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_2bytes (100);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: switch (m_cinfo.m_jpeg_color_space) {  case J_COLOR_SPACE.JCS_YCbCr:  	emit_byte (1);  	/* Color transform = 1 */break;  case J_COLOR_SPACE.JCS_YCCK:  	emit_byte (2);  	/* Color transform = 2 */break;  default:  	emit_byte (0);  	/* Color transform = 0 */break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_adobe_app14,The following statement contains a magic number: emit_byte (2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dri,The following statement contains a magic number: emit_2bytes (4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: if (!htbl.Sent_table) {  	emit_marker (JPEG_MARKER.DHT);  	int length = 0;  	for (int i = 1; i <= 16; i++)  		length += htbl.Bits [i];  	emit_2bytes (length + 2 + 1 + 16);  	emit_byte (index);  	for (int i = 1; i <= 16; i++)  		emit_byte (htbl.Bits [i]);  	for (int i = 0; i < length; i++)  		emit_byte (htbl.Huffval [i]);  	htbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: if (!htbl.Sent_table) {  	emit_marker (JPEG_MARKER.DHT);  	int length = 0;  	for (int i = 1; i <= 16; i++)  		length += htbl.Bits [i];  	emit_2bytes (length + 2 + 1 + 16);  	emit_byte (index);  	for (int i = 1; i <= 16; i++)  		emit_byte (htbl.Bits [i]);  	for (int i = 0; i < length; i++)  		emit_byte (htbl.Huffval [i]);  	htbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: if (!htbl.Sent_table) {  	emit_marker (JPEG_MARKER.DHT);  	int length = 0;  	for (int i = 1; i <= 16; i++)  		length += htbl.Bits [i];  	emit_2bytes (length + 2 + 1 + 16);  	emit_byte (index);  	for (int i = 1; i <= 16; i++)  		emit_byte (htbl.Bits [i]);  	for (int i = 0; i < length; i++)  		emit_byte (htbl.Huffval [i]);  	htbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: if (!htbl.Sent_table) {  	emit_marker (JPEG_MARKER.DHT);  	int length = 0;  	for (int i = 1; i <= 16; i++)  		length += htbl.Bits [i];  	emit_2bytes (length + 2 + 1 + 16);  	emit_byte (index);  	for (int i = 1; i <= 16; i++)  		emit_byte (htbl.Bits [i]);  	for (int i = 0; i < length; i++)  		emit_byte (htbl.Huffval [i]);  	htbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: for (int i = 1; i <= 16; i++)  	length += htbl.Bits [i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: emit_2bytes (length + 2 + 1 + 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: emit_2bytes (length + 2 + 1 + 16);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dht,The following statement contains a magic number: for (int i = 1; i <= 16; i++)  	emit_byte (htbl.Bits [i]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	if (qtbl.quantval [i] > 255)  		prec = 1;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (qtbl.quantval [i] > 255)  	prec = 1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (!qtbl.Sent_table) {  	emit_marker (JPEG_MARKER.DQT);  	emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  	emit_byte (index + (prec << 4));  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* The table entries must be emitted in zigzag order. */int qval = qtbl.quantval [JpegUtils.jpeg_natural_order [i]];  		if (prec != 0)  			emit_byte (qval >> 8);  		emit_byte (qval & 0xFF);  	}  	qtbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (!qtbl.Sent_table) {  	emit_marker (JPEG_MARKER.DQT);  	emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  	emit_byte (index + (prec << 4));  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* The table entries must be emitted in zigzag order. */int qval = qtbl.quantval [JpegUtils.jpeg_natural_order [i]];  		if (prec != 0)  			emit_byte (qval >> 8);  		emit_byte (qval & 0xFF);  	}  	qtbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (!qtbl.Sent_table) {  	emit_marker (JPEG_MARKER.DQT);  	emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  	emit_byte (index + (prec << 4));  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* The table entries must be emitted in zigzag order. */int qval = qtbl.quantval [JpegUtils.jpeg_natural_order [i]];  		if (prec != 0)  			emit_byte (qval >> 8);  		emit_byte (qval & 0xFF);  	}  	qtbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (!qtbl.Sent_table) {  	emit_marker (JPEG_MARKER.DQT);  	emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  	emit_byte (index + (prec << 4));  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* The table entries must be emitted in zigzag order. */int qval = qtbl.quantval [JpegUtils.jpeg_natural_order [i]];  		if (prec != 0)  			emit_byte (qval >> 8);  		emit_byte (qval & 0xFF);  	}  	qtbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (!qtbl.Sent_table) {  	emit_marker (JPEG_MARKER.DQT);  	emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  	emit_byte (index + (prec << 4));  	for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  		/* The table entries must be emitted in zigzag order. */int qval = qtbl.quantval [JpegUtils.jpeg_natural_order [i]];  		if (prec != 0)  			emit_byte (qval >> 8);  		emit_byte (qval & 0xFF);  	}  	qtbl.Sent_table = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: emit_2bytes (prec != 0 ? JpegConstants.DCTSIZE2 * 2 + 1 + 2 : JpegConstants.DCTSIZE2 + 1 + 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: emit_byte (index + (prec << 4));  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: for (int i = 0; i < JpegConstants.DCTSIZE2; i++) {  	/* The table entries must be emitted in zigzag order. */int qval = qtbl.quantval [JpegUtils.jpeg_natural_order [i]];  	if (prec != 0)  		emit_byte (qval >> 8);  	emit_byte (qval & 0xFF);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: if (prec != 0)  	emit_byte (qval >> 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_dqt,The following statement contains a magic number: emit_byte (qval >> 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_jfif_app0,The following statement contains a magic number: emit_2bytes (2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_jfif_app0,The following statement contains a magic number: emit_2bytes (2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_jfif_app0,The following statement contains a magic number: emit_2bytes (2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_jfif_app0,The following statement contains a magic number: emit_2bytes (2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_jfif_app0,The following statement contains a magic number: emit_2bytes (2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,jpeg_marker_writer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_marker_writer.cs,emit_2bytes,The following statement contains a magic number: emit_byte ((value >> 8) & 0xFF);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,start_pass,The following statement contains a magic number: switch (m_cinfo.m_dither_mode) {  case J_DITHER_MODE.JDITHER_NONE:  	if (m_cinfo.m_out_color_components == 3)  		m_quantizer = QuantizerType.color_quantizer3;  	else  		m_quantizer = QuantizerType.color_quantizer;  	break;  case J_DITHER_MODE.JDITHER_ORDERED:  	if (m_cinfo.m_out_color_components == 3)  		m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  	else  		m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  	/* initialize state for ordered dither */m_row_index = 0;  	/* If user changed to ordered dither from another mode'                      * we must recreate the color index table with padding.                      * This will cost extra space' but probably isn't very likely.                      */if (!m_is_padded)  		create_colorindex ();  	/* Create ordered-dither tables if we didn't already. */if (m_odither [0] == null)  		create_odither_tables ();  	break;  case J_DITHER_MODE.JDITHER_FS:  	m_quantizer = QuantizerType.quantize_fs_dither_quantizer;  	/* initialize state for F-S dither */m_on_odd_row = false;  	/* Allocate Floyd-Steinberg workspace if didn't already. */if (m_fserrors [0] == null)  		alloc_fs_workspace ();  	/* Initialize the propagated errors to zero. */int arraysize = m_cinfo.m_output_width + 2;  	for (int i = 0; i < m_cinfo.m_out_color_components; i++)  		Array.Clear (m_fserrors [i]' 0' arraysize);  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,start_pass,The following statement contains a magic number: switch (m_cinfo.m_dither_mode) {  case J_DITHER_MODE.JDITHER_NONE:  	if (m_cinfo.m_out_color_components == 3)  		m_quantizer = QuantizerType.color_quantizer3;  	else  		m_quantizer = QuantizerType.color_quantizer;  	break;  case J_DITHER_MODE.JDITHER_ORDERED:  	if (m_cinfo.m_out_color_components == 3)  		m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  	else  		m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  	/* initialize state for ordered dither */m_row_index = 0;  	/* If user changed to ordered dither from another mode'                      * we must recreate the color index table with padding.                      * This will cost extra space' but probably isn't very likely.                      */if (!m_is_padded)  		create_colorindex ();  	/* Create ordered-dither tables if we didn't already. */if (m_odither [0] == null)  		create_odither_tables ();  	break;  case J_DITHER_MODE.JDITHER_FS:  	m_quantizer = QuantizerType.quantize_fs_dither_quantizer;  	/* initialize state for F-S dither */m_on_odd_row = false;  	/* Allocate Floyd-Steinberg workspace if didn't already. */if (m_fserrors [0] == null)  		alloc_fs_workspace ();  	/* Initialize the propagated errors to zero. */int arraysize = m_cinfo.m_output_width + 2;  	for (int i = 0; i < m_cinfo.m_out_color_components; i++)  		Array.Clear (m_fserrors [i]' 0' arraysize);  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,start_pass,The following statement contains a magic number: switch (m_cinfo.m_dither_mode) {  case J_DITHER_MODE.JDITHER_NONE:  	if (m_cinfo.m_out_color_components == 3)  		m_quantizer = QuantizerType.color_quantizer3;  	else  		m_quantizer = QuantizerType.color_quantizer;  	break;  case J_DITHER_MODE.JDITHER_ORDERED:  	if (m_cinfo.m_out_color_components == 3)  		m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  	else  		m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  	/* initialize state for ordered dither */m_row_index = 0;  	/* If user changed to ordered dither from another mode'                      * we must recreate the color index table with padding.                      * This will cost extra space' but probably isn't very likely.                      */if (!m_is_padded)  		create_colorindex ();  	/* Create ordered-dither tables if we didn't already. */if (m_odither [0] == null)  		create_odither_tables ();  	break;  case J_DITHER_MODE.JDITHER_FS:  	m_quantizer = QuantizerType.quantize_fs_dither_quantizer;  	/* initialize state for F-S dither */m_on_odd_row = false;  	/* Allocate Floyd-Steinberg workspace if didn't already. */if (m_fserrors [0] == null)  		alloc_fs_workspace ();  	/* Initialize the propagated errors to zero. */int arraysize = m_cinfo.m_output_width + 2;  	for (int i = 0; i < m_cinfo.m_out_color_components; i++)  		Array.Clear (m_fserrors [i]' 0' arraysize);  	break;  default:  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOT_COMPILED);  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (m_cinfo.m_out_color_components == 3)  	m_quantizer = QuantizerType.color_quantizer3;  else  	m_quantizer = QuantizerType.color_quantizer;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (m_cinfo.m_out_color_components == 3)  	m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  else  	m_quantizer = QuantizerType.quantize3_ord_dither_quantizer;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inIndex = 0;  	int inRow = in_row + row;  	int outIndex = 0;  	int outRow = out_row + row;  	for (int col = width; col > 0; col--) {  		int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex]];  		inIndex++;  		pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex]];  		inIndex++;  		pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex]];  		inIndex++;  		output_buf [outRow] [outIndex] = (byte)pixcode;  		outIndex++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inIndex = 0;  	int inRow = in_row + row;  	int outIndex = 0;  	int outRow = out_row + row;  	for (int col = width; col > 0; col--) {  		int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex]];  		inIndex++;  		pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex]];  		inIndex++;  		pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex]];  		inIndex++;  		output_buf [outRow] [outIndex] = (byte)pixcode;  		outIndex++;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex]];  	inIndex++;  	pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex]];  	inIndex++;  	pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex]];  	inIndex++;  	output_buf [outRow] [outIndex] = (byte)pixcode;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex]];  	inIndex++;  	pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex]];  	inIndex++;  	pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex]];  	inIndex++;  	output_buf [outRow] [outIndex] = (byte)pixcode;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The following statement contains a magic number: pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex]];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3,The following statement contains a magic number: pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex]];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int row_index = m_row_index;  	int inRow = in_row + row;  	int inIndex = 0;  	int outIndex = 0;  	int outRow = out_row + row;  	int col_index = 0;  	for (int col = width; col > 0; col--) {  		int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]];  		inIndex++;  		pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]];  		inIndex++;  		pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  		inIndex++;  		output_buf [outRow] [outIndex] = (byte)pixcode;  		outIndex++;  		col_index = (col_index + 1) & ODITHER_MASK;  	}  	row_index = (row_index + 1) & ODITHER_MASK;  	m_row_index = row_index;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int row_index = m_row_index;  	int inRow = in_row + row;  	int inIndex = 0;  	int outIndex = 0;  	int outRow = out_row + row;  	int col_index = 0;  	for (int col = width; col > 0; col--) {  		int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]];  		inIndex++;  		pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]];  		inIndex++;  		pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  		inIndex++;  		output_buf [outRow] [outIndex] = (byte)pixcode;  		outIndex++;  		col_index = (col_index + 1) & ODITHER_MASK;  	}  	row_index = (row_index + 1) & ODITHER_MASK;  	m_row_index = row_index;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int row_index = m_row_index;  	int inRow = in_row + row;  	int inIndex = 0;  	int outIndex = 0;  	int outRow = out_row + row;  	int col_index = 0;  	for (int col = width; col > 0; col--) {  		int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]];  		inIndex++;  		pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]];  		inIndex++;  		pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  		inIndex++;  		output_buf [outRow] [outIndex] = (byte)pixcode;  		outIndex++;  		col_index = (col_index + 1) & ODITHER_MASK;  	}  	row_index = (row_index + 1) & ODITHER_MASK;  	m_row_index = row_index;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]];  	inIndex++;  	pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]];  	inIndex++;  	pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  	inIndex++;  	output_buf [outRow] [outIndex] = (byte)pixcode;  	outIndex++;  	col_index = (col_index + 1) & ODITHER_MASK;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]];  	inIndex++;  	pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]];  	inIndex++;  	pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  	inIndex++;  	output_buf [outRow] [outIndex] = (byte)pixcode;  	outIndex++;  	col_index = (col_index + 1) & ODITHER_MASK;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	int pixcode = m_colorindex [0] [m_colorindexOffset [0] + input_buf [inRow] [inIndex] + m_odither [0] [row_index] [col_index]];  	inIndex++;  	pixcode += m_colorindex [1] [m_colorindexOffset [1] + input_buf [inRow] [inIndex] + m_odither [1] [row_index] [col_index]];  	inIndex++;  	pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  	inIndex++;  	output_buf [outRow] [outIndex] = (byte)pixcode;  	outIndex++;  	col_index = (col_index + 1) & ODITHER_MASK;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize3_ord_dither,The following statement contains a magic number: pixcode += m_colorindex [2] [m_colorindexOffset [2] + input_buf [inRow] [inIndex] + m_odither [2] [row_index] [col_index]];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	/* Initialize output values to 0 so can process components separately */Array.Clear (output_buf [out_row + row]' 0' width);  	for (int ci = 0; ci < nc; ci++) {  		int inRow = in_row + row;  		int inIndex = ci;  		int outIndex = 0;  		int outRow = out_row + row;  		int errorIndex = 0;  		int dir;  		/* 1 for left-to-right' -1 for right-to-left */if (m_on_odd_row) {  			/* work right to left in this row */inIndex += (width - 1) * nc;  			/* so point to rightmost pixel */outIndex += width - 1;  			dir = -1;  			errorIndex = width + 1;  			/* => entry after last column */}  		else {  			/* work left to right in this row */dir = 1;  			errorIndex = 0;  			/* => entry before first column */}  		int dirnc = dir * nc;  		/* Preset error values: no error propagated to first pixel from left */int cur = 0;  		/* and no error propagated to row below yet */int belowerr = 0;  		int bpreverr = 0;  		for (int col = width; col > 0; col--) {  			/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  			/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  			cur = limit [limitOffset + cur];  			/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  			output_buf [outRow] [outIndex] += (byte)pixcode;  			/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  			/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  			int delta = cur * 2;  			cur += delta;  			/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  			cur += delta;  			/* form error * 5 */bpreverr = belowerr + cur;  			belowerr = bnexterr;  			cur += delta;  			/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  			/* advance input to next column */outIndex += dir;  			/* advance output to next column */errorIndex += dir;  			/* advance errorIndex to current column */}  		/* Post-loop cleanup: we must unload the final error value into the                      * final fserrors[] entry.  Note we need not unload belowerr because                      * it is for the dummy column before or after the actual array.                      */m_fserrors [ci] [errorIndex + 0] = (short)bpreverr;  		/* unload prev err into array */}  	m_on_odd_row = (m_on_odd_row ? false : true);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	/* Initialize output values to 0 so can process components separately */Array.Clear (output_buf [out_row + row]' 0' width);  	for (int ci = 0; ci < nc; ci++) {  		int inRow = in_row + row;  		int inIndex = ci;  		int outIndex = 0;  		int outRow = out_row + row;  		int errorIndex = 0;  		int dir;  		/* 1 for left-to-right' -1 for right-to-left */if (m_on_odd_row) {  			/* work right to left in this row */inIndex += (width - 1) * nc;  			/* so point to rightmost pixel */outIndex += width - 1;  			dir = -1;  			errorIndex = width + 1;  			/* => entry after last column */}  		else {  			/* work left to right in this row */dir = 1;  			errorIndex = 0;  			/* => entry before first column */}  		int dirnc = dir * nc;  		/* Preset error values: no error propagated to first pixel from left */int cur = 0;  		/* and no error propagated to row below yet */int belowerr = 0;  		int bpreverr = 0;  		for (int col = width; col > 0; col--) {  			/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  			/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  			cur = limit [limitOffset + cur];  			/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  			output_buf [outRow] [outIndex] += (byte)pixcode;  			/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  			/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  			int delta = cur * 2;  			cur += delta;  			/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  			cur += delta;  			/* form error * 5 */bpreverr = belowerr + cur;  			belowerr = bnexterr;  			cur += delta;  			/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  			/* advance input to next column */outIndex += dir;  			/* advance output to next column */errorIndex += dir;  			/* advance errorIndex to current column */}  		/* Post-loop cleanup: we must unload the final error value into the                      * final fserrors[] entry.  Note we need not unload belowerr because                      * it is for the dummy column before or after the actual array.                      */m_fserrors [ci] [errorIndex + 0] = (short)bpreverr;  		/* unload prev err into array */}  	m_on_odd_row = (m_on_odd_row ? false : true);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	/* Initialize output values to 0 so can process components separately */Array.Clear (output_buf [out_row + row]' 0' width);  	for (int ci = 0; ci < nc; ci++) {  		int inRow = in_row + row;  		int inIndex = ci;  		int outIndex = 0;  		int outRow = out_row + row;  		int errorIndex = 0;  		int dir;  		/* 1 for left-to-right' -1 for right-to-left */if (m_on_odd_row) {  			/* work right to left in this row */inIndex += (width - 1) * nc;  			/* so point to rightmost pixel */outIndex += width - 1;  			dir = -1;  			errorIndex = width + 1;  			/* => entry after last column */}  		else {  			/* work left to right in this row */dir = 1;  			errorIndex = 0;  			/* => entry before first column */}  		int dirnc = dir * nc;  		/* Preset error values: no error propagated to first pixel from left */int cur = 0;  		/* and no error propagated to row below yet */int belowerr = 0;  		int bpreverr = 0;  		for (int col = width; col > 0; col--) {  			/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  			/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  			cur = limit [limitOffset + cur];  			/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  			output_buf [outRow] [outIndex] += (byte)pixcode;  			/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  			/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  			int delta = cur * 2;  			cur += delta;  			/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  			cur += delta;  			/* form error * 5 */bpreverr = belowerr + cur;  			belowerr = bnexterr;  			cur += delta;  			/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  			/* advance input to next column */outIndex += dir;  			/* advance output to next column */errorIndex += dir;  			/* advance errorIndex to current column */}  		/* Post-loop cleanup: we must unload the final error value into the                      * final fserrors[] entry.  Note we need not unload belowerr because                      * it is for the dummy column before or after the actual array.                      */m_fserrors [ci] [errorIndex + 0] = (short)bpreverr;  		/* unload prev err into array */}  	m_on_odd_row = (m_on_odd_row ? false : true);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int ci = 0; ci < nc; ci++) {  	int inRow = in_row + row;  	int inIndex = ci;  	int outIndex = 0;  	int outRow = out_row + row;  	int errorIndex = 0;  	int dir;  	/* 1 for left-to-right' -1 for right-to-left */if (m_on_odd_row) {  		/* work right to left in this row */inIndex += (width - 1) * nc;  		/* so point to rightmost pixel */outIndex += width - 1;  		dir = -1;  		errorIndex = width + 1;  		/* => entry after last column */}  	else {  		/* work left to right in this row */dir = 1;  		errorIndex = 0;  		/* => entry before first column */}  	int dirnc = dir * nc;  	/* Preset error values: no error propagated to first pixel from left */int cur = 0;  	/* and no error propagated to row below yet */int belowerr = 0;  	int bpreverr = 0;  	for (int col = width; col > 0; col--) {  		/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  		cur = limit [limitOffset + cur];  		/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  		output_buf [outRow] [outIndex] += (byte)pixcode;  		/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  		int delta = cur * 2;  		cur += delta;  		/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  		cur += delta;  		/* form error * 5 */bpreverr = belowerr + cur;  		belowerr = bnexterr;  		cur += delta;  		/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  		/* advance input to next column */outIndex += dir;  		/* advance output to next column */errorIndex += dir;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error value into the                      * final fserrors[] entry.  Note we need not unload belowerr because                      * it is for the dummy column before or after the actual array.                      */m_fserrors [ci] [errorIndex + 0] = (short)bpreverr;  	/* unload prev err into array */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int ci = 0; ci < nc; ci++) {  	int inRow = in_row + row;  	int inIndex = ci;  	int outIndex = 0;  	int outRow = out_row + row;  	int errorIndex = 0;  	int dir;  	/* 1 for left-to-right' -1 for right-to-left */if (m_on_odd_row) {  		/* work right to left in this row */inIndex += (width - 1) * nc;  		/* so point to rightmost pixel */outIndex += width - 1;  		dir = -1;  		errorIndex = width + 1;  		/* => entry after last column */}  	else {  		/* work left to right in this row */dir = 1;  		errorIndex = 0;  		/* => entry before first column */}  	int dirnc = dir * nc;  	/* Preset error values: no error propagated to first pixel from left */int cur = 0;  	/* and no error propagated to row below yet */int belowerr = 0;  	int bpreverr = 0;  	for (int col = width; col > 0; col--) {  		/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  		cur = limit [limitOffset + cur];  		/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  		output_buf [outRow] [outIndex] += (byte)pixcode;  		/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  		int delta = cur * 2;  		cur += delta;  		/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  		cur += delta;  		/* form error * 5 */bpreverr = belowerr + cur;  		belowerr = bnexterr;  		cur += delta;  		/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  		/* advance input to next column */outIndex += dir;  		/* advance output to next column */errorIndex += dir;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error value into the                      * final fserrors[] entry.  Note we need not unload belowerr because                      * it is for the dummy column before or after the actual array.                      */m_fserrors [ci] [errorIndex + 0] = (short)bpreverr;  	/* unload prev err into array */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int ci = 0; ci < nc; ci++) {  	int inRow = in_row + row;  	int inIndex = ci;  	int outIndex = 0;  	int outRow = out_row + row;  	int errorIndex = 0;  	int dir;  	/* 1 for left-to-right' -1 for right-to-left */if (m_on_odd_row) {  		/* work right to left in this row */inIndex += (width - 1) * nc;  		/* so point to rightmost pixel */outIndex += width - 1;  		dir = -1;  		errorIndex = width + 1;  		/* => entry after last column */}  	else {  		/* work left to right in this row */dir = 1;  		errorIndex = 0;  		/* => entry before first column */}  	int dirnc = dir * nc;  	/* Preset error values: no error propagated to first pixel from left */int cur = 0;  	/* and no error propagated to row below yet */int belowerr = 0;  	int bpreverr = 0;  	for (int col = width; col > 0; col--) {  		/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  		cur = limit [limitOffset + cur];  		/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  		output_buf [outRow] [outIndex] += (byte)pixcode;  		/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  		int delta = cur * 2;  		cur += delta;  		/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  		cur += delta;  		/* form error * 5 */bpreverr = belowerr + cur;  		belowerr = bnexterr;  		cur += delta;  		/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  		/* advance input to next column */outIndex += dir;  		/* advance output to next column */errorIndex += dir;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error value into the                      * final fserrors[] entry.  Note we need not unload belowerr because                      * it is for the dummy column before or after the actual array.                      */m_fserrors [ci] [errorIndex + 0] = (short)bpreverr;  	/* unload prev err into array */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  	cur = limit [limitOffset + cur];  	/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  	output_buf [outRow] [outIndex] += (byte)pixcode;  	/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  	int delta = cur * 2;  	cur += delta;  	/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  	cur += delta;  	/* form error * 5 */bpreverr = belowerr + cur;  	belowerr = bnexterr;  	cur += delta;  	/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  	/* advance input to next column */outIndex += dir;  	/* advance output to next column */errorIndex += dir;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  	cur = limit [limitOffset + cur];  	/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  	output_buf [outRow] [outIndex] += (byte)pixcode;  	/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  	int delta = cur * 2;  	cur += delta;  	/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  	cur += delta;  	/* form error * 5 */bpreverr = belowerr + cur;  	belowerr = bnexterr;  	cur += delta;  	/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  	/* advance input to next column */outIndex += dir;  	/* advance output to next column */errorIndex += dir;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: for (int col = width; col > 0; col--) {  	/* cur holds the error propagated from the previous pixel on the                          * current line.  Add the error propagated from the previous line                          * to form the complete error correction term for this pixel' and                          * round the error term (which is expressed * 16) to an integer.                          * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                          * for either sign of the error value.                          * Note: errorIndex is for *previous* column's array entry.                          */cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                          * The maximum error is +- MAXJSAMPLE; this sets the required size                          * of the range_limit array.                          */cur += input_buf [inRow] [inIndex];  	cur = limit [limitOffset + cur];  	/* Select output value' accumulate into output code for this pixel */int pixcode = m_colorindex [ci] [m_colorindexOffset [ci] + cur];  	output_buf [outRow] [outIndex] += (byte)pixcode;  	/* Compute actual representation error at this pixel *//* Note: we can do this even though we don't have the final *//* pixel code' because the colormap is orthogonal. */cur -= m_sv_colormap [ci] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                          * Add these into the running sums' and simultaneously shift the                          * next-line error sums left by 1 column.                          */int bnexterr = cur;  	int delta = cur * 2;  	cur += delta;  	/* form error * 3 */m_fserrors [ci] [errorIndex + 0] = (short)(bpreverr + cur);  	cur += delta;  	/* form error * 5 */bpreverr = belowerr + cur;  	belowerr = bnexterr;  	cur += delta;  	/* form error * 7 *//* At this point cur contains the 7/16 error value to be propagated                          * to the next pixel on the current line' and all the errors for the                          * next line have been shifted over. We are therefore ready to move on.                          */inIndex += dirnc;  	/* advance input to next column */outIndex += dir;  	/* advance output to next column */errorIndex += dir;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,quantize_fs_dither,The following statement contains a magic number: cur = JpegUtils.RIGHT_SHIFT (cur + m_fserrors [ci] [errorIndex + dir] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colormap,The following statement contains a magic number: if (m_cinfo.m_out_color_components == 3)  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS' total_colors' m_Ncolors [0]' m_Ncolors [1]' m_Ncolors [2]);  else  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_QUANT_NCOLORS' total_colors);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colormap,The following statement contains a magic number: if (m_cinfo.m_out_color_components == 3)  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS' total_colors' m_Ncolors [0]' m_Ncolors [1]' m_Ncolors [2]);  else  	m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_QUANT_NCOLORS' total_colors);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colormap,The following statement contains a magic number: m_cinfo.TRACEMS (1' J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS' total_colors' m_Ncolors [0]' m_Ncolors [1]' m_Ncolors [2]);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colorindex,The following statement contains a magic number: if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_ORDERED) {  	pad = JpegConstants.MAXJSAMPLE * 2;  	m_is_padded = true;  }  else {  	pad = 0;  	m_is_padded = false;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,create_colorindex,The following statement contains a magic number: pad = JpegConstants.MAXJSAMPLE * 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,alloc_fs_workspace,The following statement contains a magic number: for (int i = 0; i < m_cinfo.m_out_color_components; i++)  	m_fserrors [i] = new short[m_cinfo.m_output_width + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,alloc_fs_workspace,The following statement contains a magic number: m_fserrors [i] = new short[m_cinfo.m_output_width + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,largest_input_value,The following statement contains a magic number: return (int)(((2 * j + 1) * JpegConstants.MAXJSAMPLE + maxj) / (2 * maxj));  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,largest_input_value,The following statement contains a magic number: return (int)(((2 * j + 1) * JpegConstants.MAXJSAMPLE + maxj) / (2 * maxj));  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,output_value,The following statement contains a magic number: return (int)((j * JpegConstants.MAXJSAMPLE + maxj / 2) / maxj);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,select_ncolors,The following statement contains a magic number: if (iroot < 2)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' (int)temp);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,make_odither_array,The following statement contains a magic number: for (int j = 0; j < ODITHER_SIZE; j++) {  	for (int k = 0; k < ODITHER_SIZE; k++) {  		int num = ((int)(ODITHER_CELLS - 1 - 2 * ((int)base_dither_matrix [j] [k]))) * JpegConstants.MAXJSAMPLE;  		/* Ensure round towards zero despite C's lack of consistency                      * about rounding negative values in integer division...                      */odither [j] [k] = num < 0 ? -((-num) / den) : num / den;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_1pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_1pass_cquantizer.cs,make_odither_array,The following statement contains a magic number: for (int k = 0; k < ODITHER_SIZE; k++) {  	int num = ((int)(ODITHER_CELLS - 1 - 2 * ((int)base_dither_matrix [j] [k]))) * JpegConstants.MAXJSAMPLE;  	/* Ensure round towards zero despite C's lack of consistency                      * about rounding negative values in integer division...                      */odither [j] [k] = num < 0 ? -((-num) / den) : num / den;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (cinfo.m_out_color_components != 3)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (cinfo.m_enable_2pass_quant) {  	/* Make sure color count is acceptable */int desired_local = cinfo.m_desired_number_of_colors;  	/* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */if (desired_local < 8)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 8);  	/* Make sure colormap indexes can be represented by JSAMPLEs */if (desired_local > MAXNUMCOLORS)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS' MAXNUMCOLORS);  	m_sv_colormap = jpeg_common_struct.AllocJpegSamples (desired_local' 3);  	m_desired = desired_local;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (cinfo.m_enable_2pass_quant) {  	/* Make sure color count is acceptable */int desired_local = cinfo.m_desired_number_of_colors;  	/* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */if (desired_local < 8)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 8);  	/* Make sure colormap indexes can be represented by JSAMPLEs */if (desired_local > MAXNUMCOLORS)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS' MAXNUMCOLORS);  	m_sv_colormap = jpeg_common_struct.AllocJpegSamples (desired_local' 3);  	m_desired = desired_local;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (cinfo.m_enable_2pass_quant) {  	/* Make sure color count is acceptable */int desired_local = cinfo.m_desired_number_of_colors;  	/* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */if (desired_local < 8)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 8);  	/* Make sure colormap indexes can be represented by JSAMPLEs */if (desired_local > MAXNUMCOLORS)  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS' MAXNUMCOLORS);  	m_sv_colormap = jpeg_common_struct.AllocJpegSamples (desired_local' 3);  	m_desired = desired_local;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (desired_local < 8)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (desired_local < 8)  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: m_sv_colormap = jpeg_common_struct.AllocJpegSamples (desired_local' 3);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS) {  	m_fserrors = new short[(cinfo.m_output_width + 2) * 3];  	/* Might as well create the error-limiting table too. */init_error_limit ();  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: if (cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS) {  	m_fserrors = new short[(cinfo.m_output_width + 2) * 3];  	/* Might as well create the error-limiting table too. */init_error_limit ();  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: m_fserrors = new short[(cinfo.m_output_width + 2) * 3];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,my_2pass_cquantizer,The following statement contains a magic number: m_fserrors = new short[(cinfo.m_output_width + 2) * 3];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (is_pre_scan) {  	/* Set up method pointers */m_quantizer = QuantizerType.prescan_quantizer;  	m_useFinishPass1 = true;  	m_needs_zeroed = true;  	/* Always zero histogram */}  else {  	/* Set up method pointers */if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS)  		m_quantizer = QuantizerType.pass2_fs_dither_quantizer;  	else  		m_quantizer = QuantizerType.pass2_no_dither_quantizer;  	m_useFinishPass1 = false;  	/* Make sure color count is acceptable */int i = m_cinfo.m_actual_number_of_colors;  	if (i < 1)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 1);  	if (i > MAXNUMCOLORS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS' MAXNUMCOLORS);  	if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS) {  		/* Allocate Floyd-Steinberg workspace if we didn't already. */if (m_fserrors == null) {  			int arraysize = (m_cinfo.m_output_width + 2) * 3;  			m_fserrors = new short[arraysize];  		}  		else {  			/* Initialize the propagated errors to zero. */Array.Clear (m_fserrors' 0' m_fserrors.Length);  		}  		/* Make the error-limit table if we didn't already. */if (m_error_limiter == null)  			init_error_limit ();  		m_on_odd_row = false;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (is_pre_scan) {  	/* Set up method pointers */m_quantizer = QuantizerType.prescan_quantizer;  	m_useFinishPass1 = true;  	m_needs_zeroed = true;  	/* Always zero histogram */}  else {  	/* Set up method pointers */if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS)  		m_quantizer = QuantizerType.pass2_fs_dither_quantizer;  	else  		m_quantizer = QuantizerType.pass2_no_dither_quantizer;  	m_useFinishPass1 = false;  	/* Make sure color count is acceptable */int i = m_cinfo.m_actual_number_of_colors;  	if (i < 1)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS' 1);  	if (i > MAXNUMCOLORS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS' MAXNUMCOLORS);  	if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS) {  		/* Allocate Floyd-Steinberg workspace if we didn't already. */if (m_fserrors == null) {  			int arraysize = (m_cinfo.m_output_width + 2) * 3;  			m_fserrors = new short[arraysize];  		}  		else {  			/* Initialize the propagated errors to zero. */Array.Clear (m_fserrors' 0' m_fserrors.Length);  		}  		/* Make the error-limit table if we didn't already. */if (m_error_limiter == null)  			init_error_limit ();  		m_on_odd_row = false;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS) {  	/* Allocate Floyd-Steinberg workspace if we didn't already. */if (m_fserrors == null) {  		int arraysize = (m_cinfo.m_output_width + 2) * 3;  		m_fserrors = new short[arraysize];  	}  	else {  		/* Initialize the propagated errors to zero. */Array.Clear (m_fserrors' 0' m_fserrors.Length);  	}  	/* Make the error-limit table if we didn't already. */if (m_error_limiter == null)  		init_error_limit ();  	m_on_odd_row = false;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (m_cinfo.m_dither_mode == J_DITHER_MODE.JDITHER_FS) {  	/* Allocate Floyd-Steinberg workspace if we didn't already. */if (m_fserrors == null) {  		int arraysize = (m_cinfo.m_output_width + 2) * 3;  		m_fserrors = new short[arraysize];  	}  	else {  		/* Initialize the propagated errors to zero. */Array.Clear (m_fserrors' 0' m_fserrors.Length);  	}  	/* Make the error-limit table if we didn't already. */if (m_error_limiter == null)  		init_error_limit ();  	m_on_odd_row = false;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (m_fserrors == null) {  	int arraysize = (m_cinfo.m_output_width + 2) * 3;  	m_fserrors = new short[arraysize];  }  else {  	/* Initialize the propagated errors to zero. */Array.Clear (m_fserrors' 0' m_fserrors.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,start_pass,The following statement contains a magic number: if (m_fserrors == null) {  	int arraysize = (m_cinfo.m_output_width + 2) * 3;  	m_fserrors = new short[arraysize];  }  else {  	/* Initialize the propagated errors to zero. */Array.Clear (m_fserrors' 0' m_fserrors.Length);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,prescan_quantize,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputIndex = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		int rowIndex = (int)input_buf [in_row + row] [inputIndex] >> C0_SHIFT;  		int columnIndex = ((int)input_buf [in_row + row] [inputIndex + 1] >> C1_SHIFT) * HIST_C2_ELEMS + ((int)input_buf [in_row + row] [inputIndex + 2] >> C2_SHIFT);  		/* increment pixel value' check for overflow and undo increment if so. */m_histogram [rowIndex] [columnIndex]++;  		if (m_histogram [rowIndex] [columnIndex] <= 0)  			m_histogram [rowIndex] [columnIndex]--;  		inputIndex += 3;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,prescan_quantize,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputIndex = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		int rowIndex = (int)input_buf [in_row + row] [inputIndex] >> C0_SHIFT;  		int columnIndex = ((int)input_buf [in_row + row] [inputIndex + 1] >> C1_SHIFT) * HIST_C2_ELEMS + ((int)input_buf [in_row + row] [inputIndex + 2] >> C2_SHIFT);  		/* increment pixel value' check for overflow and undo increment if so. */m_histogram [rowIndex] [columnIndex]++;  		if (m_histogram [rowIndex] [columnIndex] <= 0)  			m_histogram [rowIndex] [columnIndex]--;  		inputIndex += 3;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,prescan_quantize,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	int rowIndex = (int)input_buf [in_row + row] [inputIndex] >> C0_SHIFT;  	int columnIndex = ((int)input_buf [in_row + row] [inputIndex + 1] >> C1_SHIFT) * HIST_C2_ELEMS + ((int)input_buf [in_row + row] [inputIndex + 2] >> C2_SHIFT);  	/* increment pixel value' check for overflow and undo increment if so. */m_histogram [rowIndex] [columnIndex]++;  	if (m_histogram [rowIndex] [columnIndex] <= 0)  		m_histogram [rowIndex] [columnIndex]--;  	inputIndex += 3;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,prescan_quantize,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	int rowIndex = (int)input_buf [in_row + row] [inputIndex] >> C0_SHIFT;  	int columnIndex = ((int)input_buf [in_row + row] [inputIndex + 1] >> C1_SHIFT) * HIST_C2_ELEMS + ((int)input_buf [in_row + row] [inputIndex + 2] >> C2_SHIFT);  	/* increment pixel value' check for overflow and undo increment if so. */m_histogram [rowIndex] [columnIndex]++;  	if (m_histogram [rowIndex] [columnIndex] <= 0)  		m_histogram [rowIndex] [columnIndex]--;  	inputIndex += 3;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,prescan_quantize,The following statement contains a magic number: inputIndex += 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int row = 0; row < num_rows; row++) {  	int inputPixelIndex = 0;  	int outputPixelIndex = 0;  	int errorIndex = 0;  	int dir;  	/* +1 or -1 depending on direction */int dir3;  	/* 3*dir' for advancing inputIndex & errorIndex */if (m_on_odd_row) {  		/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  		/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  		dir = -1;  		dir3 = -3;  		errorIndex = (m_cinfo.m_output_width + 1) * 3;  		/* => entry after last column */m_on_odd_row = false;  		/* flip for next time */}  	else {  		/* work left to right in this row */dir = 1;  		dir3 = 3;  		errorIndex = 0;  		/* => entry before first real column */m_on_odd_row = true;  		/* flip for next time */}  	/* Preset error values: no error propagated to first pixel from left *//* current error or pixel value */int cur0 = 0;  	int cur1 = 0;  	int cur2 = 0;  	/* and no error propagated to row below yet *//* error for pixel below cur */int belowerr0 = 0;  	int belowerr1 = 0;  	int belowerr2 = 0;  	/* error for below/prev col */int bpreverr0 = 0;  	int bpreverr1 = 0;  	int bpreverr2 = 0;  	for (int col = m_cinfo.m_output_width; col > 0; col--) {  		/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  		cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  		cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  		/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  		cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  		cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  		/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  		cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  		cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  		cur0 = limit [limitOffset + cur0];  		cur1 = limit [limitOffset + cur1];  		cur2 = limit [limitOffset + cur2];  		/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  		int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  		/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  			fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  		/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  		output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  		/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  		cur1 -= m_cinfo.m_colormap [1] [pixcode];  		cur2 -= m_cinfo.m_colormap [2] [pixcode];  		/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  		/* Process component 0 */int delta = cur0 * 2;  		cur0 += delta;  		/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  		cur0 += delta;  		/* form error * 5 */bpreverr0 = belowerr0 + cur0;  		belowerr0 = bnexterr;  		cur0 += delta;  		/* form error * 7 */bnexterr = cur1;  		/* Process component 1 */delta = cur1 * 2;  		cur1 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  		cur1 += delta;  		/* form error * 5 */bpreverr1 = belowerr1 + cur1;  		belowerr1 = bnexterr;  		cur1 += delta;  		/* form error * 7 */bnexterr = cur2;  		/* Process component 2 */delta = cur2 * 2;  		cur2 += delta;  		/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  		cur2 += delta;  		/* form error * 5 */bpreverr2 = belowerr2 + cur2;  		belowerr2 = bnexterr;  		cur2 += delta;  		/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  		/* Advance pixel pointers to next column */outputPixelIndex += dir;  		errorIndex += dir3;  		/* advance errorIndex to current column */}  	/* Post-loop cleanup: we must unload the final error values into the                  * final fserrors[] entry.  Note we need not unload belowerrN because                  * it is for the dummy column before or after the actual array.                  */m_fserrors [errorIndex] = (short)bpreverr0;  	/* unload prev errs into array */m_fserrors [errorIndex + 1] = (short)bpreverr1;  	m_fserrors [errorIndex + 2] = (short)bpreverr2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: if (m_on_odd_row) {  	/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  	/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  	dir = -1;  	dir3 = -3;  	errorIndex = (m_cinfo.m_output_width + 1) * 3;  	/* => entry after last column */m_on_odd_row = false;  	/* flip for next time */}  else {  	/* work left to right in this row */dir = 1;  	dir3 = 3;  	errorIndex = 0;  	/* => entry before first real column */m_on_odd_row = true;  	/* flip for next time */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: if (m_on_odd_row) {  	/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  	/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  	dir = -1;  	dir3 = -3;  	errorIndex = (m_cinfo.m_output_width + 1) * 3;  	/* => entry after last column */m_on_odd_row = false;  	/* flip for next time */}  else {  	/* work left to right in this row */dir = 1;  	dir3 = 3;  	errorIndex = 0;  	/* => entry before first real column */m_on_odd_row = true;  	/* flip for next time */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: if (m_on_odd_row) {  	/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  	/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  	dir = -1;  	dir3 = -3;  	errorIndex = (m_cinfo.m_output_width + 1) * 3;  	/* => entry after last column */m_on_odd_row = false;  	/* flip for next time */}  else {  	/* work left to right in this row */dir = 1;  	dir3 = 3;  	errorIndex = 0;  	/* => entry before first real column */m_on_odd_row = true;  	/* flip for next time */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: if (m_on_odd_row) {  	/* work right to left in this row */inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  	/* so point to rightmost pixel */outputPixelIndex += m_cinfo.m_output_width - 1;  	dir = -1;  	dir3 = -3;  	errorIndex = (m_cinfo.m_output_width + 1) * 3;  	/* => entry after last column */m_on_odd_row = false;  	/* flip for next time */}  else {  	/* work left to right in this row */dir = 1;  	dir3 = 3;  	errorIndex = 0;  	/* => entry before first real column */m_on_odd_row = true;  	/* flip for next time */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: inputPixelIndex += (m_cinfo.m_output_width - 1) * 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: dir3 = -3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: errorIndex = (m_cinfo.m_output_width + 1) * 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: dir3 = 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: for (int col = m_cinfo.m_output_width; col > 0; col--) {  	/* curN holds the error propagated from the previous pixel on the                      * current line.  Add the error propagated from the previous line                      * to form the complete error correction term for this pixel' and                      * round the error term (which is expressed * 16) to an integer.                      * RIGHT_SHIFT rounds towards minus infinity' so adding 8 is correct                      * for either sign of the error value.                      * Note: errorIndex is for *previous* column's array entry.                      */cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  	cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  	cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  	/* Limit the error using transfer function set by init_error_limit.                      * See comments with init_error_limit for rationale.                      */cur0 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur0];  	cur1 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur1];  	cur2 = m_error_limiter [JpegConstants.MAXJSAMPLE + cur2];  	/* Form pixel value + error' and range-limit to 0..MAXJSAMPLE.                      * The maximum error is +- MAXJSAMPLE (or less with error limiting);                      * this sets the required size of the range_limit array.                      */cur0 += input_buf [in_row + row] [inputPixelIndex];  	cur1 += input_buf [in_row + row] [inputPixelIndex + 1];  	cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  	cur0 = limit [limitOffset + cur0];  	cur1 = limit [limitOffset + cur1];  	cur2 = limit [limitOffset + cur2];  	/* Index into the cache with adjusted pixel value */int hRow = cur0 >> C0_SHIFT;  	int hColumn = (cur1 >> C1_SHIFT) * HIST_C2_ELEMS + (cur2 >> C2_SHIFT);  	/* If we have not seen this color before' find nearest colormap *//* entry and update the cache */if (m_histogram [hRow] [hColumn] == 0)  		fill_inverse_cmap (cur0 >> C0_SHIFT' cur1 >> C1_SHIFT' cur2 >> C2_SHIFT);  	/* Now emit the colormap index for this cell */int pixcode = m_histogram [hRow] [hColumn] - 1;  	output_buf [out_row + row] [outputPixelIndex] = (byte)pixcode;  	/* Compute representation error for this pixel */cur0 -= m_cinfo.m_colormap [0] [pixcode];  	cur1 -= m_cinfo.m_colormap [1] [pixcode];  	cur2 -= m_cinfo.m_colormap [2] [pixcode];  	/* Compute error fractions to be propagated to adjacent pixels.                      * Add these into the running sums' and simultaneously shift the                      * next-line error sums left by 1 column.                      */int bnexterr = cur0;  	/* Process component 0 */int delta = cur0 * 2;  	cur0 += delta;  	/* form error * 3 */m_fserrors [errorIndex] = (short)(bpreverr0 + cur0);  	cur0 += delta;  	/* form error * 5 */bpreverr0 = belowerr0 + cur0;  	belowerr0 = bnexterr;  	cur0 += delta;  	/* form error * 7 */bnexterr = cur1;  	/* Process component 1 */delta = cur1 * 2;  	cur1 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 1] = (short)(bpreverr1 + cur1);  	cur1 += delta;  	/* form error * 5 */bpreverr1 = belowerr1 + cur1;  	belowerr1 = bnexterr;  	cur1 += delta;  	/* form error * 7 */bnexterr = cur2;  	/* Process component 2 */delta = cur2 * 2;  	cur2 += delta;  	/* form error * 3 */m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  	cur2 += delta;  	/* form error * 5 */bpreverr2 = belowerr2 + cur2;  	belowerr2 = bnexterr;  	cur2 += delta;  	/* form error * 7 *//* At this point curN contains the 7/16 error value to be propagated                      * to the next pixel on the current line' and all the errors for the                      * next line have been shifted over.  We are therefore ready to move on.                      */inputPixelIndex += dir3;  	/* Advance pixel pointers to next column */outputPixelIndex += dir;  	errorIndex += dir3;  	/* advance errorIndex to current column */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur0 = JpegUtils.RIGHT_SHIFT (cur0 + m_fserrors [errorIndex + dir3] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur1 = JpegUtils.RIGHT_SHIFT (cur1 + m_fserrors [errorIndex + dir3 + 1] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur2 = JpegUtils.RIGHT_SHIFT (cur2 + m_fserrors [errorIndex + dir3 + 2] + 8' 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur2 += input_buf [in_row + row] [inputPixelIndex + 2];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: cur2 -= m_cinfo.m_colormap [2] [pixcode];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: delta = cur1 * 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: delta = cur2 * 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: m_fserrors [errorIndex + 2] = (short)(bpreverr2 + cur2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,pass2_fs_dither,The following statement contains a magic number: m_fserrors [errorIndex + 2] = (short)bpreverr2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,compute_color,The following statement contains a magic number: m_cinfo.m_colormap [2] [icolor] = (byte)((c2total + (total >> 1)) / total);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: while (numboxes < desired_colors) {  	/* Select box to split.                  * Current algorithm: by population for first half' then by volume.                  */int foundIndex;  	if (numboxes * 2 <= desired_colors)  		foundIndex = find_biggest_color_pop (boxlist' numboxes);  	else  		foundIndex = find_biggest_volume (boxlist' numboxes);  	if (foundIndex == -1)  		/* no splittable boxes left! */break;  	/* Copy the color bounds to the new box. */boxlist [numboxes].c0max = boxlist [foundIndex].c0max;  	boxlist [numboxes].c1max = boxlist [foundIndex].c1max;  	boxlist [numboxes].c2max = boxlist [foundIndex].c2max;  	boxlist [numboxes].c0min = boxlist [foundIndex].c0min;  	boxlist [numboxes].c1min = boxlist [foundIndex].c1min;  	boxlist [numboxes].c2min = boxlist [foundIndex].c2min;  	/* Choose which axis to split the box on.                  * Current algorithm: longest scaled axis.                  * See notes in update_box about scaling distances.                  */int c0 = ((boxlist [foundIndex].c0max - boxlist [foundIndex].c0min) << C0_SHIFT) * R_SCALE;  	int c1 = ((boxlist [foundIndex].c1max - boxlist [foundIndex].c1min) << C1_SHIFT) * G_SCALE;  	int c2 = ((boxlist [foundIndex].c2max - boxlist [foundIndex].c2min) << C2_SHIFT) * B_SCALE;  	/* We want to break any ties in favor of green' then red' blue last.                  * This code does the right thing for R'G'B or B'G'R color orders only.                  */int cmax = c1;  	int n = 1;  	if (c0 > cmax) {  		cmax = c0;  		n = 0;  	}  	if (c2 > cmax) {  		n = 2;  	}  	/* Choose split point along selected axis' and update box bounds.                  * Current algorithm: split at halfway point.                  * (Since the box has been shrunk to minimum volume'                  * any split will produce two nonempty subboxes.)                  * Note that lb value is max for lower box' so must be < old max.                  */int lb;  	switch (n) {  	case 0:  		lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  		boxlist [foundIndex].c0max = lb;  		boxlist [numboxes].c0min = lb + 1;  		break;  	case 1:  		lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  		boxlist [foundIndex].c1max = lb;  		boxlist [numboxes].c1min = lb + 1;  		break;  	case 2:  		lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  		boxlist [foundIndex].c2max = lb;  		boxlist [numboxes].c2min = lb + 1;  		break;  	}  	/* Update stats for boxes */update_box (boxlist' foundIndex);  	update_box (boxlist' numboxes);  	numboxes++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: while (numboxes < desired_colors) {  	/* Select box to split.                  * Current algorithm: by population for first half' then by volume.                  */int foundIndex;  	if (numboxes * 2 <= desired_colors)  		foundIndex = find_biggest_color_pop (boxlist' numboxes);  	else  		foundIndex = find_biggest_volume (boxlist' numboxes);  	if (foundIndex == -1)  		/* no splittable boxes left! */break;  	/* Copy the color bounds to the new box. */boxlist [numboxes].c0max = boxlist [foundIndex].c0max;  	boxlist [numboxes].c1max = boxlist [foundIndex].c1max;  	boxlist [numboxes].c2max = boxlist [foundIndex].c2max;  	boxlist [numboxes].c0min = boxlist [foundIndex].c0min;  	boxlist [numboxes].c1min = boxlist [foundIndex].c1min;  	boxlist [numboxes].c2min = boxlist [foundIndex].c2min;  	/* Choose which axis to split the box on.                  * Current algorithm: longest scaled axis.                  * See notes in update_box about scaling distances.                  */int c0 = ((boxlist [foundIndex].c0max - boxlist [foundIndex].c0min) << C0_SHIFT) * R_SCALE;  	int c1 = ((boxlist [foundIndex].c1max - boxlist [foundIndex].c1min) << C1_SHIFT) * G_SCALE;  	int c2 = ((boxlist [foundIndex].c2max - boxlist [foundIndex].c2min) << C2_SHIFT) * B_SCALE;  	/* We want to break any ties in favor of green' then red' blue last.                  * This code does the right thing for R'G'B or B'G'R color orders only.                  */int cmax = c1;  	int n = 1;  	if (c0 > cmax) {  		cmax = c0;  		n = 0;  	}  	if (c2 > cmax) {  		n = 2;  	}  	/* Choose split point along selected axis' and update box bounds.                  * Current algorithm: split at halfway point.                  * (Since the box has been shrunk to minimum volume'                  * any split will produce two nonempty subboxes.)                  * Note that lb value is max for lower box' so must be < old max.                  */int lb;  	switch (n) {  	case 0:  		lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  		boxlist [foundIndex].c0max = lb;  		boxlist [numboxes].c0min = lb + 1;  		break;  	case 1:  		lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  		boxlist [foundIndex].c1max = lb;  		boxlist [numboxes].c1min = lb + 1;  		break;  	case 2:  		lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  		boxlist [foundIndex].c2max = lb;  		boxlist [numboxes].c2min = lb + 1;  		break;  	}  	/* Update stats for boxes */update_box (boxlist' foundIndex);  	update_box (boxlist' numboxes);  	numboxes++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: while (numboxes < desired_colors) {  	/* Select box to split.                  * Current algorithm: by population for first half' then by volume.                  */int foundIndex;  	if (numboxes * 2 <= desired_colors)  		foundIndex = find_biggest_color_pop (boxlist' numboxes);  	else  		foundIndex = find_biggest_volume (boxlist' numboxes);  	if (foundIndex == -1)  		/* no splittable boxes left! */break;  	/* Copy the color bounds to the new box. */boxlist [numboxes].c0max = boxlist [foundIndex].c0max;  	boxlist [numboxes].c1max = boxlist [foundIndex].c1max;  	boxlist [numboxes].c2max = boxlist [foundIndex].c2max;  	boxlist [numboxes].c0min = boxlist [foundIndex].c0min;  	boxlist [numboxes].c1min = boxlist [foundIndex].c1min;  	boxlist [numboxes].c2min = boxlist [foundIndex].c2min;  	/* Choose which axis to split the box on.                  * Current algorithm: longest scaled axis.                  * See notes in update_box about scaling distances.                  */int c0 = ((boxlist [foundIndex].c0max - boxlist [foundIndex].c0min) << C0_SHIFT) * R_SCALE;  	int c1 = ((boxlist [foundIndex].c1max - boxlist [foundIndex].c1min) << C1_SHIFT) * G_SCALE;  	int c2 = ((boxlist [foundIndex].c2max - boxlist [foundIndex].c2min) << C2_SHIFT) * B_SCALE;  	/* We want to break any ties in favor of green' then red' blue last.                  * This code does the right thing for R'G'B or B'G'R color orders only.                  */int cmax = c1;  	int n = 1;  	if (c0 > cmax) {  		cmax = c0;  		n = 0;  	}  	if (c2 > cmax) {  		n = 2;  	}  	/* Choose split point along selected axis' and update box bounds.                  * Current algorithm: split at halfway point.                  * (Since the box has been shrunk to minimum volume'                  * any split will produce two nonempty subboxes.)                  * Note that lb value is max for lower box' so must be < old max.                  */int lb;  	switch (n) {  	case 0:  		lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  		boxlist [foundIndex].c0max = lb;  		boxlist [numboxes].c0min = lb + 1;  		break;  	case 1:  		lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  		boxlist [foundIndex].c1max = lb;  		boxlist [numboxes].c1min = lb + 1;  		break;  	case 2:  		lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  		boxlist [foundIndex].c2max = lb;  		boxlist [numboxes].c2min = lb + 1;  		break;  	}  	/* Update stats for boxes */update_box (boxlist' foundIndex);  	update_box (boxlist' numboxes);  	numboxes++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: while (numboxes < desired_colors) {  	/* Select box to split.                  * Current algorithm: by population for first half' then by volume.                  */int foundIndex;  	if (numboxes * 2 <= desired_colors)  		foundIndex = find_biggest_color_pop (boxlist' numboxes);  	else  		foundIndex = find_biggest_volume (boxlist' numboxes);  	if (foundIndex == -1)  		/* no splittable boxes left! */break;  	/* Copy the color bounds to the new box. */boxlist [numboxes].c0max = boxlist [foundIndex].c0max;  	boxlist [numboxes].c1max = boxlist [foundIndex].c1max;  	boxlist [numboxes].c2max = boxlist [foundIndex].c2max;  	boxlist [numboxes].c0min = boxlist [foundIndex].c0min;  	boxlist [numboxes].c1min = boxlist [foundIndex].c1min;  	boxlist [numboxes].c2min = boxlist [foundIndex].c2min;  	/* Choose which axis to split the box on.                  * Current algorithm: longest scaled axis.                  * See notes in update_box about scaling distances.                  */int c0 = ((boxlist [foundIndex].c0max - boxlist [foundIndex].c0min) << C0_SHIFT) * R_SCALE;  	int c1 = ((boxlist [foundIndex].c1max - boxlist [foundIndex].c1min) << C1_SHIFT) * G_SCALE;  	int c2 = ((boxlist [foundIndex].c2max - boxlist [foundIndex].c2min) << C2_SHIFT) * B_SCALE;  	/* We want to break any ties in favor of green' then red' blue last.                  * This code does the right thing for R'G'B or B'G'R color orders only.                  */int cmax = c1;  	int n = 1;  	if (c0 > cmax) {  		cmax = c0;  		n = 0;  	}  	if (c2 > cmax) {  		n = 2;  	}  	/* Choose split point along selected axis' and update box bounds.                  * Current algorithm: split at halfway point.                  * (Since the box has been shrunk to minimum volume'                  * any split will produce two nonempty subboxes.)                  * Note that lb value is max for lower box' so must be < old max.                  */int lb;  	switch (n) {  	case 0:  		lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  		boxlist [foundIndex].c0max = lb;  		boxlist [numboxes].c0min = lb + 1;  		break;  	case 1:  		lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  		boxlist [foundIndex].c1max = lb;  		boxlist [numboxes].c1min = lb + 1;  		break;  	case 2:  		lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  		boxlist [foundIndex].c2max = lb;  		boxlist [numboxes].c2min = lb + 1;  		break;  	}  	/* Update stats for boxes */update_box (boxlist' foundIndex);  	update_box (boxlist' numboxes);  	numboxes++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: while (numboxes < desired_colors) {  	/* Select box to split.                  * Current algorithm: by population for first half' then by volume.                  */int foundIndex;  	if (numboxes * 2 <= desired_colors)  		foundIndex = find_biggest_color_pop (boxlist' numboxes);  	else  		foundIndex = find_biggest_volume (boxlist' numboxes);  	if (foundIndex == -1)  		/* no splittable boxes left! */break;  	/* Copy the color bounds to the new box. */boxlist [numboxes].c0max = boxlist [foundIndex].c0max;  	boxlist [numboxes].c1max = boxlist [foundIndex].c1max;  	boxlist [numboxes].c2max = boxlist [foundIndex].c2max;  	boxlist [numboxes].c0min = boxlist [foundIndex].c0min;  	boxlist [numboxes].c1min = boxlist [foundIndex].c1min;  	boxlist [numboxes].c2min = boxlist [foundIndex].c2min;  	/* Choose which axis to split the box on.                  * Current algorithm: longest scaled axis.                  * See notes in update_box about scaling distances.                  */int c0 = ((boxlist [foundIndex].c0max - boxlist [foundIndex].c0min) << C0_SHIFT) * R_SCALE;  	int c1 = ((boxlist [foundIndex].c1max - boxlist [foundIndex].c1min) << C1_SHIFT) * G_SCALE;  	int c2 = ((boxlist [foundIndex].c2max - boxlist [foundIndex].c2min) << C2_SHIFT) * B_SCALE;  	/* We want to break any ties in favor of green' then red' blue last.                  * This code does the right thing for R'G'B or B'G'R color orders only.                  */int cmax = c1;  	int n = 1;  	if (c0 > cmax) {  		cmax = c0;  		n = 0;  	}  	if (c2 > cmax) {  		n = 2;  	}  	/* Choose split point along selected axis' and update box bounds.                  * Current algorithm: split at halfway point.                  * (Since the box has been shrunk to minimum volume'                  * any split will produce two nonempty subboxes.)                  * Note that lb value is max for lower box' so must be < old max.                  */int lb;  	switch (n) {  	case 0:  		lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  		boxlist [foundIndex].c0max = lb;  		boxlist [numboxes].c0min = lb + 1;  		break;  	case 1:  		lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  		boxlist [foundIndex].c1max = lb;  		boxlist [numboxes].c1min = lb + 1;  		break;  	case 2:  		lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  		boxlist [foundIndex].c2max = lb;  		boxlist [numboxes].c2min = lb + 1;  		break;  	}  	/* Update stats for boxes */update_box (boxlist' foundIndex);  	update_box (boxlist' numboxes);  	numboxes++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: while (numboxes < desired_colors) {  	/* Select box to split.                  * Current algorithm: by population for first half' then by volume.                  */int foundIndex;  	if (numboxes * 2 <= desired_colors)  		foundIndex = find_biggest_color_pop (boxlist' numboxes);  	else  		foundIndex = find_biggest_volume (boxlist' numboxes);  	if (foundIndex == -1)  		/* no splittable boxes left! */break;  	/* Copy the color bounds to the new box. */boxlist [numboxes].c0max = boxlist [foundIndex].c0max;  	boxlist [numboxes].c1max = boxlist [foundIndex].c1max;  	boxlist [numboxes].c2max = boxlist [foundIndex].c2max;  	boxlist [numboxes].c0min = boxlist [foundIndex].c0min;  	boxlist [numboxes].c1min = boxlist [foundIndex].c1min;  	boxlist [numboxes].c2min = boxlist [foundIndex].c2min;  	/* Choose which axis to split the box on.                  * Current algorithm: longest scaled axis.                  * See notes in update_box about scaling distances.                  */int c0 = ((boxlist [foundIndex].c0max - boxlist [foundIndex].c0min) << C0_SHIFT) * R_SCALE;  	int c1 = ((boxlist [foundIndex].c1max - boxlist [foundIndex].c1min) << C1_SHIFT) * G_SCALE;  	int c2 = ((boxlist [foundIndex].c2max - boxlist [foundIndex].c2min) << C2_SHIFT) * B_SCALE;  	/* We want to break any ties in favor of green' then red' blue last.                  * This code does the right thing for R'G'B or B'G'R color orders only.                  */int cmax = c1;  	int n = 1;  	if (c0 > cmax) {  		cmax = c0;  		n = 0;  	}  	if (c2 > cmax) {  		n = 2;  	}  	/* Choose split point along selected axis' and update box bounds.                  * Current algorithm: split at halfway point.                  * (Since the box has been shrunk to minimum volume'                  * any split will produce two nonempty subboxes.)                  * Note that lb value is max for lower box' so must be < old max.                  */int lb;  	switch (n) {  	case 0:  		lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  		boxlist [foundIndex].c0max = lb;  		boxlist [numboxes].c0min = lb + 1;  		break;  	case 1:  		lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  		boxlist [foundIndex].c1max = lb;  		boxlist [numboxes].c1min = lb + 1;  		break;  	case 2:  		lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  		boxlist [foundIndex].c2max = lb;  		boxlist [numboxes].c2min = lb + 1;  		break;  	}  	/* Update stats for boxes */update_box (boxlist' foundIndex);  	update_box (boxlist' numboxes);  	numboxes++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: if (numboxes * 2 <= desired_colors)  	foundIndex = find_biggest_color_pop (boxlist' numboxes);  else  	foundIndex = find_biggest_volume (boxlist' numboxes);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: if (c2 > cmax) {  	n = 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: n = 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: switch (n) {  case 0:  	lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  	boxlist [foundIndex].c0max = lb;  	boxlist [numboxes].c0min = lb + 1;  	break;  case 1:  	lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  	boxlist [foundIndex].c1max = lb;  	boxlist [numboxes].c1min = lb + 1;  	break;  case 2:  	lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  	boxlist [foundIndex].c2max = lb;  	boxlist [numboxes].c2min = lb + 1;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: switch (n) {  case 0:  	lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  	boxlist [foundIndex].c0max = lb;  	boxlist [numboxes].c0min = lb + 1;  	break;  case 1:  	lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  	boxlist [foundIndex].c1max = lb;  	boxlist [numboxes].c1min = lb + 1;  	break;  case 2:  	lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  	boxlist [foundIndex].c2max = lb;  	boxlist [numboxes].c2min = lb + 1;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: switch (n) {  case 0:  	lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  	boxlist [foundIndex].c0max = lb;  	boxlist [numboxes].c0min = lb + 1;  	break;  case 1:  	lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  	boxlist [foundIndex].c1max = lb;  	boxlist [numboxes].c1min = lb + 1;  	break;  case 2:  	lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  	boxlist [foundIndex].c2max = lb;  	boxlist [numboxes].c2min = lb + 1;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: switch (n) {  case 0:  	lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  	boxlist [foundIndex].c0max = lb;  	boxlist [numboxes].c0min = lb + 1;  	break;  case 1:  	lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  	boxlist [foundIndex].c1max = lb;  	boxlist [numboxes].c1min = lb + 1;  	break;  case 2:  	lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  	boxlist [foundIndex].c2max = lb;  	boxlist [numboxes].c2min = lb + 1;  	break;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following statement contains a magic number: lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,init_error_limit,The following statement contains a magic number: m_error_limiter = new int[JpegConstants.MAXJSAMPLE * 2 + 1];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,init_error_limit,The following statement contains a magic number: for (; input < STEPSIZE * 3; input++) {  	m_error_limiter [tableOffset + input] = output;  	m_error_limiter [tableOffset - input] = -output;  	output += (input & 1) != 0 ? 1 : 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_nearby_colors,The following statement contains a magic number: for (int i = 0; i < m_cinfo.m_actual_number_of_colors; i++) {  	/* We compute the squared-c0-distance term' then add in the other two. */int x = m_cinfo.m_colormap [0] [i];  	int min_dist;  	int max_dist;  	if (x < minc0) {  		int tdist = (x - minc0) * R_SCALE;  		min_dist = tdist * tdist;  		tdist = (x - maxc0) * R_SCALE;  		max_dist = tdist * tdist;  	}  	else if (x > maxc0) {  		int tdist = (x - maxc0) * R_SCALE;  		min_dist = tdist * tdist;  		tdist = (x - minc0) * R_SCALE;  		max_dist = tdist * tdist;  	}  	else {  		/* within cell range so no contribution to min_dist */min_dist = 0;  		if (x <= centerc0) {  			int tdist = (x - maxc0) * R_SCALE;  			max_dist = tdist * tdist;  		}  		else {  			int tdist = (x - minc0) * R_SCALE;  			max_dist = tdist * tdist;  		}  	}  	x = m_cinfo.m_colormap [1] [i];  	if (x < minc1) {  		int tdist = (x - minc1) * G_SCALE;  		min_dist += tdist * tdist;  		tdist = (x - maxc1) * G_SCALE;  		max_dist += tdist * tdist;  	}  	else if (x > maxc1) {  		int tdist = (x - maxc1) * G_SCALE;  		min_dist += tdist * tdist;  		tdist = (x - minc1) * G_SCALE;  		max_dist += tdist * tdist;  	}  	else {  		/* within cell range so no contribution to min_dist */if (x <= centerc1) {  			int tdist = (x - maxc1) * G_SCALE;  			max_dist += tdist * tdist;  		}  		else {  			int tdist = (x - minc1) * G_SCALE;  			max_dist += tdist * tdist;  		}  	}  	x = m_cinfo.m_colormap [2] [i];  	if (x < minc2) {  		int tdist = (x - minc2) * B_SCALE;  		min_dist += tdist * tdist;  		tdist = (x - maxc2) * B_SCALE;  		max_dist += tdist * tdist;  	}  	else if (x > maxc2) {  		int tdist = (x - maxc2) * B_SCALE;  		min_dist += tdist * tdist;  		tdist = (x - minc2) * B_SCALE;  		max_dist += tdist * tdist;  	}  	else {  		/* within cell range so no contribution to min_dist */if (x <= centerc2) {  			int tdist = (x - maxc2) * B_SCALE;  			max_dist += tdist * tdist;  		}  		else {  			int tdist = (x - minc2) * B_SCALE;  			max_dist += tdist * tdist;  		}  	}  	mindist [i] = min_dist;  	/* save away the results */if (max_dist < minmaxdist)  		minmaxdist = max_dist;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_nearby_colors,The following statement contains a magic number: x = m_cinfo.m_colormap [2] [i];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int i = 0; i < numcolors; i++) {  	int icolor = colorlist [i];  	/* Compute (square of) distance from minc0/c1/c2 to this color */int inc0 = (minc0 - m_cinfo.m_colormap [0] [icolor]) * R_SCALE;  	int dist0 = inc0 * inc0;  	int inc1 = (minc1 - m_cinfo.m_colormap [1] [icolor]) * G_SCALE;  	dist0 += inc1 * inc1;  	int inc2 = (minc2 - m_cinfo.m_colormap [2] [icolor]) * B_SCALE;  	dist0 += inc2 * inc2;  	/* Form the initial difference increments */inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  	inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  	inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  	/* Now loop over all cells in box' updating distance per Thomas method */bestIndex = 0;  	int colorIndex = 0;  	int xx0 = inc0;  	for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  		int dist1 = dist0;  		int xx1 = inc1;  		for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  			int dist2 = dist1;  			int xx2 = inc2;  			for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  				if (dist2 < bestdist [bestIndex]) {  					bestdist [bestIndex] = dist2;  					bestcolor [colorIndex] = (byte)icolor;  				}  				dist2 += xx2;  				xx2 += 2 * STEP_C2 * STEP_C2;  				bestIndex++;  				colorIndex++;  			}  			dist1 += xx1;  			xx1 += 2 * STEP_C1 * STEP_C1;  		}  		dist0 += xx0;  		xx0 += 2 * STEP_C0 * STEP_C0;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  	int dist1 = dist0;  	int xx1 = inc1;  	for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  		int dist2 = dist1;  		int xx2 = inc2;  		for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  			if (dist2 < bestdist [bestIndex]) {  				bestdist [bestIndex] = dist2;  				bestcolor [colorIndex] = (byte)icolor;  			}  			dist2 += xx2;  			xx2 += 2 * STEP_C2 * STEP_C2;  			bestIndex++;  			colorIndex++;  		}  		dist1 += xx1;  		xx1 += 2 * STEP_C1 * STEP_C1;  	}  	dist0 += xx0;  	xx0 += 2 * STEP_C0 * STEP_C0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  	int dist1 = dist0;  	int xx1 = inc1;  	for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  		int dist2 = dist1;  		int xx2 = inc2;  		for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  			if (dist2 < bestdist [bestIndex]) {  				bestdist [bestIndex] = dist2;  				bestcolor [colorIndex] = (byte)icolor;  			}  			dist2 += xx2;  			xx2 += 2 * STEP_C2 * STEP_C2;  			bestIndex++;  			colorIndex++;  		}  		dist1 += xx1;  		xx1 += 2 * STEP_C1 * STEP_C1;  	}  	dist0 += xx0;  	xx0 += 2 * STEP_C0 * STEP_C0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {  	int dist1 = dist0;  	int xx1 = inc1;  	for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  		int dist2 = dist1;  		int xx2 = inc2;  		for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  			if (dist2 < bestdist [bestIndex]) {  				bestdist [bestIndex] = dist2;  				bestcolor [colorIndex] = (byte)icolor;  			}  			dist2 += xx2;  			xx2 += 2 * STEP_C2 * STEP_C2;  			bestIndex++;  			colorIndex++;  		}  		dist1 += xx1;  		xx1 += 2 * STEP_C1 * STEP_C1;  	}  	dist0 += xx0;  	xx0 += 2 * STEP_C0 * STEP_C0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  	int dist2 = dist1;  	int xx2 = inc2;  	for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  		if (dist2 < bestdist [bestIndex]) {  			bestdist [bestIndex] = dist2;  			bestcolor [colorIndex] = (byte)icolor;  		}  		dist2 += xx2;  		xx2 += 2 * STEP_C2 * STEP_C2;  		bestIndex++;  		colorIndex++;  	}  	dist1 += xx1;  	xx1 += 2 * STEP_C1 * STEP_C1;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {  	int dist2 = dist1;  	int xx2 = inc2;  	for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  		if (dist2 < bestdist [bestIndex]) {  			bestdist [bestIndex] = dist2;  			bestcolor [colorIndex] = (byte)icolor;  		}  		dist2 += xx2;  		xx2 += 2 * STEP_C2 * STEP_C2;  		bestIndex++;  		colorIndex++;  	}  	dist1 += xx1;  	xx1 += 2 * STEP_C1 * STEP_C1;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: for (int ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {  	if (dist2 < bestdist [bestIndex]) {  		bestdist [bestIndex] = dist2;  		bestcolor [colorIndex] = (byte)icolor;  	}  	dist2 += xx2;  	xx2 += 2 * STEP_C2 * STEP_C2;  	bestIndex++;  	colorIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: xx2 += 2 * STEP_C2 * STEP_C2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: xx1 += 2 * STEP_C1 * STEP_C1;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,find_best_colors,The following statement contains a magic number: xx0 += 2 * STEP_C0 * STEP_C0;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,my_merged_upsampler,The following statement contains a magic number: if (cinfo.m_max_v_samp_factor == 2) {  	m_use_2v_upsample = true;  	/* Allocate a spare row buffer */m_spare_row = new byte[m_out_row_width];  }  else {  	m_use_2v_upsample = false;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,merged_2v_upsample,The following statement contains a magic number: if (m_spare_full) {  	/* If we have a spare row saved from a previous cycle' just return it. */byte[][] temp = new byte[1][];  	temp [0] = m_spare_row;  	JpegUtils.jcopy_sample_rows (temp' 0' output_buf' out_row_ctr' 1' m_out_row_width);  	num_rows = 1;  	m_spare_full = false;  }  else {  	/* Figure number of rows to return to caller. */num_rows = 2;  	/* Not more than the distance to the end of the image. */if (num_rows > m_rows_to_go)  		num_rows = m_rows_to_go;  	/* And not more than what the client can accept: */out_rows_avail -= out_row_ctr;  	if (num_rows > out_rows_avail)  		num_rows = out_rows_avail;  	/* Create output pointer array for upsampler. */byte[][] work_ptrs = new byte[2][];  	work_ptrs [0] = output_buf [out_row_ctr];  	if (num_rows > 1) {  		work_ptrs [1] = output_buf [out_row_ctr + 1];  	}  	else {  		work_ptrs [1] = m_spare_row;  		m_spare_full = true;  	}  	/* Now do the upsampling. */h2v2_merged_upsample (input_buf' in_row_group_ctr' work_ptrs);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,merged_2v_upsample,The following statement contains a magic number: if (m_spare_full) {  	/* If we have a spare row saved from a previous cycle' just return it. */byte[][] temp = new byte[1][];  	temp [0] = m_spare_row;  	JpegUtils.jcopy_sample_rows (temp' 0' output_buf' out_row_ctr' 1' m_out_row_width);  	num_rows = 1;  	m_spare_full = false;  }  else {  	/* Figure number of rows to return to caller. */num_rows = 2;  	/* Not more than the distance to the end of the image. */if (num_rows > m_rows_to_go)  		num_rows = m_rows_to_go;  	/* And not more than what the client can accept: */out_rows_avail -= out_row_ctr;  	if (num_rows > out_rows_avail)  		num_rows = out_rows_avail;  	/* Create output pointer array for upsampler. */byte[][] work_ptrs = new byte[2][];  	work_ptrs [0] = output_buf [out_row_ctr];  	if (num_rows > 1) {  		work_ptrs [1] = output_buf [out_row_ctr + 1];  	}  	else {  		work_ptrs [1] = m_spare_row;  		m_spare_full = true;  	}  	/* Now do the upsampling. */h2v2_merged_upsample (input_buf' in_row_group_ctr' work_ptrs);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,merged_2v_upsample,The following statement contains a magic number: num_rows = 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,h2v1_merged_upsample,The following statement contains a magic number: for (int col = m_cinfo.m_output_width >> 1; col > 0; col--) {  	/* Do the chroma part of the calculation */int cb = input_buf [1] [in_row_group_ctr] [inputIndex1];  	inputIndex1++;  	int cr = input_buf [2] [in_row_group_ctr] [inputIndex2];  	inputIndex2++;  	int cred = m_Cr_r_tab [cr];  	int cgreen = JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS);  	int cblue = m_Cb_b_tab [cb];  	/* Fetch 2 Y values and emit 2 pixels */int y = input_buf [0] [in_row_group_ctr] [inputIndex0];  	inputIndex0++;  	output_buf [outRow] [outputIndex + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	outputIndex += JpegConstants.RGB_PIXELSIZE;  	y = input_buf [0] [in_row_group_ctr] [inputIndex0];  	inputIndex0++;  	output_buf [outRow] [outputIndex + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	outputIndex += JpegConstants.RGB_PIXELSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,h2v1_merged_upsample,The following statement contains a magic number: if ((m_cinfo.m_output_width & 1) != 0) {  	int cb = input_buf [1] [in_row_group_ctr] [inputIndex1];  	int cr = input_buf [2] [in_row_group_ctr] [inputIndex2];  	int cred = m_Cr_r_tab [cr];  	int cgreen = JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS);  	int cblue = m_Cb_b_tab [cb];  	int y = input_buf [0] [in_row_group_ctr] [inputIndex0];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [outRow] [outputIndex + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,h2v2_merged_upsample,The following statement contains a magic number: for (int col = m_cinfo.m_output_width >> 1; col > 0; col--) {  	/* Do the chroma part of the calculation */int cb = input_buf [1] [in_row_group_ctr] [inputIndex1];  	inputIndex1++;  	int cr = input_buf [2] [in_row_group_ctr] [inputIndex2];  	inputIndex2++;  	int cred = m_Cr_r_tab [cr];  	int cgreen = JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS);  	int cblue = m_Cb_b_tab [cb];  	/* Fetch 4 Y values and emit 4 pixels */int y = input_buf [0] [inputRow00] [inputIndex00];  	inputIndex00++;  	output_buf [0] [outIndex0 + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [0] [outIndex0 + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [0] [outIndex0 + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	outIndex0 += JpegConstants.RGB_PIXELSIZE;  	y = input_buf [0] [inputRow00] [inputIndex00];  	inputIndex00++;  	output_buf [0] [outIndex0 + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [0] [outIndex0 + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [0] [outIndex0 + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	outIndex0 += JpegConstants.RGB_PIXELSIZE;  	y = input_buf [0] [inputRow01] [inputIndex01];  	inputIndex01++;  	output_buf [1] [outIndex1 + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [1] [outIndex1 + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [1] [outIndex1 + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	outIndex1 += JpegConstants.RGB_PIXELSIZE;  	y = input_buf [0] [inputRow01] [inputIndex01];  	inputIndex01++;  	output_buf [1] [outIndex1 + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [1] [outIndex1 + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [1] [outIndex1 + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	outIndex1 += JpegConstants.RGB_PIXELSIZE;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,h2v2_merged_upsample,The following statement contains a magic number: if ((m_cinfo.m_output_width & 1) != 0) {  	int cb = input_buf [1] [in_row_group_ctr] [inputIndex1];  	int cr = input_buf [2] [in_row_group_ctr] [inputIndex2];  	int cred = m_Cr_r_tab [cr];  	int cgreen = JpegUtils.RIGHT_SHIFT (m_Cb_g_tab [cb] + m_Cr_g_tab [cr]' SCALEBITS);  	int cblue = m_Cb_b_tab [cb];  	int y = input_buf [0] [inputRow00] [inputIndex00];  	output_buf [0] [outIndex0 + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [0] [outIndex0 + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [0] [outIndex0 + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  	y = input_buf [0] [inputRow01] [inputIndex01];  	output_buf [1] [outIndex1 + JpegConstants.RGB_RED] = limit [limitOffset + y + cred];  	output_buf [1] [outIndex1 + JpegConstants.RGB_GREEN] = limit [limitOffset + y + cgreen];  	output_buf [1] [outIndex1 + JpegConstants.RGB_BLUE] = limit [limitOffset + y + cblue];  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: for (int i = 0' x = -JpegConstants.CENTERJSAMPLE; i <= JpegConstants.MAXJSAMPLE; i++' x++) {  	/* i is the actual input pixel value' in the range 0..MAXJSAMPLE *//* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE *//* Cr=>R value is nearest int to 1.40200 * x */m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  	/* Cb=>B value is nearest int to 1.77200 * x */m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  	/* Cr=>G value is scaled-up -0.71414 * x */m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  	/* Cb=>G value is scaled-up -0.34414 * x *//* We also add in ONE_HALF so that need not do it in inner loop */m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cr_r_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.40200) * x + ONE_HALF' SCALEBITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cb_b_tab [i] = JpegUtils.RIGHT_SHIFT (FIX (1.77200) * x + ONE_HALF' SCALEBITS);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cr_g_tab [i] = (-FIX (0.71414)) * x;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,build_ycc_rgb_table,The following statement contains a magic number: m_Cb_g_tab [i] = (-FIX (0.34414)) * x + ONE_HALF;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_merged_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_merged_upsampler.cs,FIX,The following statement contains a magic number: return ((int)((x) * (1L << SCALEBITS) + 0.5));  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_source_mgr.cs,fill_input_buffer,The following statement contains a magic number: if (nbytes <= 0) {  	if (m_start_of_file)  		/* Treat empty input file as fatal error */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_INPUT_EMPTY);  	m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_JPEG_EOF);  	/* Insert a fake EOI marker */m_buffer [0] = (byte)0xFF;  	m_buffer [1] = (byte)JPEG_MARKER.EOI;  	nbytes = 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_source_mgr.cs,fill_input_buffer,The following statement contains a magic number: nbytes = 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Comp_info [ci];  	/* Compute size of an "input group" after IDCT scaling.  This many samples                 * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.                 */int h_in_group = (componentInfo.H_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int v_in_group = (componentInfo.V_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int h_out_group = cinfo.m_max_h_samp_factor;  	int v_out_group = cinfo.m_max_v_samp_factor;  	/* save for use later */m_rowgroup_height [ci] = v_in_group;  	bool need_buffer = true;  	if (!componentInfo.component_needed) {  		/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  		need_buffer = false;  	}  	else if (h_in_group == h_out_group && v_in_group == v_out_group) {  		/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  		need_buffer = false;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  		/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  		else  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  		/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  			m_need_context_rows = true;  		}  		else {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  		}  	}  	else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  		/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  		m_h_expand [ci] = (byte)(h_out_group / h_in_group);  		m_v_expand [ci] = (byte)(v_out_group / v_in_group);  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  	if (need_buffer) {  		ComponentBuffer cb = new ComponentBuffer ();  		cb.SetBuffer (jpeg_common_struct.AllocJpegSamples (JpegUtils.jround_up (cinfo.m_output_width' cinfo.m_max_h_samp_factor)' cinfo.m_max_v_samp_factor)' null' 0);  		m_color_buf [ci] = cb;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Comp_info [ci];  	/* Compute size of an "input group" after IDCT scaling.  This many samples                 * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.                 */int h_in_group = (componentInfo.H_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int v_in_group = (componentInfo.V_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int h_out_group = cinfo.m_max_h_samp_factor;  	int v_out_group = cinfo.m_max_v_samp_factor;  	/* save for use later */m_rowgroup_height [ci] = v_in_group;  	bool need_buffer = true;  	if (!componentInfo.component_needed) {  		/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  		need_buffer = false;  	}  	else if (h_in_group == h_out_group && v_in_group == v_out_group) {  		/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  		need_buffer = false;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  		/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  		else  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  		/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  			m_need_context_rows = true;  		}  		else {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  		}  	}  	else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  		/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  		m_h_expand [ci] = (byte)(h_out_group / h_in_group);  		m_v_expand [ci] = (byte)(v_out_group / v_in_group);  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  	if (need_buffer) {  		ComponentBuffer cb = new ComponentBuffer ();  		cb.SetBuffer (jpeg_common_struct.AllocJpegSamples (JpegUtils.jround_up (cinfo.m_output_width' cinfo.m_max_h_samp_factor)' cinfo.m_max_v_samp_factor)' null' 0);  		m_color_buf [ci] = cb;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Comp_info [ci];  	/* Compute size of an "input group" after IDCT scaling.  This many samples                 * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.                 */int h_in_group = (componentInfo.H_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int v_in_group = (componentInfo.V_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int h_out_group = cinfo.m_max_h_samp_factor;  	int v_out_group = cinfo.m_max_v_samp_factor;  	/* save for use later */m_rowgroup_height [ci] = v_in_group;  	bool need_buffer = true;  	if (!componentInfo.component_needed) {  		/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  		need_buffer = false;  	}  	else if (h_in_group == h_out_group && v_in_group == v_out_group) {  		/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  		need_buffer = false;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  		/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  		else  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  		/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  			m_need_context_rows = true;  		}  		else {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  		}  	}  	else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  		/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  		m_h_expand [ci] = (byte)(h_out_group / h_in_group);  		m_v_expand [ci] = (byte)(v_out_group / v_in_group);  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  	if (need_buffer) {  		ComponentBuffer cb = new ComponentBuffer ();  		cb.SetBuffer (jpeg_common_struct.AllocJpegSamples (JpegUtils.jround_up (cinfo.m_output_width' cinfo.m_max_h_samp_factor)' cinfo.m_max_v_samp_factor)' null' 0);  		m_color_buf [ci] = cb;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Comp_info [ci];  	/* Compute size of an "input group" after IDCT scaling.  This many samples                 * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.                 */int h_in_group = (componentInfo.H_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int v_in_group = (componentInfo.V_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int h_out_group = cinfo.m_max_h_samp_factor;  	int v_out_group = cinfo.m_max_v_samp_factor;  	/* save for use later */m_rowgroup_height [ci] = v_in_group;  	bool need_buffer = true;  	if (!componentInfo.component_needed) {  		/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  		need_buffer = false;  	}  	else if (h_in_group == h_out_group && v_in_group == v_out_group) {  		/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  		need_buffer = false;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  		/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  		else  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  		/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  			m_need_context_rows = true;  		}  		else {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  		}  	}  	else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  		/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  		m_h_expand [ci] = (byte)(h_out_group / h_in_group);  		m_v_expand [ci] = (byte)(v_out_group / v_in_group);  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  	if (need_buffer) {  		ComponentBuffer cb = new ComponentBuffer ();  		cb.SetBuffer (jpeg_common_struct.AllocJpegSamples (JpegUtils.jround_up (cinfo.m_output_width' cinfo.m_max_h_samp_factor)' cinfo.m_max_v_samp_factor)' null' 0);  		m_color_buf [ci] = cb;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: for (int ci = 0; ci < cinfo.m_num_components; ci++) {  	jpeg_component_info componentInfo = cinfo.Comp_info [ci];  	/* Compute size of an "input group" after IDCT scaling.  This many samples                 * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.                 */int h_in_group = (componentInfo.H_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int v_in_group = (componentInfo.V_samp_factor * componentInfo.DCT_scaled_size) / cinfo.m_min_DCT_scaled_size;  	int h_out_group = cinfo.m_max_h_samp_factor;  	int v_out_group = cinfo.m_max_v_samp_factor;  	/* save for use later */m_rowgroup_height [ci] = v_in_group;  	bool need_buffer = true;  	if (!componentInfo.component_needed) {  		/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  		need_buffer = false;  	}  	else if (h_in_group == h_out_group && v_in_group == v_out_group) {  		/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  		need_buffer = false;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  		/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  		else  			m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  	}  	else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  		/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  			m_need_context_rows = true;  		}  		else {  			m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  		}  	}  	else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  		/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  		m_h_expand [ci] = (byte)(h_out_group / h_in_group);  		m_v_expand [ci] = (byte)(v_out_group / v_in_group);  	}  	else  		cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  	if (need_buffer) {  		ComponentBuffer cb = new ComponentBuffer ();  		cb.SetBuffer (jpeg_common_struct.AllocJpegSamples (JpegUtils.jround_up (cinfo.m_output_width' cinfo.m_max_h_samp_factor)' cinfo.m_max_v_samp_factor)' null' 0);  		m_color_buf [ci] = cb;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (!componentInfo.component_needed) {  	/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  	need_buffer = false;  }  else if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (!componentInfo.component_needed) {  	/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  	need_buffer = false;  }  else if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (!componentInfo.component_needed) {  	/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  	need_buffer = false;  }  else if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (!componentInfo.component_needed) {  	/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  	need_buffer = false;  }  else if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (!componentInfo.component_needed) {  	/* Don't bother to upsample an uninteresting component. */m_upsampleMethods [ci] = ComponentUpsampler.noop_upsampler;  	need_buffer = false;  }  else if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group == h_out_group && v_in_group == v_out_group) {  	/* Fullsize components can be processed without any work. */m_upsampleMethods [ci] = ComponentUpsampler.fullsize_upsampler;  	need_buffer = false;  }  else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {  	/* Special cases for 2h1v upsampling */if (do_fancy && componentInfo.downsampled_width > 2)  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  	else  		m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  }  else if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (do_fancy && componentInfo.downsampled_width > 2)  	m_upsampleMethods [ci] = ComponentUpsampler.h2v1_fancy_upsampler;  else  	m_upsampleMethods [ci] = ComponentUpsampler.h2v1_upsampler;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group) {  	/* Special cases for 2h2v upsampling */if (do_fancy && componentInfo.downsampled_width > 2) {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  		m_need_context_rows = true;  	}  	else {  		m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  	}  }  else if ((h_out_group % h_in_group) == 0 && (v_out_group % v_in_group) == 0) {  	/* Generic integral-factors upsampling method */m_upsampleMethods [ci] = ComponentUpsampler.int_upsampler;  	m_h_expand [ci] = (byte)(h_out_group / h_in_group);  	m_v_expand [ci] = (byte)(v_out_group / v_in_group);  }  else  	cinfo.ERREXIT (J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,my_upsampler,The following statement contains a magic number: if (do_fancy && componentInfo.downsampled_width > 2) {  	m_upsampleMethods [ci] = ComponentUpsampler.h2v2_fancy_upsampler;  	m_need_context_rows = true;  }  else {  	m_upsampleMethods [ci] = ComponentUpsampler.h2v2_upsampler;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int inrow = 0; inrow < m_cinfo.m_max_v_samp_factor; inrow++) {  	int row = m_upsampleRowOffset + inrow;  	int inIndex = 0;  	int outIndex = 0;  	/* Special case for first column */int invalue = input_data [row] [inIndex];  	inIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  		inIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  		outIndex++;  		output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  		outIndex++;  	}  	/* Special case for last column */invalue = input_data [row] [inIndex];  	output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)invalue;  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex] + 2) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  	inIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  	inIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  	inIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  	inIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  	inIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel */invalue = (int)input_data [row] [inIndex] * 3;  	inIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  	outIndex++;  	output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: invalue = (int)input_data [row] [inIndex] * 3;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex - 2] + 1) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue + (int)input_data [row] [inIndex] + 2) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v1_fancy_upsample,The following statement contains a magic number: output_data [inrow] [outIndex] = (byte)((invalue * 3 + (int)input_data [row] [inIndex - 1] + 1) >> 2);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	for (int v = 0; v < 2; v++) {  		// nearest input row index  		int inIndex0 = 0;  		//next nearest input row index  		int inIndex1 = 0;  		int inRow1 = -1;  		if (v == 0) {  			/* next nearest is row above */inRow1 = inrow - 1;  		}  		else {  			/* next nearest is row below */inRow1 = inrow + 1;  		}  		int row = outrow;  		int outIndex = 0;  		outrow++;  		/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		int lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  		for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  			/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  			inIndex0++;  			inIndex1++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  			outIndex++;  			output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  			outIndex++;  			lastcolsum = thiscolsum;  			thiscolsum = nextcolsum;  		}  		/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  		outIndex++;  	}  	inrow++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int v = 0; v < 2; v++) {  	// nearest input row index  	int inIndex0 = 0;  	//next nearest input row index  	int inIndex1 = 0;  	int inRow1 = -1;  	if (v == 0) {  		/* next nearest is row above */inRow1 = inrow - 1;  	}  	else {  		/* next nearest is row below */inRow1 = inrow + 1;  	}  	int row = outrow;  	int outIndex = 0;  	outrow++;  	/* Special case for first column */int thiscolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	int nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	int lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  	for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  		/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  		inIndex0++;  		inIndex1++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  		outIndex++;  		output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  		outIndex++;  		lastcolsum = thiscolsum;  		thiscolsum = nextcolsum;  	}  	/* Special case for last column */output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  	outIndex++;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: for (int colctr = downsampled_width - 2; colctr > 0; colctr--) {  	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each *//* dimension' thus 9/16' 3/16' 3/16' 1/16 overall */nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  	inIndex0++;  	inIndex1++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  	outIndex++;  	output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  	outIndex++;  	lastcolsum = thiscolsum;  	thiscolsum = nextcolsum;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: nextcolsum = (int)input_data [inrow] [inIndex0] * 3 + (int)input_data [inRow1] [inIndex1];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + nextcolsum + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 3 + lastcolsum + 8) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_fancy_upsample,The following statement contains a magic number: output_data [row] [outIndex] = (byte)((thiscolsum * 4 + 7) >> 4);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_upsample,The following statement contains a magic number: while (outrow < m_cinfo.m_max_v_samp_factor) {  	int row = m_upsampleRowOffset + inrow;  	int outIndex = 0;  	for (int col = 0; outIndex < m_cinfo.m_output_width; col++) {  		byte invalue = input_data [row] [col];  		/* don't need GETJSAMPLE() here */output_data [outrow] [outIndex] = invalue;  		outIndex++;  		output_data [outrow] [outIndex] = invalue;  		outIndex++;  	}  	JpegUtils.jcopy_sample_rows (output_data' outrow' output_data' outrow + 1' 1' m_cinfo.m_output_width);  	inrow++;  	outrow += 2;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,my_upsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_upsampler.cs,h2v2_upsample,The following statement contains a magic number: outrow += 2;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,start_pass,The following statement contains a magic number: if (m_cinfo.m_Al > 13) {  	/* need not check for < 0 */bad = true;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state.                  * We can avoid loading/saving bitread state if in an EOB run.                  */int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* There is always only one block per MCU */if (EOBRUN > 0) {  		/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  	}  	else {  		int get_buffer;  		int bits_left;  		bitread_working_state br_state = new bitread_working_state ();  		BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  		for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  			}  			else {  				if (r == 15) {  					/* ZRL */k += 15;  					/* skip 15 zeroes in band */}  				else {  					/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  					if (r != 0) {  						/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  							return false;  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					EOBRUN--;  					/* this band is processed at this moment */break;  					/* force end-of-band */}  			}  		}  		BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	}  	/* Completed MCU' so update state */m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state.                  * We can avoid loading/saving bitread state if in an EOB run.                  */int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* There is always only one block per MCU */if (EOBRUN > 0) {  		/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  	}  	else {  		int get_buffer;  		int bits_left;  		bitread_working_state br_state = new bitread_working_state ();  		BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  		for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  			}  			else {  				if (r == 15) {  					/* ZRL */k += 15;  					/* skip 15 zeroes in band */}  				else {  					/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  					if (r != 0) {  						/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  							return false;  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					EOBRUN--;  					/* this band is processed at this moment */break;  					/* force end-of-band */}  			}  		}  		BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	}  	/* Completed MCU' so update state */m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state.                  * We can avoid loading/saving bitread state if in an EOB run.                  */int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* There is always only one block per MCU */if (EOBRUN > 0) {  		/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  	}  	else {  		int get_buffer;  		int bits_left;  		bitread_working_state br_state = new bitread_working_state ();  		BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  		for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  			}  			else {  				if (r == 15) {  					/* ZRL */k += 15;  					/* skip 15 zeroes in band */}  				else {  					/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  					if (r != 0) {  						/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  							return false;  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					EOBRUN--;  					/* this band is processed at this moment */break;  					/* force end-of-band */}  			}  		}  		BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	}  	/* Completed MCU' so update state */m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state.                  * We can avoid loading/saving bitread state if in an EOB run.                  */int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* There is always only one block per MCU */if (EOBRUN > 0) {  		/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  	}  	else {  		int get_buffer;  		int bits_left;  		bitread_working_state br_state = new bitread_working_state ();  		BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  		for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  				return false;  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				k += r;  				if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (s' get_buffer' ref bits_left);  				s = HUFF_EXTEND (r' s);  				/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  			}  			else {  				if (r == 15) {  					/* ZRL */k += 15;  					/* skip 15 zeroes in band */}  				else {  					/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  					if (r != 0) {  						/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  							return false;  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					EOBRUN--;  					/* this band is processed at this moment */break;  					/* force end-of-band */}  			}  		}  		BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	}  	/* Completed MCU' so update state */m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (EOBRUN > 0) {  	/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  }  else {  	int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  		}  		else {  			if (r == 15) {  				/* ZRL */k += 15;  				/* skip 15 zeroes in band */}  			else {  				/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  				if (r != 0) {  					/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				EOBRUN--;  				/* this band is processed at this moment */break;  				/* force end-of-band */}  		}  	}  	BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (EOBRUN > 0) {  	/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  }  else {  	int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  		}  		else {  			if (r == 15) {  				/* ZRL */k += 15;  				/* skip 15 zeroes in band */}  			else {  				/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  				if (r != 0) {  					/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				EOBRUN--;  				/* this band is processed at this moment */break;  				/* force end-of-band */}  		}  	}  	BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (EOBRUN > 0) {  	/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  }  else {  	int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  		}  		else {  			if (r == 15) {  				/* ZRL */k += 15;  				/* skip 15 zeroes in band */}  			else {  				/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  				if (r != 0) {  					/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				EOBRUN--;  				/* this band is processed at this moment */break;  				/* force end-of-band */}  		}  	}  	BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (EOBRUN > 0) {  	/* if it's a band of zeroes... *//* ...process it now (we do nothing) */EOBRUN--;  }  else {  	int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  			return false;  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			k += r;  			if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (s' get_buffer' ref bits_left);  			s = HUFF_EXTEND (r' s);  			/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  		}  		else {  			if (r == 15) {  				/* ZRL */k += 15;  				/* skip 15 zeroes in band */}  			else {  				/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  				if (r != 0) {  					/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  						return false;  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				EOBRUN--;  				/* this band is processed at this moment */break;  				/* force end-of-band */}  		}  	}  	BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  	}  	else {  		if (r == 15) {  			/* ZRL */k += 15;  			/* skip 15 zeroes in band */}  		else {  			/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  			if (r != 0) {  				/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			EOBRUN--;  			/* this band is processed at this moment */break;  			/* force end-of-band */}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  	}  	else {  		if (r == 15) {  			/* ZRL */k += 15;  			/* skip 15 zeroes in band */}  		else {  			/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  			if (r != 0) {  				/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			EOBRUN--;  			/* this band is processed at this moment */break;  			/* force end-of-band */}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  	}  	else {  		if (r == 15) {  			/* ZRL */k += 15;  			/* skip 15 zeroes in band */}  		else {  			/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  			if (r != 0) {  				/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			EOBRUN--;  			/* this band is processed at this moment */break;  			/* force end-of-band */}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left))  		return false;  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		k += r;  		if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (s' get_buffer' ref bits_left);  		s = HUFF_EXTEND (r' s);  		/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  	}  	else {  		if (r == 15) {  			/* ZRL */k += 15;  			/* skip 15 zeroes in band */}  		else {  			/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  			if (r != 0) {  				/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  					return false;  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			EOBRUN--;  			/* this band is processed at this moment */break;  			/* force end-of-band */}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: s &= 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (s != 0) {  	k += r;  	if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  		return false;  	r = GET_BITS (s' get_buffer' ref bits_left);  	s = HUFF_EXTEND (r' s);  	/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  }  else {  	if (r == 15) {  		/* ZRL */k += 15;  		/* skip 15 zeroes in band */}  	else {  		/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  		if (r != 0) {  			/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (r' get_buffer' ref bits_left);  			EOBRUN += r;  		}  		EOBRUN--;  		/* this band is processed at this moment */break;  		/* force end-of-band */}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (s != 0) {  	k += r;  	if (!CHECK_BIT_BUFFER (ref br_state' s' ref get_buffer' ref bits_left))  		return false;  	r = GET_BITS (s' get_buffer' ref bits_left);  	s = HUFF_EXTEND (r' s);  	/* Scale and output coefficient in natural (dezigzagged) order */MCU_data [0] [JpegUtils.jpeg_natural_order [k]] = (short)(s << m_cinfo.m_Al);  }  else {  	if (r == 15) {  		/* ZRL */k += 15;  		/* skip 15 zeroes in band */}  	else {  		/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  		if (r != 0) {  			/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  				return false;  			r = GET_BITS (r' get_buffer' ref bits_left);  			EOBRUN += r;  		}  		EOBRUN--;  		/* this band is processed at this moment */break;  		/* force end-of-band */}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (r == 15) {  	/* ZRL */k += 15;  	/* skip 15 zeroes in band */}  else {  	/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  	if (r != 0) {  		/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (r' get_buffer' ref bits_left);  		EOBRUN += r;  	}  	EOBRUN--;  	/* this band is processed at this moment */break;  	/* force end-of-band */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: if (r == 15) {  	/* ZRL */k += 15;  	/* skip 15 zeroes in band */}  else {  	/* EOBr' run length is 2^r + appended bits */EOBRUN = 1 << r;  	if (r != 0) {  		/* EOBr' r > 0 */if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left))  			return false;  		r = GET_BITS (r' get_buffer' ref bits_left);  		EOBRUN += r;  	}  	EOBRUN--;  	/* this band is processed at this moment */break;  	/* force end-of-band */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_first,The following statement contains a magic number: k += 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* If we are forced to suspend' we must undo the assignments to any newly                  * nonzero coefficients in the block' because otherwise we'd get confused                  * next time about which coefficients were already nonzero.                  * But we need not undo addition of bits to already-nonzero coefficients;                  * instead' we can test the current bit to see if we already did it.                  */int num_newnz = 0;  	int[] newnz_pos = new int[JpegConstants.DCTSIZE2];  	/* initialize coefficient loop counter to start of band */int k = m_cinfo.m_Ss;  	if (EOBRUN == 0) {  		for (; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				if (s != 1) {  					/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  				}  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					/* newly nonzero coef is positive */s = p1;  				}  				else {  					/* newly nonzero coef is negative */s = m1;  				}  			}  			else {  				if (r != 15) {  					EOBRUN = 1 << r;  					/* EOBr' run length is 2^r + appended bits */if (r != 0) {  						if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  							undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  							return false;  						}  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					break;  					/* rest of block is handled by EOB logic */}  				/* note s = 0 for processing ZRL */}  			/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  				int blockIndex = JpegUtils.jpeg_natural_order [k];  				short thiscoef = MCU_data [0] [blockIndex];  				if (thiscoef != 0) {  					if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  						undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  						return false;  					}  					if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  						if ((thiscoef & p1) == 0) {  							/* do nothing if already set it */if (thiscoef >= 0)  								MCU_data [0] [blockIndex] += (short)p1;  							else  								MCU_data [0] [blockIndex] += (short)m1;  						}  					}  				}  				else {  					if (--r < 0)  						break;  					/* reached target zero coefficient */}  				k++;  			}  			while (k <= m_cinfo.m_Se);  			if (s != 0) {  				int pos = JpegUtils.jpeg_natural_order [k];  				/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  				/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  			}  		}  	}  	if (EOBRUN > 0) {  		/* Scan any remaining coefficient positions after the end-of-band                      * (the last newly nonzero coefficient' if any).  Append a correction                      * bit to each already-nonzero coefficient.  A correction bit is 1                      * if the absolute value of the coefficient must be increased.                      */for (; k <= m_cinfo.m_Se; k++) {  			int blockIndex = JpegUtils.jpeg_natural_order [k];  			short thiscoef = MCU_data [0] [blockIndex];  			if (thiscoef != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					//undo_decode_mcu_AC_refine(MCU_data[0]' newnz_pos' num_newnz);  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					if ((thiscoef & p1) == 0) {  						/* do nothing if already changed it */if (thiscoef >= 0)  							MCU_data [0] [blockIndex] += (short)p1;  						else  							MCU_data [0] [blockIndex] += (short)m1;  					}  				}  			}  		}  		/* Count one block completed in EOB run */EOBRUN--;  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* If we are forced to suspend' we must undo the assignments to any newly                  * nonzero coefficients in the block' because otherwise we'd get confused                  * next time about which coefficients were already nonzero.                  * But we need not undo addition of bits to already-nonzero coefficients;                  * instead' we can test the current bit to see if we already did it.                  */int num_newnz = 0;  	int[] newnz_pos = new int[JpegConstants.DCTSIZE2];  	/* initialize coefficient loop counter to start of band */int k = m_cinfo.m_Ss;  	if (EOBRUN == 0) {  		for (; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				if (s != 1) {  					/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  				}  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					/* newly nonzero coef is positive */s = p1;  				}  				else {  					/* newly nonzero coef is negative */s = m1;  				}  			}  			else {  				if (r != 15) {  					EOBRUN = 1 << r;  					/* EOBr' run length is 2^r + appended bits */if (r != 0) {  						if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  							undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  							return false;  						}  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					break;  					/* rest of block is handled by EOB logic */}  				/* note s = 0 for processing ZRL */}  			/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  				int blockIndex = JpegUtils.jpeg_natural_order [k];  				short thiscoef = MCU_data [0] [blockIndex];  				if (thiscoef != 0) {  					if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  						undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  						return false;  					}  					if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  						if ((thiscoef & p1) == 0) {  							/* do nothing if already set it */if (thiscoef >= 0)  								MCU_data [0] [blockIndex] += (short)p1;  							else  								MCU_data [0] [blockIndex] += (short)m1;  						}  					}  				}  				else {  					if (--r < 0)  						break;  					/* reached target zero coefficient */}  				k++;  			}  			while (k <= m_cinfo.m_Se);  			if (s != 0) {  				int pos = JpegUtils.jpeg_natural_order [k];  				/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  				/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  			}  		}  	}  	if (EOBRUN > 0) {  		/* Scan any remaining coefficient positions after the end-of-band                      * (the last newly nonzero coefficient' if any).  Append a correction                      * bit to each already-nonzero coefficient.  A correction bit is 1                      * if the absolute value of the coefficient must be increased.                      */for (; k <= m_cinfo.m_Se; k++) {  			int blockIndex = JpegUtils.jpeg_natural_order [k];  			short thiscoef = MCU_data [0] [blockIndex];  			if (thiscoef != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					//undo_decode_mcu_AC_refine(MCU_data[0]' newnz_pos' num_newnz);  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					if ((thiscoef & p1) == 0) {  						/* do nothing if already changed it */if (thiscoef >= 0)  							MCU_data [0] [blockIndex] += (short)p1;  						else  							MCU_data [0] [blockIndex] += (short)m1;  					}  				}  			}  		}  		/* Count one block completed in EOB run */EOBRUN--;  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (!m_insufficient_data) {  	/* Load up working state */int get_buffer;  	int bits_left;  	bitread_working_state br_state = new bitread_working_state ();  	BITREAD_LOAD_STATE (m_bitstate' out get_buffer' out bits_left' ref br_state);  	int EOBRUN = m_saved.EOBRUN;  	/* only part of saved state we need *//* If we are forced to suspend' we must undo the assignments to any newly                  * nonzero coefficients in the block' because otherwise we'd get confused                  * next time about which coefficients were already nonzero.                  * But we need not undo addition of bits to already-nonzero coefficients;                  * instead' we can test the current bit to see if we already did it.                  */int num_newnz = 0;  	int[] newnz_pos = new int[JpegConstants.DCTSIZE2];  	/* initialize coefficient loop counter to start of band */int k = m_cinfo.m_Ss;  	if (EOBRUN == 0) {  		for (; k <= m_cinfo.m_Se; k++) {  			int s;  			if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			int r = s >> 4;  			s &= 15;  			if (s != 0) {  				if (s != 1) {  					/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  				}  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					/* newly nonzero coef is positive */s = p1;  				}  				else {  					/* newly nonzero coef is negative */s = m1;  				}  			}  			else {  				if (r != 15) {  					EOBRUN = 1 << r;  					/* EOBr' run length is 2^r + appended bits */if (r != 0) {  						if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  							undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  							return false;  						}  						r = GET_BITS (r' get_buffer' ref bits_left);  						EOBRUN += r;  					}  					break;  					/* rest of block is handled by EOB logic */}  				/* note s = 0 for processing ZRL */}  			/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  				int blockIndex = JpegUtils.jpeg_natural_order [k];  				short thiscoef = MCU_data [0] [blockIndex];  				if (thiscoef != 0) {  					if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  						undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  						return false;  					}  					if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  						if ((thiscoef & p1) == 0) {  							/* do nothing if already set it */if (thiscoef >= 0)  								MCU_data [0] [blockIndex] += (short)p1;  							else  								MCU_data [0] [blockIndex] += (short)m1;  						}  					}  				}  				else {  					if (--r < 0)  						break;  					/* reached target zero coefficient */}  				k++;  			}  			while (k <= m_cinfo.m_Se);  			if (s != 0) {  				int pos = JpegUtils.jpeg_natural_order [k];  				/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  				/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  			}  		}  	}  	if (EOBRUN > 0) {  		/* Scan any remaining coefficient positions after the end-of-band                      * (the last newly nonzero coefficient' if any).  Append a correction                      * bit to each already-nonzero coefficient.  A correction bit is 1                      * if the absolute value of the coefficient must be increased.                      */for (; k <= m_cinfo.m_Se; k++) {  			int blockIndex = JpegUtils.jpeg_natural_order [k];  			short thiscoef = MCU_data [0] [blockIndex];  			if (thiscoef != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					//undo_decode_mcu_AC_refine(MCU_data[0]' newnz_pos' num_newnz);  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					if ((thiscoef & p1) == 0) {  						/* do nothing if already changed it */if (thiscoef >= 0)  							MCU_data [0] [blockIndex] += (short)p1;  						else  							MCU_data [0] [blockIndex] += (short)m1;  					}  				}  			}  		}  		/* Count one block completed in EOB run */EOBRUN--;  	}  	/* Completed MCU' so update state */BITREAD_SAVE_STATE (ref m_bitstate' get_buffer' bits_left);  	m_saved.EOBRUN = EOBRUN;  	/* only part of saved state we need */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (EOBRUN == 0) {  	for (; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			if (s != 1) {  				/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  			}  			if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  				/* newly nonzero coef is positive */s = p1;  			}  			else {  				/* newly nonzero coef is negative */s = m1;  			}  		}  		else {  			if (r != 15) {  				EOBRUN = 1 << r;  				/* EOBr' run length is 2^r + appended bits */if (r != 0) {  					if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  						undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  						return false;  					}  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				break;  				/* rest of block is handled by EOB logic */}  			/* note s = 0 for processing ZRL */}  		/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  			int blockIndex = JpegUtils.jpeg_natural_order [k];  			short thiscoef = MCU_data [0] [blockIndex];  			if (thiscoef != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					if ((thiscoef & p1) == 0) {  						/* do nothing if already set it */if (thiscoef >= 0)  							MCU_data [0] [blockIndex] += (short)p1;  						else  							MCU_data [0] [blockIndex] += (short)m1;  					}  				}  			}  			else {  				if (--r < 0)  					break;  				/* reached target zero coefficient */}  			k++;  		}  		while (k <= m_cinfo.m_Se);  		if (s != 0) {  			int pos = JpegUtils.jpeg_natural_order [k];  			/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  			/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (EOBRUN == 0) {  	for (; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			if (s != 1) {  				/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  			}  			if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  				/* newly nonzero coef is positive */s = p1;  			}  			else {  				/* newly nonzero coef is negative */s = m1;  			}  		}  		else {  			if (r != 15) {  				EOBRUN = 1 << r;  				/* EOBr' run length is 2^r + appended bits */if (r != 0) {  					if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  						undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  						return false;  					}  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				break;  				/* rest of block is handled by EOB logic */}  			/* note s = 0 for processing ZRL */}  		/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  			int blockIndex = JpegUtils.jpeg_natural_order [k];  			short thiscoef = MCU_data [0] [blockIndex];  			if (thiscoef != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					if ((thiscoef & p1) == 0) {  						/* do nothing if already set it */if (thiscoef >= 0)  							MCU_data [0] [blockIndex] += (short)p1;  						else  							MCU_data [0] [blockIndex] += (short)m1;  					}  				}  			}  			else {  				if (--r < 0)  					break;  				/* reached target zero coefficient */}  			k++;  		}  		while (k <= m_cinfo.m_Se);  		if (s != 0) {  			int pos = JpegUtils.jpeg_natural_order [k];  			/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  			/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (EOBRUN == 0) {  	for (; k <= m_cinfo.m_Se; k++) {  		int s;  		if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		int r = s >> 4;  		s &= 15;  		if (s != 0) {  			if (s != 1) {  				/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  			}  			if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  				/* newly nonzero coef is positive */s = p1;  			}  			else {  				/* newly nonzero coef is negative */s = m1;  			}  		}  		else {  			if (r != 15) {  				EOBRUN = 1 << r;  				/* EOBr' run length is 2^r + appended bits */if (r != 0) {  					if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  						undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  						return false;  					}  					r = GET_BITS (r' get_buffer' ref bits_left);  					EOBRUN += r;  				}  				break;  				/* rest of block is handled by EOB logic */}  			/* note s = 0 for processing ZRL */}  		/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  			int blockIndex = JpegUtils.jpeg_natural_order [k];  			short thiscoef = MCU_data [0] [blockIndex];  			if (thiscoef != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  					if ((thiscoef & p1) == 0) {  						/* do nothing if already set it */if (thiscoef >= 0)  							MCU_data [0] [blockIndex] += (short)p1;  						else  							MCU_data [0] [blockIndex] += (short)m1;  					}  				}  			}  			else {  				if (--r < 0)  					break;  				/* reached target zero coefficient */}  			k++;  		}  		while (k <= m_cinfo.m_Se);  		if (s != 0) {  			int pos = JpegUtils.jpeg_natural_order [k];  			/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  			/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  		}  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: for (; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  		undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  		return false;  	}  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		if (s != 1) {  			/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  		}  		if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  			/* newly nonzero coef is positive */s = p1;  		}  		else {  			/* newly nonzero coef is negative */s = m1;  		}  	}  	else {  		if (r != 15) {  			EOBRUN = 1 << r;  			/* EOBr' run length is 2^r + appended bits */if (r != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			break;  			/* rest of block is handled by EOB logic */}  		/* note s = 0 for processing ZRL */}  	/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  		int blockIndex = JpegUtils.jpeg_natural_order [k];  		short thiscoef = MCU_data [0] [blockIndex];  		if (thiscoef != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  				if ((thiscoef & p1) == 0) {  					/* do nothing if already set it */if (thiscoef >= 0)  						MCU_data [0] [blockIndex] += (short)p1;  					else  						MCU_data [0] [blockIndex] += (short)m1;  				}  			}  		}  		else {  			if (--r < 0)  				break;  			/* reached target zero coefficient */}  		k++;  	}  	while (k <= m_cinfo.m_Se);  	if (s != 0) {  		int pos = JpegUtils.jpeg_natural_order [k];  		/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  		/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: for (; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  		undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  		return false;  	}  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		if (s != 1) {  			/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  		}  		if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  			/* newly nonzero coef is positive */s = p1;  		}  		else {  			/* newly nonzero coef is negative */s = m1;  		}  	}  	else {  		if (r != 15) {  			EOBRUN = 1 << r;  			/* EOBr' run length is 2^r + appended bits */if (r != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			break;  			/* rest of block is handled by EOB logic */}  		/* note s = 0 for processing ZRL */}  	/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  		int blockIndex = JpegUtils.jpeg_natural_order [k];  		short thiscoef = MCU_data [0] [blockIndex];  		if (thiscoef != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  				if ((thiscoef & p1) == 0) {  					/* do nothing if already set it */if (thiscoef >= 0)  						MCU_data [0] [blockIndex] += (short)p1;  					else  						MCU_data [0] [blockIndex] += (short)m1;  				}  			}  		}  		else {  			if (--r < 0)  				break;  			/* reached target zero coefficient */}  		k++;  	}  	while (k <= m_cinfo.m_Se);  	if (s != 0) {  		int pos = JpegUtils.jpeg_natural_order [k];  		/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  		/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: for (; k <= m_cinfo.m_Se; k++) {  	int s;  	if (!HUFF_DECODE (out s' ref br_state' m_ac_derived_tbl' ref get_buffer' ref bits_left)) {  		undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  		return false;  	}  	int r = s >> 4;  	s &= 15;  	if (s != 0) {  		if (s != 1) {  			/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  		}  		if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  			/* newly nonzero coef is positive */s = p1;  		}  		else {  			/* newly nonzero coef is negative */s = m1;  		}  	}  	else {  		if (r != 15) {  			EOBRUN = 1 << r;  			/* EOBr' run length is 2^r + appended bits */if (r != 0) {  				if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  					undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  					return false;  				}  				r = GET_BITS (r' get_buffer' ref bits_left);  				EOBRUN += r;  			}  			break;  			/* rest of block is handled by EOB logic */}  		/* note s = 0 for processing ZRL */}  	/* Advance over already-nonzero coefs and r still-zero coefs'                          * appending correction bits to the nonzeroes.  A correction bit is 1                          * if the absolute value of the coefficient must be increased.                          */do {  		int blockIndex = JpegUtils.jpeg_natural_order [k];  		short thiscoef = MCU_data [0] [blockIndex];  		if (thiscoef != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  				if ((thiscoef & p1) == 0) {  					/* do nothing if already set it */if (thiscoef >= 0)  						MCU_data [0] [blockIndex] += (short)p1;  					else  						MCU_data [0] [blockIndex] += (short)m1;  				}  			}  		}  		else {  			if (--r < 0)  				break;  			/* reached target zero coefficient */}  		k++;  	}  	while (k <= m_cinfo.m_Se);  	if (s != 0) {  		int pos = JpegUtils.jpeg_natural_order [k];  		/* Output newly nonzero coefficient */MCU_data [0] [pos] = (short)s;  		/* Remember its position in case we have to suspend */newnz_pos [num_newnz++] = pos;  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: s &= 15;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (s != 0) {  	if (s != 1) {  		/* size of new coef should always be 1 */m_cinfo.WARNMS (J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE);  	}  	if (!CHECK_BIT_BUFFER (ref br_state' 1' ref get_buffer' ref bits_left)) {  		undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  		return false;  	}  	if (GET_BITS (1' get_buffer' ref bits_left) != 0) {  		/* newly nonzero coef is positive */s = p1;  	}  	else {  		/* newly nonzero coef is negative */s = m1;  	}  }  else {  	if (r != 15) {  		EOBRUN = 1 << r;  		/* EOBr' run length is 2^r + appended bits */if (r != 0) {  			if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  				undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  				return false;  			}  			r = GET_BITS (r' get_buffer' ref bits_left);  			EOBRUN += r;  		}  		break;  		/* rest of block is handled by EOB logic */}  	/* note s = 0 for processing ZRL */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu_AC_refine,The following statement contains a magic number: if (r != 15) {  	EOBRUN = 1 << r;  	/* EOBr' run length is 2^r + appended bits */if (r != 0) {  		if (!CHECK_BIT_BUFFER (ref br_state' r' ref get_buffer' ref bits_left)) {  			undo_decode_mcu_AC_refine (MCU_data' newnz_pos' num_newnz);  			return false;  		}  		r = GET_BITS (r' get_buffer' ref bits_left);  		EOBRUN += r;  	}  	break;  	/* rest of block is handled by EOB logic */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,process_restart,The following statement contains a magic number: m_cinfo.m_marker.SkipBytes (m_bitstate.bits_left / 8);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_comps_in_scan; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]];  	/* Initialize DC predictions to 0 */m_last_dc_val [ci] = 0;  	/* Get table index */int tbl;  	if (is_DC_band) {  		if (m_cinfo.m_Ah != 0)  			/* DC refinement needs no table */continue;  		tbl = componentInfo.Dc_tbl_no;  	}  	else {  		m_ac_tbl_no = componentInfo.Ac_tbl_no;  		tbl = componentInfo.Ac_tbl_no;  	}  	if (m_gather_statistics) {  		/* Check for invalid table index *//* (make_c_derived_tbl does this in the other path) */if (tbl < 0 || tbl >= JpegConstants.NUM_HUFF_TBLS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' tbl);  		/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_count_ptrs [tbl] == null)  			m_count_ptrs [tbl] = new long[257];  		Array.Clear (m_count_ptrs [tbl]' 0' 257);  	}  	else {  		/* Compute derived values for Huffman table *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (is_DC_band' tbl' ref m_derived_tbls [tbl]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: for (int ci = 0; ci < m_cinfo.m_comps_in_scan; ci++) {  	jpeg_component_info componentInfo = m_cinfo.Component_info [m_cinfo.m_cur_comp_info [ci]];  	/* Initialize DC predictions to 0 */m_last_dc_val [ci] = 0;  	/* Get table index */int tbl;  	if (is_DC_band) {  		if (m_cinfo.m_Ah != 0)  			/* DC refinement needs no table */continue;  		tbl = componentInfo.Dc_tbl_no;  	}  	else {  		m_ac_tbl_no = componentInfo.Ac_tbl_no;  		tbl = componentInfo.Ac_tbl_no;  	}  	if (m_gather_statistics) {  		/* Check for invalid table index *//* (make_c_derived_tbl does this in the other path) */if (tbl < 0 || tbl >= JpegConstants.NUM_HUFF_TBLS)  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' tbl);  		/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_count_ptrs [tbl] == null)  			m_count_ptrs [tbl] = new long[257];  		Array.Clear (m_count_ptrs [tbl]' 0' 257);  	}  	else {  		/* Compute derived values for Huffman table *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (is_DC_band' tbl' ref m_derived_tbls [tbl]);  	}  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_gather_statistics) {  	/* Check for invalid table index *//* (make_c_derived_tbl does this in the other path) */if (tbl < 0 || tbl >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' tbl);  	/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_count_ptrs [tbl] == null)  		m_count_ptrs [tbl] = new long[257];  	Array.Clear (m_count_ptrs [tbl]' 0' 257);  }  else {  	/* Compute derived values for Huffman table *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (is_DC_band' tbl' ref m_derived_tbls [tbl]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_gather_statistics) {  	/* Check for invalid table index *//* (make_c_derived_tbl does this in the other path) */if (tbl < 0 || tbl >= JpegConstants.NUM_HUFF_TBLS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_NO_HUFF_TABLE' tbl);  	/* Allocate and zero the statistics tables *//* Note that jpeg_gen_optimal_table expects 257 entries in each table! */if (m_count_ptrs [tbl] == null)  		m_count_ptrs [tbl] = new long[257];  	Array.Clear (m_count_ptrs [tbl]' 0' 257);  }  else {  	/* Compute derived values for Huffman table *//* We may do this more than once for a table' but it's not expensive */jpeg_make_c_derived_tbl (is_DC_band' tbl' ref m_derived_tbls [tbl]);  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: if (m_count_ptrs [tbl] == null)  	m_count_ptrs [tbl] = new long[257];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: m_count_ptrs [tbl] = new long[257];  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,start_pass,The following statement contains a magic number: Array.Clear (m_count_ptrs [tbl]' 0' 257);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,The following statement contains a magic number: if (m_cinfo.m_restart_interval != 0) {  	if (m_restarts_to_go == 0) {  		m_restarts_to_go = m_cinfo.m_restart_interval;  		m_next_restart_num++;  		m_next_restart_num &= 7;  	}  	m_restarts_to_go--;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,The following statement contains a magic number: if (m_restarts_to_go == 0) {  	m_restarts_to_go = m_cinfo.m_restart_interval;  	m_next_restart_num++;  	m_next_restart_num &= 7;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_first,The following statement contains a magic number: m_next_restart_num &= 7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int temp = MCU_data [0] [0] [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  		continue;  	}  	/* We must apply the point transform by Al.  For AC coefficients this                  * is an integer division with rounding towards 0.  To do this portably                  * in C' we shift after obtaining the absolute value; so the code is                  * interwoven with finding the abs value (temp) and output bits (temp2).                  */int temp2;  	if (temp < 0) {  		temp = -temp;  		/* temp is abs value of input */temp >>= m_cinfo.m_Al;  		/* apply the point transform *//* For a negative coef' want temp2 = bitwise complement of abs(coef) */temp2 = ~temp;  	}  	else {  		temp >>= m_cinfo.m_Al;  		/* apply the point transform */temp2 = temp;  	}  	/* Watch out for case that nonzero coef is zero after point transform */if (temp == 0) {  		r++;  		continue;  	}  	/* Emit any pending EOBRUN */if (m_EOBRUN > 0)  		emit_eobrun ();  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		emit_symbol (m_ac_tbl_no' 0xF0);  		r -= 16;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */int nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Count/emit Huffman symbol for run length / number of bits */emit_symbol (m_ac_tbl_no' (r << 4) + nbits);  	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */emit_bits (temp2' nbits);  	r = 0;  	/* reset zero run length */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int temp = MCU_data [0] [0] [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  		continue;  	}  	/* We must apply the point transform by Al.  For AC coefficients this                  * is an integer division with rounding towards 0.  To do this portably                  * in C' we shift after obtaining the absolute value; so the code is                  * interwoven with finding the abs value (temp) and output bits (temp2).                  */int temp2;  	if (temp < 0) {  		temp = -temp;  		/* temp is abs value of input */temp >>= m_cinfo.m_Al;  		/* apply the point transform *//* For a negative coef' want temp2 = bitwise complement of abs(coef) */temp2 = ~temp;  	}  	else {  		temp >>= m_cinfo.m_Al;  		/* apply the point transform */temp2 = temp;  	}  	/* Watch out for case that nonzero coef is zero after point transform */if (temp == 0) {  		r++;  		continue;  	}  	/* Emit any pending EOBRUN */if (m_EOBRUN > 0)  		emit_eobrun ();  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		emit_symbol (m_ac_tbl_no' 0xF0);  		r -= 16;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */int nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Count/emit Huffman symbol for run length / number of bits */emit_symbol (m_ac_tbl_no' (r << 4) + nbits);  	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */emit_bits (temp2' nbits);  	r = 0;  	/* reset zero run length */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int temp = MCU_data [0] [0] [JpegUtils.jpeg_natural_order [k]];  	if (temp == 0) {  		r++;  		continue;  	}  	/* We must apply the point transform by Al.  For AC coefficients this                  * is an integer division with rounding towards 0.  To do this portably                  * in C' we shift after obtaining the absolute value; so the code is                  * interwoven with finding the abs value (temp) and output bits (temp2).                  */int temp2;  	if (temp < 0) {  		temp = -temp;  		/* temp is abs value of input */temp >>= m_cinfo.m_Al;  		/* apply the point transform *//* For a negative coef' want temp2 = bitwise complement of abs(coef) */temp2 = ~temp;  	}  	else {  		temp >>= m_cinfo.m_Al;  		/* apply the point transform */temp2 = temp;  	}  	/* Watch out for case that nonzero coef is zero after point transform */if (temp == 0) {  		r++;  		continue;  	}  	/* Emit any pending EOBRUN */if (m_EOBRUN > 0)  		emit_eobrun ();  	/* if run length > 15' must emit special run-length-16 codes (0xF0) */while (r > 15) {  		emit_symbol (m_ac_tbl_no' 0xF0);  		r -= 16;  	}  	/* Find the number of bits needed for the magnitude of the coefficient */int nbits = 1;  	/* there must be at least one 1 bit */while ((temp >>= 1) != 0)  		nbits++;  	/* Check for out-of-range coefficient values */if (nbits > MAX_HUFFMAN_COEF_BITS)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_BAD_DCT_COEF);  	/* Count/emit Huffman symbol for run length / number of bits */emit_symbol (m_ac_tbl_no' (r << 4) + nbits);  	/* Emit that number of bits of the value' if positive' *//* or the complement of its magnitude' if negative. */emit_bits (temp2' nbits);  	r = 0;  	/* reset zero run length */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: while (r > 15) {  	emit_symbol (m_ac_tbl_no' 0xF0);  	r -= 16;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: while (r > 15) {  	emit_symbol (m_ac_tbl_no' 0xF0);  	r -= 16;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: r -= 16;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: emit_symbol (m_ac_tbl_no' (r << 4) + nbits);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: if (m_cinfo.m_restart_interval != 0) {  	if (m_restarts_to_go == 0) {  		m_restarts_to_go = m_cinfo.m_restart_interval;  		m_next_restart_num++;  		m_next_restart_num &= 7;  	}  	m_restarts_to_go--;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: if (m_restarts_to_go == 0) {  	m_restarts_to_go = m_cinfo.m_restart_interval;  	m_next_restart_num++;  	m_next_restart_num &= 7;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_first,The following statement contains a magic number: m_next_restart_num &= 7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_refine,The following statement contains a magic number: if (m_cinfo.m_restart_interval != 0) {  	if (m_restarts_to_go == 0) {  		m_restarts_to_go = m_cinfo.m_restart_interval;  		m_next_restart_num++;  		m_next_restart_num &= 7;  	}  	m_restarts_to_go--;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_refine,The following statement contains a magic number: if (m_restarts_to_go == 0) {  	m_restarts_to_go = m_cinfo.m_restart_interval;  	m_next_restart_num++;  	m_next_restart_num &= 7;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_DC_refine,The following statement contains a magic number: m_next_restart_num &= 7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int temp = absvalues [k];  	if (temp == 0) {  		r++;  		continue;  	}  	/* Emit any required ZRLs' but not if they can be folded into EOB */while (r > 15 && k <= EOB) {  		/* emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  		/* Emit ZRL */emit_symbol (m_ac_tbl_no' 0xF0);  		r -= 16;  		/* Emit buffered correction bits that must be associated with ZRL */emit_buffered_bits (bitBufferOffset' BR);  		bitBufferOffset = 0;  		/* BE bits are gone now */BR = 0;  	}  	/* If the coef was previously nonzero' it only needs a correction bit.                  * NOTE: a straight translation of the spec's figure G.7 would suggest                  * that we also need to test r > 15.  But if r > 15' we can only get here                  * if k > EOB' which implies that this coefficient is not 1.                  */if (temp > 1) {  		/* The correction bit is the next bit of the absolute value. */m_bit_buffer [bitBufferOffset + BR] = (char)(temp & 1);  		BR++;  		continue;  	}  	/* Emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  	/* Count/emit Huffman symbol for run length / number of bits */emit_symbol (m_ac_tbl_no' (r << 4) + 1);  	/* Emit output bit for newly-nonzero coef */temp = (MCU_data [0] [0] [JpegUtils.jpeg_natural_order [k]] < 0) ? 0 : 1;  	emit_bits (temp' 1);  	/* Emit buffered correction bits that must be associated with this code */emit_buffered_bits (bitBufferOffset' BR);  	bitBufferOffset = 0;  	/* BE bits are gone now */BR = 0;  	r = 0;  	/* reset zero run length */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int temp = absvalues [k];  	if (temp == 0) {  		r++;  		continue;  	}  	/* Emit any required ZRLs' but not if they can be folded into EOB */while (r > 15 && k <= EOB) {  		/* emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  		/* Emit ZRL */emit_symbol (m_ac_tbl_no' 0xF0);  		r -= 16;  		/* Emit buffered correction bits that must be associated with ZRL */emit_buffered_bits (bitBufferOffset' BR);  		bitBufferOffset = 0;  		/* BE bits are gone now */BR = 0;  	}  	/* If the coef was previously nonzero' it only needs a correction bit.                  * NOTE: a straight translation of the spec's figure G.7 would suggest                  * that we also need to test r > 15.  But if r > 15' we can only get here                  * if k > EOB' which implies that this coefficient is not 1.                  */if (temp > 1) {  		/* The correction bit is the next bit of the absolute value. */m_bit_buffer [bitBufferOffset + BR] = (char)(temp & 1);  		BR++;  		continue;  	}  	/* Emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  	/* Count/emit Huffman symbol for run length / number of bits */emit_symbol (m_ac_tbl_no' (r << 4) + 1);  	/* Emit output bit for newly-nonzero coef */temp = (MCU_data [0] [0] [JpegUtils.jpeg_natural_order [k]] < 0) ? 0 : 1;  	emit_bits (temp' 1);  	/* Emit buffered correction bits that must be associated with this code */emit_buffered_bits (bitBufferOffset' BR);  	bitBufferOffset = 0;  	/* BE bits are gone now */BR = 0;  	r = 0;  	/* reset zero run length */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: for (int k = m_cinfo.m_Ss; k <= m_cinfo.m_Se; k++) {  	int temp = absvalues [k];  	if (temp == 0) {  		r++;  		continue;  	}  	/* Emit any required ZRLs' but not if they can be folded into EOB */while (r > 15 && k <= EOB) {  		/* emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  		/* Emit ZRL */emit_symbol (m_ac_tbl_no' 0xF0);  		r -= 16;  		/* Emit buffered correction bits that must be associated with ZRL */emit_buffered_bits (bitBufferOffset' BR);  		bitBufferOffset = 0;  		/* BE bits are gone now */BR = 0;  	}  	/* If the coef was previously nonzero' it only needs a correction bit.                  * NOTE: a straight translation of the spec's figure G.7 would suggest                  * that we also need to test r > 15.  But if r > 15' we can only get here                  * if k > EOB' which implies that this coefficient is not 1.                  */if (temp > 1) {  		/* The correction bit is the next bit of the absolute value. */m_bit_buffer [bitBufferOffset + BR] = (char)(temp & 1);  		BR++;  		continue;  	}  	/* Emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  	/* Count/emit Huffman symbol for run length / number of bits */emit_symbol (m_ac_tbl_no' (r << 4) + 1);  	/* Emit output bit for newly-nonzero coef */temp = (MCU_data [0] [0] [JpegUtils.jpeg_natural_order [k]] < 0) ? 0 : 1;  	emit_bits (temp' 1);  	/* Emit buffered correction bits that must be associated with this code */emit_buffered_bits (bitBufferOffset' BR);  	bitBufferOffset = 0;  	/* BE bits are gone now */BR = 0;  	r = 0;  	/* reset zero run length */}  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: while (r > 15 && k <= EOB) {  	/* emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  	/* Emit ZRL */emit_symbol (m_ac_tbl_no' 0xF0);  	r -= 16;  	/* Emit buffered correction bits that must be associated with ZRL */emit_buffered_bits (bitBufferOffset' BR);  	bitBufferOffset = 0;  	/* BE bits are gone now */BR = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: while (r > 15 && k <= EOB) {  	/* emit any pending EOBRUN and the BE correction bits */emit_eobrun ();  	/* Emit ZRL */emit_symbol (m_ac_tbl_no' 0xF0);  	r -= 16;  	/* Emit buffered correction bits that must be associated with ZRL */emit_buffered_bits (bitBufferOffset' BR);  	bitBufferOffset = 0;  	/* BE bits are gone now */BR = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: r -= 16;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: emit_symbol (m_ac_tbl_no' (r << 4) + 1);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: if (m_cinfo.m_restart_interval != 0) {  	if (m_restarts_to_go == 0) {  		m_restarts_to_go = m_cinfo.m_restart_interval;  		m_next_restart_num++;  		m_next_restart_num &= 7;  	}  	m_restarts_to_go--;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: if (m_restarts_to_go == 0) {  	m_restarts_to_go = m_cinfo.m_restart_interval;  	m_next_restart_num++;  	m_next_restart_num &= 7;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu_AC_refine,The following statement contains a magic number: m_next_restart_num &= 7;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: local_put_buffer <<= 24 - m_put_bits;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (m_put_bits >= 8) {  	int c = (local_put_buffer >> 16) & 0xFF;  	emit_byte (c);  	if (c == 0xFF) {  		/* need to stuff a zero byte? */emit_byte (0);  	}  	local_put_buffer <<= 8;  	m_put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (m_put_bits >= 8) {  	int c = (local_put_buffer >> 16) & 0xFF;  	emit_byte (c);  	if (c == 0xFF) {  		/* need to stuff a zero byte? */emit_byte (0);  	}  	local_put_buffer <<= 8;  	m_put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (m_put_bits >= 8) {  	int c = (local_put_buffer >> 16) & 0xFF;  	emit_byte (c);  	if (c == 0xFF) {  		/* need to stuff a zero byte? */emit_byte (0);  	}  	local_put_buffer <<= 8;  	m_put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: while (m_put_bits >= 8) {  	int c = (local_put_buffer >> 16) & 0xFF;  	emit_byte (c);  	if (c == 0xFF) {  		/* need to stuff a zero byte? */emit_byte (0);  	}  	local_put_buffer <<= 8;  	m_put_bits -= 8;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: local_put_buffer <<= 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_bits,The following statement contains a magic number: m_put_bits -= 8;  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,flush_bits,The following statement contains a magic number: emit_bits (0x7F' 7);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_eobrun,The following statement contains a magic number: if (m_EOBRUN > 0) {  	/* if there is any pending EOBRUN */int temp = m_EOBRUN;  	int nbits = 0;  	while ((temp >>= 1) != 0)  		nbits++;  	/* safety check: shouldn't happen given limited correction-bit buffer */if (nbits > 14)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE);  	emit_symbol (m_ac_tbl_no' nbits << 4);  	if (nbits != 0)  		emit_bits (m_EOBRUN' nbits);  	m_EOBRUN = 0;  	/* Emit any buffered correction bits */emit_buffered_bits (0' m_BE);  	m_BE = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_eobrun,The following statement contains a magic number: if (m_EOBRUN > 0) {  	/* if there is any pending EOBRUN */int temp = m_EOBRUN;  	int nbits = 0;  	while ((temp >>= 1) != 0)  		nbits++;  	/* safety check: shouldn't happen given limited correction-bit buffer */if (nbits > 14)  		m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE);  	emit_symbol (m_ac_tbl_no' nbits << 4);  	if (nbits != 0)  		emit_bits (m_EOBRUN' nbits);  	m_EOBRUN = 0;  	/* Emit any buffered correction bits */emit_buffered_bits (0' m_BE);  	m_BE = 0;  }  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_eobrun,The following statement contains a magic number: if (nbits > 14)  	m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE);  
Magic Number,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,emit_eobrun,The following statement contains a magic number: emit_symbol (m_ac_tbl_no' nbits << 4);  
Missing Default,BitMiracle.LibJpeg,BitStream,C:\repos\b9chris_LibJpeg.Net\LibJpeg\BitStream.cs,Seek,The following switch statement is missing a default case: switch (mode) {  case SeekOrigin.Begin:  	seekSet (pos);  	break;  case SeekOrigin.Current:  	seekCurrent (pos);  	break;  case SeekOrigin.End:  	seekSet (Size () + pos);  	break;  }  
Missing Default,BitMiracle.LibJpeg.Classic,jpeg_compress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_compress_struct.cs,map_colorspace,The following switch statement is missing a default case: switch (in_color_space) {  case J_COLOR_SPACE.JCS_GRAYSCALE:  case J_COLOR_SPACE.JCS_CMYK:  case J_COLOR_SPACE.JCS_YCCK:  case J_COLOR_SPACE.JCS_UNKNOWN:  	return in_color_space;  case J_COLOR_SPACE.JCS_RGB:  case J_COLOR_SPACE.JCS_YCbCr:  	return J_COLOR_SPACE.JCS_YCbCr;  }  
Missing Default,BitMiracle.LibJpeg.Classic,jpeg_decompress_struct,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_decompress_struct.cs,jpeg_read_header,The following switch statement is missing a default case: switch (retcode) {  case ReadResult.JPEG_REACHED_SOS:  	return ReadResult.JPEG_HEADER_OK;  case ReadResult.JPEG_REACHED_EOI:  	if (require_image)  		/* Complain if application wanted an image */ERREXIT (J_MESSAGE_CODE.JERR_NO_IMAGE);  	/* Reset to start state; it would be safer to require the application to                     * call jpeg_abort' but we can't change it now for compatibility reasons.                     * A side effect is to free any temporary memory (there shouldn't be any).                     */jpeg_abort ();  	/* sets state = DSTATE_START */return ReadResult.JPEG_HEADER_TABLES_ONLY;  case ReadResult.JPEG_SUSPENDED:  	/* no work */break;  }  
Missing Default,BitMiracle.LibJpeg.Classic,jpeg_source_mgr,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\jpeg_source_mgr.cs,resync_to_restart,The following switch statement is missing a default case: switch (action) {  case 1:  	/* Discard marker and let entropy decoder resume processing. */cinfo.m_unread_marker = 0;  	return true;  case 2:  	/* Scan to the next marker' and repeat the decision loop. */if (!cinfo.m_marker.next_marker ())  		return false;  	break;  case 3:  	/* Return without advancing past this marker. *//* Entropy decoder will be forced to process an empty segment. */return true;  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,jpeg_comp_master,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_comp_master.cs,finish_pass,The following switch statement is missing a default case: switch (m_pass_type) {  case c_pass_type.main_pass:  	/* next pass is either output of scan 0 (after optimization)                     * or output of scan 1 (if no optimization).                     */m_pass_type = c_pass_type.output_pass;  	if (!m_cinfo.m_optimize_coding)  		m_scan_number++;  	break;  case c_pass_type.huff_opt_pass:  	/* next pass is always output of current scan */m_pass_type = c_pass_type.output_pass;  	break;  case c_pass_type.output_pass:  	/* next pass is either optimization or output of next scan */if (m_cinfo.m_optimize_coding)  		m_pass_type = c_pass_type.huff_opt_pass;  	m_scan_number++;  	break;  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,jpeg_downsampler,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_downsampler.cs,downsample,The following switch statement is missing a default case: switch (m_downSamplers [ci]) {  case downSampleMethod.fullsize_smooth_downsampler:  	fullsize_smooth_downsample (ci' input_buf [ci]' in_row_index' output_buf [ci]' outIndex);  	break;  case downSampleMethod.fullsize_downsampler:  	fullsize_downsample (ci' input_buf [ci]' in_row_index' output_buf [ci]' outIndex);  	break;  case downSampleMethod.h2v1_downsampler:  	h2v1_downsample (ci' input_buf [ci]' in_row_index' output_buf [ci]' outIndex);  	break;  case downSampleMethod.h2v2_smooth_downsampler:  	h2v2_smooth_downsample (ci' input_buf [ci]' in_row_index' output_buf [ci]' outIndex);  	break;  case downSampleMethod.h2v2_downsampler:  	h2v2_downsample (ci' input_buf [ci]' in_row_index' output_buf [ci]' outIndex);  	break;  case downSampleMethod.int_downsampler:  	int_downsample (ci' input_buf [ci]' in_row_index' output_buf [ci]' outIndex);  	break;  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,jpeg_d_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_d_coef_controller.cs,decompress_data,The following switch statement is missing a default case: switch (m_decompressor) {  case DecompressorType.Ordinary:  	return decompress_data_ordinary (output_buf);  case DecompressorType.Smooth:  	return decompress_smooth_data (output_buf);  case DecompressorType.OnePass:  	return decompress_onepass (output_buf);  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,jpeg_input_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\jpeg_input_controller.cs,consume_markers,The following switch statement is missing a default case: switch (val) {  case ReadResult.JPEG_REACHED_SOS:  	/* Found SOS */if (m_inheaders) {  		/* 1st SOS */initial_setup ();  		m_inheaders = false;  		/* Note: start_input_pass must be called by jpeg_decomp_master                          * before any more input can be consumed.                          */}  	else {  		/* 2nd or later SOS marker */if (!m_has_multiple_scans) {  			/* Oops' I wasn't expecting this! */m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_EOI_EXPECTED);  		}  		m_cinfo.m_inputctl.start_input_pass ();  	}  	break;  case ReadResult.JPEG_REACHED_EOI:  	/* Found EOI */m_eoi_reached = true;  	if (m_inheaders) {  		/* Tables-only datastream' apparently */if (m_cinfo.m_marker.SawSOF ())  			m_cinfo.ERREXIT (J_MESSAGE_CODE.JERR_SOF_NO_SOS);  	}  	else {  		/* Prevent infinite loop in coef ctlr's decompress_data routine                          * if user set output_scan_number larger than number of scans.                          */if (m_cinfo.m_output_scan_number > m_cinfo.m_input_scan_number)  			m_cinfo.m_output_scan_number = m_cinfo.m_input_scan_number;  	}  	break;  case ReadResult.JPEG_SUSPENDED:  	break;  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,my_2pass_cquantizer,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_2pass_cquantizer.cs,median_cut,The following switch statement is missing a default case: switch (n) {  case 0:  	lb = (boxlist [foundIndex].c0max + boxlist [foundIndex].c0min) / 2;  	boxlist [foundIndex].c0max = lb;  	boxlist [numboxes].c0min = lb + 1;  	break;  case 1:  	lb = (boxlist [foundIndex].c1max + boxlist [foundIndex].c1min) / 2;  	boxlist [foundIndex].c1max = lb;  	boxlist [numboxes].c1min = lb + 1;  	break;  case 2:  	lb = (boxlist [foundIndex].c2max + boxlist [foundIndex].c2min) / 2;  	boxlist [foundIndex].c2max = lb;  	boxlist [numboxes].c2min = lb + 1;  	break;  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,my_c_coef_controller,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\my_c_coef_controller.cs,compress_data,The following switch statement is missing a default case: switch (m_passModeSetByLastStartPass) {  case J_BUF_MODE.JBUF_PASS_THRU:  	return compressDataImpl (input_buf);  case J_BUF_MODE.JBUF_SAVE_AND_PASS:  	return compressFirstPass (input_buf);  case J_BUF_MODE.JBUF_CRANK_DEST:  	return compressOutput ();  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_decoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_decoder.cs,decode_mcu,The following switch statement is missing a default case: switch (m_decoder) {  case MCUDecoder.mcu_DC_first_decoder:  	return decode_mcu_DC_first (MCU_data);  case MCUDecoder.mcu_AC_first_decoder:  	return decode_mcu_AC_first (MCU_data);  case MCUDecoder.mcu_DC_refine_decoder:  	return decode_mcu_DC_refine (MCU_data);  case MCUDecoder.mcu_AC_refine_decoder:  	return decode_mcu_AC_refine (MCU_data);  }  
Missing Default,BitMiracle.LibJpeg.Classic.Internal,phuff_entropy_encoder,C:\repos\b9chris_LibJpeg.Net\LibJpeg\Classic\Internal\phuff_entropy_encoder.cs,encode_mcu,The following switch statement is missing a default case: switch (m_MCUEncoder) {  case MCUEncoder.mcu_DC_first_encoder:  	return encode_mcu_DC_first (MCU_data);  case MCUEncoder.mcu_AC_first_encoder:  	return encode_mcu_AC_first (MCU_data);  case MCUEncoder.mcu_DC_refine_encoder:  	return encode_mcu_DC_refine (MCU_data);  case MCUEncoder.mcu_AC_refine_encoder:  	return encode_mcu_AC_refine (MCU_data);  }  
