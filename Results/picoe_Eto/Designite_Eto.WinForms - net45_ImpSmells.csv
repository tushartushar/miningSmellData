Implementation smell,Namespace,Class,File,Method,Description
Long Method,Eto.WinForms,KeyMap,C:\repos\picoe_Eto\Source\Eto.WinForms\KeyMap.cs,GetMap,The method has 104 lines of code.
Long Method,Eto.WinForms,Platform,C:\repos\picoe_Eto\Source\Eto.WinForms\Platform.cs,AddTo,The method has 122 lines of code.
Long Method,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The method has 120 lines of code.
Long Method,Eto.WinForms.Forms.Controls,TreeViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeViewHandler.cs,AttachEvent,The method has 120 lines of code.
Complex Method,Eto.CustomControls,TreeController,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\TreeController.cs,GetItemAtRow,Cyclomatic complexity of the method is 8
Complex Method,Eto.WinForms,ScrollMessageFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\ScrollMessageFilter.cs,PreFilterMessage,Cyclomatic complexity of the method is 8
Complex Method,Eto.WinForms,Win32TextBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Win32TextBox.cs,FastScrollToCaret,Cyclomatic complexity of the method is 8
Complex Method,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,Cyclomatic complexity of the method is 9
Complex Method,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,Cyclomatic complexity of the method is 8
Complex Method,Eto.WinForms.Forms.Controls,EtoNumericUpDown,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\NumericStepperHandler.cs,UpdateValue,Cyclomatic complexity of the method is 11
Complex Method,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,Cyclomatic complexity of the method is 9
Long Parameter List,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,PeekMessage,The method has 5 parameters. Parameters: wMsg' hwnd' msgMin' msgMax' remove
Long Parameter List,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,GetLinearScale,The method has 5 parameters. Parameters: startPoint' endPoint' rect' lastScale' gradientScale
Long Parameter List,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,GetLinearMinMax,The method has 6 parameters. Parameters: startPoint' endPoint' rect' min' max' includeStartEnd
Long Parameter List,Eto.WinForms.Forms,EtoTableLayoutPanel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,SetBoundsCore,The method has 5 parameters. Parameters: x' y' width' height' specified
Long Parameter List,Eto.WinForms.Drawing,RadialGradientBrushHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\RadialGradientBrushHandler.cs,Create,The method has 5 parameters. Parameters: startColor' endColor' center' gradientOrigin' radius
Long Parameter List,Eto.WinForms.Drawing,MatrixHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\MatrixHandler.cs,Create,The method has 6 parameters. Parameters: xx' yx' xy' yy' dx' dy
Long Parameter List,Eto.WinForms.Drawing,IWindowsImage,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,DrawImage,The method has 5 parameters. Parameters: graphics' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,BitmapDataHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,BitmapDataHandler,The method has 5 parameters. Parameters: image' data' scanWidth' bitsPerPixel' controlObject
Long Parameter List,Eto.WinForms.Drawing,BitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,DrawImage,The method has 5 parameters. Parameters: graphics' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawLine,The method has 5 parameters. Parameters: pen' startx' starty' endx' endy
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawRectangle,The method has 5 parameters. Parameters: pen' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillRectangle,The method has 5 parameters. Parameters: brush' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawEllipse,The method has 5 parameters. Parameters: pen' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillEllipse,The method has 5 parameters. Parameters: brush' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The method has 7 parameters. Parameters: pen' x' y' width' height' startAngle' sweepAngle
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillPie,The method has 7 parameters. Parameters: brush' x' y' width' height' startAngle' sweepAngle
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawImage,The method has 5 parameters. Parameters: image' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawText,The method has 5 parameters. Parameters: font' brush' x' y' text
Long Parameter List,Eto.WinForms.Drawing,IconHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IconHandler.cs,DrawImage,The method has 5 parameters. Parameters: graphics' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,IndexedBitmapDataHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IndexedBitmapHandler.cs,IndexedBitmapDataHandler,The method has 5 parameters. Parameters: image' data' scanWidth' bitsPerPixel' controlObject
Long Parameter List,Eto.WinForms.Drawing,IndexedBitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IndexedBitmapHandler.cs,DrawImage,The method has 5 parameters. Parameters: graphics' x' y' width' height
Long Parameter List,Eto.WinForms.Drawing,GraphicsPathHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsPathHandler.cs,AddArc,The method has 6 parameters. Parameters: x' y' width' height' startAngle' sweepAngle
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,GetFormattedValue,The method has 6 parameters. Parameters: value' rowIndex' cellStyle' valueTypeConverter' formattedValueTypeConverter' context
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,GetFormattedValue,The method has 6 parameters. Parameters: value' rowIndex' cellStyle' valueTypeConverter' formattedValueTypeConverter' context
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The method has 9 parameters. Parameters: setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow
Long Parameter List,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,ICellConfigHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Cells,CellHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CellHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Controls,IGridHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,Paint,The method has 12 parameters. Parameters: column' graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Controls,GridHandler<TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,Paint,The method has 12 parameters. Parameters: column' graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Controls,GridColumnHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridColumnHandler.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The method has 12 parameters. Parameters: column' graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,Eto.WinForms.Forms.Controls,WebViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\WebViewHandler.cs,WebBrowserV1_NewWindow,The method has 6 parameters. Parameters: url' flags' targetFrameName' postData' headers' processed
Long Parameter List,ImageManipulation,Quantizer,C:\repos\picoe_Eto\Source\Eto.WinForms\Quantizer.cs,SecondPass,The method has 5 parameters. Parameters: sourceData' output' width' height' bounds
Long Parameter List,Eto.WinForms.IO,Shell32,C:\repos\picoe_Eto\Source\Eto.WinForms\IO\ShellIcon.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' psfi' cbFileInfo' uFlags
Long Parameter List,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,BaseBitmapData,The method has 5 parameters. Parameters: image' data' scanWidth' bitsPerPixel' controlObject
Long Statement,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,GetPerpendicular,The length of the statement  "			var k = ((l1end.Y - l1start.Y) * (l2start.X - l1start.X) - (l1end.X - l1start.X) * (l2start.Y - l1start.Y)) / (Math.Pow(l1end.Y - l1start.Y' 2) + Math.Pow(l1end.X - l1start.X' 2)); " is 180.
Long Statement,Eto.WinForms.Forms,VistaSelectFolderDialogHandler,C:\repos\picoe_Eto\Source\Eto.Wpf\Forms\VistaSelectFolderDialogHandler.cs,ShowDialog,The length of the statement  "			// use reflection since adding a parameter requires us to reference PresentationFramework which we don't want in winforms " is 121.
Long Statement,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,SetOptions,The length of the statement  "				bubble.AddBubbleMouseEvents((c' cb' e) => cb.OnMouseDown(c' e)' true' Win32.WM.LBUTTONDOWN' Win32.WM.RBUTTONDOWN' Win32.WM.MBUTTONDOWN); " is 136.
Long Statement,Eto.WinForms.Forms,DialogHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\DialogHandler.cs,AddButton,The length of the statement  "            panelButtons.ColumnStyles.Add(new swf.ColumnStyle(swf.SizeType.Absolute' button.Width > 0 ? button.Width : Controls.ButtonHandler.DefaultMinimumSize.Width)); " is 157.
Long Statement,Eto.WinForms.Forms,MessageBoxHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\MessageBoxHandler.cs,ShowDialog,The length of the statement  "			swf.DialogResult result = swf.MessageBox.Show(c' Text' caption' Convert(Buttons)' Convert(Type)' Convert(DefaultButton' Buttons)); " is 130.
Long Statement,Eto.WinForms.Forms,TableLayoutHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,OnLoad,The length of the statement  "            SetMinimumSize(useCache: true); // when created during pre-load' we need this to ensure the scale is set on the children properly " is 129.
Long Statement,Eto.WinForms.Forms,WindowsContainer<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsContainer.cs,SuspendLayout,The length of the statement  "				Widget.Properties[restoreRedrawKey] = (int)Win32.SendMessage(Control.Handle' Win32.WM.SETREDRAW' IntPtr.Zero' IntPtr.Zero) == 0; " is 128.
Long Statement,Eto.WinForms.Forms,WindowsPanel<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsPanel.cs,GetPreferredSize,The length of the statement  "				var desiredContentSize = handler.GetPreferredSize(Size.Max(Size.Empty' availableSize - contentPadding)) + contentPadding; " is 121.
Long Statement,Eto.WinForms.Forms,WindowsControl<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsControl.cs,HandleControlMouseLeave,The length of the statement  "			Callback.OnMouseLeave(Widget' new MouseEventArgs(MouseButtons.None' swf.Control.ModifierKeys.ToEto()' swf.Control.MousePosition.ToEto())); " is 138.
Long Statement,Eto.WinForms.Forms,WindowsControl<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsControl.cs,HandleControlMouseEnter,The length of the statement  "			Callback.OnMouseEnter(Widget' new MouseEventArgs(MouseButtons.None' swf.Control.ModifierKeys.ToEto()' swf.Control.MousePosition.ToEto())); " is 138.
Long Statement,Eto.WinForms.Forms,WindowsControl<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsControl.cs,PointFromScreen,The length of the statement  "            return !Control.IsDisposed ? Control.PointToClient(point.ToSDPoint()).ToEto() : PointF.Empty; // safety check added because this is hit in certain situations. " is 158.
Long Statement,Eto.WinForms.Forms,WindowsControl<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsControl.cs,PointToScreen,The length of the statement  "			return !Control.IsDisposed ? Control.PointToScreen(point.ToSDPoint()).ToEto() : PointF.Empty; // safety check added because this is hit in certain situations. " is 158.
Long Statement,Eto.WinForms.Drawing,BrushObject,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\RadialGradientBrushHandler.cs,GetBrush,The length of the statement  "					var scaledRect = new RectangleF(GradientOrigin - (GradientOrigin - Center + Radius) * scale' GradientOrigin + (Center + Radius - GradientOrigin) * scale); " is 154.
Long Statement,Eto.WinForms.Drawing,MatrixHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\MatrixHandler.cs,Skew,The length of the statement  "			var m = new sd2.Matrix(1' (float)Math.Tan(Conversions.DegreesToRadians(skewX))' (float)Math.Tan(Conversions.DegreesToRadians(skewY))' 1' 0' 0); " is 143.
Long Statement,Eto.WinForms.Drawing,BitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,Create,The length of the statement  "					throw new ArgumentOutOfRangeException("pixelFormat"' pixelFormat' string.Format(CultureInfo.CurrentCulture' "Not supported")); " is 126.
Long Statement,Eto.WinForms.Drawing,BitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,Lock,The length of the statement  "			sdi.BitmapData bd = Control.LockBits(new sd.Rectangle(0' 0' Control.Width' Control.Height)' sdi.ImageLockMode.ReadWrite' Control.PixelFormat); " is 142.
Long Statement,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawText,The length of the statement  "				swf.TextRenderer.DrawText(Control' text' (sd.Font)font.ControlObject' new sd.Point((int)x' (int)y)' brush.Color.ToSD()' DefaultTextFormat); " is 139.
Long Statement,Eto.WinForms.Drawing,IndexedBitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IndexedBitmapHandler.cs,Create,The length of the statement  "					throw new ArgumentOutOfRangeException("bitsPerPixel"' bitsPerPixel' string.Format(CultureInfo.CurrentCulture' "Not supported")); " is 128.
Long Statement,Eto.WinForms.Drawing,IndexedBitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IndexedBitmapHandler.cs,Lock,The length of the statement  "			SD.Imaging.BitmapData bd = Control.LockBits(new SD.Rectangle(0' 0' Control.Width' Control.Height)' SD.Imaging.ImageLockMode.ReadWrite' Control.PixelFormat); " is 156.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				var color = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor); " is 142.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				Handler.Paint(graphics' clipBounds' ref cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 158.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				base.Paint(graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts); " is 147.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,GetFormattedValue,The length of the statement  "				return base.GetFormattedValue((val != null) ? val[1] : null' rowIndex' ref cellStyle' valueTypeConverter' formattedValueTypeConverter' context); " is 144.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				Handler.Paint(graphics' clipBounds' ref cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 155.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "						using (var b = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor)) " is 145.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "						using (var background = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor)) " is 154.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "					graphics.DrawImage(img' new sd.Rectangle(cellBounds.X + IconPadding' cellBounds.Y + (cellBounds.Height - Math.Min(img.Height' cellBounds.Height)) / 2' IconSize' IconSize)); " is 172.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				base.Paint(graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts); " is 144.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				Handler.Paint(graphics' clipBounds' ref cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 155.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				base.Paint(graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts); " is 144.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				Handler.Paint(graphics' clipBounds' ref cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 158.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				base.Paint(graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts); " is 147.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "				base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				Handler.Paint(graphics' clipBounds' ref cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 158.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "				base.Paint(graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts); " is 147.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The length of the statement  "                base.PositionEditingControl(setLocation' setSize' cellBounds' cellClip' cellStyle' singleVerticalBorderAdded' singleHorizontalBorderAdded' isFirstDisplayedColumn' isFirstDisplayedRow); " is 184.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "                Handler.Paint(graphics' clipBounds' ref cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 158.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "                base.Paint(graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts); " is 147.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "                sd.Rectangle paintRect = new sd.Rectangle(cellBounds.X + 1' cellBounds.Y + 2' cellBounds.Width - 2' cellBounds.Height - 4); " is 123.
Long Statement,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The length of the statement  "                swf.TextRenderer.DrawText(graphics' progress' cellStyle.Font' paintRect' cellStyle.ForeColor' swf.TextFormatFlags.HorizontalCenter | swf.TextFormatFlags.VerticalCenter); " is 169.
Long Statement,Eto.WinForms.Forms.Cells,CellHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CellHandler.cs,Paint,The length of the statement  "				CellConfig.Paint (graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 155.
Long Statement,Eto.WinForms.Forms.Controls,GridHandler<TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,AttachEvent,The length of the statement  "					Control.ColumnHeaderMouseClick += (sender' e) => Callback.OnColumnHeaderClick(Widget' new GridColumnEventArgs(Widget.Columns[e.ColumnIndex])); " is 142.
Long Statement,Eto.WinForms.Forms.Controls,GridHandler<TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,AttachEvent,The length of the statement  "						Callback.OnCellClick(Widget' new GridCellMouseEventArgs(column' e.RowIndex' e.ColumnIndex' item' e.Button.ToEto()' swf.Control.ModifierKeys.ToEto()' location' e.ToEtoDelta())); " is 176.
Long Statement,Eto.WinForms.Forms.Controls,GridHandler<TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,AttachEvent,The length of the statement  "							Callback.OnCellDoubleClick(Widget' new GridCellMouseEventArgs(column' e.RowIndex' e.ColumnIndex' item' e.Button.ToEto()' swf.Control.ModifierKeys.ToEto()' location' e.ToEtoDelta())); " is 182.
Long Statement,Eto.WinForms.Forms.Controls,GridColumnHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridColumnHandler.cs,Paint,The length of the statement  "				GridHandler.Paint (this' graphics' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' ref paintParts); " is 162.
Long Statement,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The length of the statement  "								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2); " is 135.
Long Statement,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The length of the statement  "								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2); " is 135.
Long Statement,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The length of the statement  "								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2); " is 135.
Long Statement,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The length of the statement  "								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2); " is 135.
Long Statement,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The length of the statement  "								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2); " is 135.
Long Statement,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The length of the statement  "								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2); " is 135.
Long Statement,Eto.WinForms.Forms.Controls,TreeViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeViewHandler.cs,AttachEvent,The length of the statement  "					Control.NodeMouseClick += (s' e) => Callback.OnNodeMouseClick(Widget' new TreeViewItemEventArgs(e.Node.Tag as ITreeItem)); " is 122.
Long Statement,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnDrawItem,The length of the statement  "				var image = handler.Widget.ItemImageBinding?.GetValue(item).ToSD(new Size(bounds.Width' bounds.Height - ItemPadding * 2)); " is 122.
Long Statement,Eto.WinForms.Forms.Controls,EtoNumericUpDown,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\NumericStepperHandler.cs,UpdateValue,The length of the statement  "							text = Regex.Replace(text' $@"(?!\d|{Regex.Escape(h.CultureInfo.NumberFormat.NumberDecimalSeparator)}|{Regex.Escape(h.CultureInfo.NumberFormat.NegativeSign)})."' ""); // strip any non-numeric value " is 197.
Long Statement,Eto.WinForms.Forms.Controls,EtoNumericUpDown,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\NumericStepperHandler.cs,UpdateValue,The length of the statement  "							if (h.HasFormatString && result > 0 && NumberStringsMatch((-result).ToString(h.ComputedFormatString' h.CultureInfo)' Text)) " is 123.
Long Statement,Eto.WinForms.Forms.Controls,TextBoxHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TextBoxHandler.cs,Control_MouseUp,The length of the statement  "			if (ShouldSelect && AutoSelectMode == AutoSelectMode.Always && e.Button == swf.MouseButtons.Left && SwfTextBox.SelectionLength == 0) " is 132.
Long Statement,Eto.WinForms.Forms.Controls,WebViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\WebViewHandler.cs,AttachEvent,The length of the statement  "					Control.DocumentTitleChanged += (sender' e) => Callback.OnDocumentTitleChanged(Widget' new WebViewTitleEventArgs(Control.DocumentTitle)); " is 137.
Long Statement,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,UpdateSegments,The length of the statement  "					var strSize = swf.TextRenderer.MeasureText(ch.ToString(CultureInfo.InvariantCulture)' Font' sd.Size.Empty' RenderTextFormat); " is 125.
Long Statement,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The length of the statement  "				swf.CheckBoxRenderer.DrawCheckBox(g' new sd.Point(checkOffset' (ClientRectangle.Height - checkSize.Height) / 2)' checkState); " is 125.
Long Statement,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The length of the statement  "							g.FillRectangle(highlightBgBrush' new sd.RectangleF(textRect.X + segment.Start' textRect.Y' segment.Width' textRect.Height)); " is 125.
Long Statement,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The length of the statement  "				swf.TextRenderer.DrawText(g' str' font' new sd.Rectangle((int)(textRect.X + segment.Start)' textRect.Y' segment.Width' textRect.Height)' textColor' RenderTextFormat); " is 166.
Long Statement,Eto.WinForms.Forms.Printing,PrintSettingsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Printing\PrintSettingsHandler.cs,DefaultSettings,The length of the statement  "			return new sdp.PrinterSettings { MinimumPage = 1' MaximumPage = 1' FromPage = 1' ToPage = 1' Copies = 1' Collate = true }; " is 122.
Long Statement,Eto.WinForms.Forms.ToolBar,RadioToolItemHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ToolBar\RadioToolItemHandler.cs,control_Click,The length of the statement  "				foreach (var button in parent.Items.OfType<SWF.ToolStripButton>().Select(r => r.Tag).OfType<RadioToolItemHandler>().Where(r => r != this)) " is 138.
Long Statement,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,GetPixel,The length of the statement  "			throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture' "This PixelFormat is not supported by GetPixel. Must be 24 or 32 bits per pixel' or 8 bit indexed")); " is 175.
Long Statement,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,SetPixel,The length of the statement  "				throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture' "This PixelFormat is not supported by SetPixel. Must be 3 or 4 bytes per pixel")); " is 156.
Complex Conditional,Eto.WinForms.Forms,EtoTableLayoutPanel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,GetMinSize,The conditional expression  "columnScale == null || rowScale == null || !Handler.Widget.Loaded || !IsHandleCreated"  is complex.
Complex Conditional,Eto.WinForms.Forms,WindowHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowHandler.cs,AttachEvent,The conditional expression  "!e.Cancel && swf.Application.OpenForms.Count <= 1  						    || e.CloseReason == swf.CloseReason.ApplicationExitCall  						    || e.CloseReason == swf.CloseReason.WindowsShutDown"  is complex.
Complex Conditional,Eto.WinForms.Drawing,BitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,Create,The conditional expression  "pixelFormat == sdi.PixelFormat.Indexed  				|| pixelFormat == sdi.PixelFormat.Format1bppIndexed  				|| pixelFormat == sdi.PixelFormat.Format4bppIndexed  				|| pixelFormat == sdi.PixelFormat.Format8bppIndexed"  is complex.
Complex Conditional,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnPaint,The conditional expression  "(SelectionMode == swf.SelectionMode.One && SelectedIndex == i)  						|| (SelectionMode == swf.SelectionMode.MultiSimple && SelectedIndices.Contains(i))  						|| (SelectionMode == swf.SelectionMode.MultiExtended && SelectedIndices.Contains(i))"  is complex.
Complex Conditional,Eto.WinForms.Forms.Controls,TextBoxHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TextBoxHandler.cs,Control_MouseUp,The conditional expression  "ShouldSelect && AutoSelectMode == AutoSelectMode.Always && e.Button == swf.MouseButtons.Left && SwfTextBox.SelectionLength == 0"  is complex.
Complex Conditional,Eto.WinForms.Forms.Controls,TextBoxHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TextBoxHandler.cs,Control_GotFocus,The conditional expression  "ShouldSelect && Mouse.Buttons == MouseButtons.None  				&& (AutoSelectMode == AutoSelectMode.OnFocus || AutoSelectMode == AutoSelectMode.Always)"  is complex.
Complex Conditional,Eto.WinForms.Forms.Controls,GridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridViewHandler.cs,GetItemAtRow,The conditional expression  "row >= 0 && collection != null && collection.Collection != null && collection.Count > row"  is complex.
Empty Catch Block,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,ApplicationHandler,The method has an empty catch block.
Empty Catch Block,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The method has an empty catch block.
Empty Catch Block,Eto.WinForms.Forms.Controls,DrawableHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DrawableHandler.cs,SetContent,The method has an empty catch block.
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: var header = new byte[40];
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: var width = BitConverter.ToInt32(header' 4);
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: var height = BitConverter.ToInt32(header' 8);
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: var bpp = BitConverter.ToInt16(header' 14);
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: var compression = BitConverter.ToInt32(header' 16);
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: if (bpp != 32)  				return null;
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: if (compression == 3) // BI_BITFIELDS  			{  				// three dwords' each specifies the bits each RGB components takes  				// we require each takes one byte  				var segments = new byte[sizeof(int) * 3];  				ms.Read(segments' 0' segments.Length);  				var rcomp = BitConverter.ToInt32(segments' 0);  				var gcomp = BitConverter.ToInt32(segments' 4);  				var bcomp = BitConverter.ToInt32(segments' 8);  				if (rcomp != 0xFF0000 || gcomp != 0xFF00 || bcomp != 0xFF)  					return null;  			}  			else if (compression != 0) // BI_RGB  				return null;
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: if (compression == 3) // BI_BITFIELDS  			{  				// three dwords' each specifies the bits each RGB components takes  				// we require each takes one byte  				var segments = new byte[sizeof(int) * 3];  				ms.Read(segments' 0' segments.Length);  				var rcomp = BitConverter.ToInt32(segments' 0);  				var gcomp = BitConverter.ToInt32(segments' 4);  				var bcomp = BitConverter.ToInt32(segments' 8);  				if (rcomp != 0xFF0000 || gcomp != 0xFF00 || bcomp != 0xFF)  					return null;  			}  			else if (compression != 0) // BI_RGB  				return null;
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: if (compression == 3) // BI_BITFIELDS  			{  				// three dwords' each specifies the bits each RGB components takes  				// we require each takes one byte  				var segments = new byte[sizeof(int) * 3];  				ms.Read(segments' 0' segments.Length);  				var rcomp = BitConverter.ToInt32(segments' 0);  				var gcomp = BitConverter.ToInt32(segments' 4);  				var bcomp = BitConverter.ToInt32(segments' 8);  				if (rcomp != 0xFF0000 || gcomp != 0xFF00 || bcomp != 0xFF)  					return null;  			}  			else if (compression != 0) // BI_RGB  				return null;
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,FromDIB,The following statement contains a magic number: if (compression == 3) // BI_BITFIELDS  			{  				// three dwords' each specifies the bits each RGB components takes  				// we require each takes one byte  				var segments = new byte[sizeof(int) * 3];  				ms.Read(segments' 0' segments.Length);  				var rcomp = BitConverter.ToInt32(segments' 0);  				var gcomp = BitConverter.ToInt32(segments' 4);  				var bcomp = BitConverter.ToInt32(segments' 8);  				if (rcomp != 0xFF0000 || gcomp != 0xFF00 || bcomp != 0xFF)  					return null;  			}  			else if (compression != 0) // BI_RGB  				return null;
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ToDIB,The following statement contains a magic number: using (var bd = bitmap.Lock())  			{  				if (bd.BytesPerPixel == 4 || bd.BytesPerPixel == 3) // only 32bpp or 24bpp supported  				{  					var ms = new MemoryStream(bitmap.Width * bitmap.Height * bd.BytesPerPixel + 40);  					// write BITMAPINFOHEADER  					const float InchesPerMeter = 39.37f;  					var pelsPerMeter = Math.Round(dpi * InchesPerMeter); // convert dpi to ppm  					Write(ms' BitConverter.GetBytes((uint)40));  // biSize  					Write(ms' BitConverter.GetBytes((uint)bitmap.Width)); // biWidth  					Write(ms' BitConverter.GetBytes((uint)bitmap.Height));// biHeight  					Write(ms' BitConverter.GetBytes((ushort)1));  // biPlanes  					Write(ms' BitConverter.GetBytes((ushort)bd.BitsPerPixel)); // biBitCount  					Write(ms' BitConverter.GetBytes((uint)0));    //  biCompression (BI_RGB' uncompressed)  					Write(ms' BitConverter.GetBytes((uint)0));    //  biSizeImage  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biXPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biYPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrUsed  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrImportant    					var hasAlpha = bd.BytesPerPixel == 4;  					// write RGB data' dibs are flipped vertically  					for (int y = bitmap.Height - 1; y >= 0; y--)  					{  						for (int x = 0; x < bitmap.Width; x++)  						{  							var p = bd.GetPixel(x' y);  							// need to write RGB premultiplied by alpha (and round up)  							ms.WriteByte((byte)(p.B * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.G * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.R * p.A * 255f + .5f));  							if (hasAlpha)  								ms.WriteByte((byte)p.Ab);  						}  					}    					ms.Position = 0;  					return ms;  				}  			}
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ToDIB,The following statement contains a magic number: using (var bd = bitmap.Lock())  			{  				if (bd.BytesPerPixel == 4 || bd.BytesPerPixel == 3) // only 32bpp or 24bpp supported  				{  					var ms = new MemoryStream(bitmap.Width * bitmap.Height * bd.BytesPerPixel + 40);  					// write BITMAPINFOHEADER  					const float InchesPerMeter = 39.37f;  					var pelsPerMeter = Math.Round(dpi * InchesPerMeter); // convert dpi to ppm  					Write(ms' BitConverter.GetBytes((uint)40));  // biSize  					Write(ms' BitConverter.GetBytes((uint)bitmap.Width)); // biWidth  					Write(ms' BitConverter.GetBytes((uint)bitmap.Height));// biHeight  					Write(ms' BitConverter.GetBytes((ushort)1));  // biPlanes  					Write(ms' BitConverter.GetBytes((ushort)bd.BitsPerPixel)); // biBitCount  					Write(ms' BitConverter.GetBytes((uint)0));    //  biCompression (BI_RGB' uncompressed)  					Write(ms' BitConverter.GetBytes((uint)0));    //  biSizeImage  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biXPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biYPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrUsed  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrImportant    					var hasAlpha = bd.BytesPerPixel == 4;  					// write RGB data' dibs are flipped vertically  					for (int y = bitmap.Height - 1; y >= 0; y--)  					{  						for (int x = 0; x < bitmap.Width; x++)  						{  							var p = bd.GetPixel(x' y);  							// need to write RGB premultiplied by alpha (and round up)  							ms.WriteByte((byte)(p.B * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.G * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.R * p.A * 255f + .5f));  							if (hasAlpha)  								ms.WriteByte((byte)p.Ab);  						}  					}    					ms.Position = 0;  					return ms;  				}  			}
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ToDIB,The following statement contains a magic number: using (var bd = bitmap.Lock())  			{  				if (bd.BytesPerPixel == 4 || bd.BytesPerPixel == 3) // only 32bpp or 24bpp supported  				{  					var ms = new MemoryStream(bitmap.Width * bitmap.Height * bd.BytesPerPixel + 40);  					// write BITMAPINFOHEADER  					const float InchesPerMeter = 39.37f;  					var pelsPerMeter = Math.Round(dpi * InchesPerMeter); // convert dpi to ppm  					Write(ms' BitConverter.GetBytes((uint)40));  // biSize  					Write(ms' BitConverter.GetBytes((uint)bitmap.Width)); // biWidth  					Write(ms' BitConverter.GetBytes((uint)bitmap.Height));// biHeight  					Write(ms' BitConverter.GetBytes((ushort)1));  // biPlanes  					Write(ms' BitConverter.GetBytes((ushort)bd.BitsPerPixel)); // biBitCount  					Write(ms' BitConverter.GetBytes((uint)0));    //  biCompression (BI_RGB' uncompressed)  					Write(ms' BitConverter.GetBytes((uint)0));    //  biSizeImage  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biXPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biYPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrUsed  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrImportant    					var hasAlpha = bd.BytesPerPixel == 4;  					// write RGB data' dibs are flipped vertically  					for (int y = bitmap.Height - 1; y >= 0; y--)  					{  						for (int x = 0; x < bitmap.Width; x++)  						{  							var p = bd.GetPixel(x' y);  							// need to write RGB premultiplied by alpha (and round up)  							ms.WriteByte((byte)(p.B * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.G * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.R * p.A * 255f + .5f));  							if (hasAlpha)  								ms.WriteByte((byte)p.Ab);  						}  					}    					ms.Position = 0;  					return ms;  				}  			}
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ToDIB,The following statement contains a magic number: using (var bd = bitmap.Lock())  			{  				if (bd.BytesPerPixel == 4 || bd.BytesPerPixel == 3) // only 32bpp or 24bpp supported  				{  					var ms = new MemoryStream(bitmap.Width * bitmap.Height * bd.BytesPerPixel + 40);  					// write BITMAPINFOHEADER  					const float InchesPerMeter = 39.37f;  					var pelsPerMeter = Math.Round(dpi * InchesPerMeter); // convert dpi to ppm  					Write(ms' BitConverter.GetBytes((uint)40));  // biSize  					Write(ms' BitConverter.GetBytes((uint)bitmap.Width)); // biWidth  					Write(ms' BitConverter.GetBytes((uint)bitmap.Height));// biHeight  					Write(ms' BitConverter.GetBytes((ushort)1));  // biPlanes  					Write(ms' BitConverter.GetBytes((ushort)bd.BitsPerPixel)); // biBitCount  					Write(ms' BitConverter.GetBytes((uint)0));    //  biCompression (BI_RGB' uncompressed)  					Write(ms' BitConverter.GetBytes((uint)0));    //  biSizeImage  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biXPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biYPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrUsed  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrImportant    					var hasAlpha = bd.BytesPerPixel == 4;  					// write RGB data' dibs are flipped vertically  					for (int y = bitmap.Height - 1; y >= 0; y--)  					{  						for (int x = 0; x < bitmap.Width; x++)  						{  							var p = bd.GetPixel(x' y);  							// need to write RGB premultiplied by alpha (and round up)  							ms.WriteByte((byte)(p.B * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.G * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.R * p.A * 255f + .5f));  							if (hasAlpha)  								ms.WriteByte((byte)p.Ab);  						}  					}    					ms.Position = 0;  					return ms;  				}  			}
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ToDIB,The following statement contains a magic number: using (var bd = bitmap.Lock())  			{  				if (bd.BytesPerPixel == 4 || bd.BytesPerPixel == 3) // only 32bpp or 24bpp supported  				{  					var ms = new MemoryStream(bitmap.Width * bitmap.Height * bd.BytesPerPixel + 40);  					// write BITMAPINFOHEADER  					const float InchesPerMeter = 39.37f;  					var pelsPerMeter = Math.Round(dpi * InchesPerMeter); // convert dpi to ppm  					Write(ms' BitConverter.GetBytes((uint)40));  // biSize  					Write(ms' BitConverter.GetBytes((uint)bitmap.Width)); // biWidth  					Write(ms' BitConverter.GetBytes((uint)bitmap.Height));// biHeight  					Write(ms' BitConverter.GetBytes((ushort)1));  // biPlanes  					Write(ms' BitConverter.GetBytes((ushort)bd.BitsPerPixel)); // biBitCount  					Write(ms' BitConverter.GetBytes((uint)0));    //  biCompression (BI_RGB' uncompressed)  					Write(ms' BitConverter.GetBytes((uint)0));    //  biSizeImage  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biXPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)pelsPerMeter)); //  biYPelsPerMeter  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrUsed  					Write(ms' BitConverter.GetBytes((uint)0));    //  biClrImportant    					var hasAlpha = bd.BytesPerPixel == 4;  					// write RGB data' dibs are flipped vertically  					for (int y = bitmap.Height - 1; y >= 0; y--)  					{  						for (int x = 0; x < bitmap.Width; x++)  						{  							var p = bd.GetPixel(x' y);  							// need to write RGB premultiplied by alpha (and round up)  							ms.WriteByte((byte)(p.B * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.G * p.A * 255f + .5f));  							ms.WriteByte((byte)(p.R * p.A * 255f + .5f));  							if (hasAlpha)  								ms.WriteByte((byte)p.Ab);  						}  					}    					ms.Position = 0;  					return ms;  				}  			}
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ScreenToLogical,The following statement contains a magic number: var screen = swf.Screen.FromPoint(new sd.Point(rect.X + rect.Width / 2' rect.Y + rect.Height / 2));
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,ScreenToLogical,The following statement contains a magic number: var screen = swf.Screen.FromPoint(new sd.Point(rect.X + rect.Width / 2' rect.Y + rect.Height / 2));
Magic Number,Eto,Win32,C:\repos\picoe_Eto\Source\Eto.Wpf\Win32.dib.cs,SignedHIWORD,The following statement contains a magic number: return (short)((n >> 16) & 0xFFFF);
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,GetPerpendicular,The following statement contains a magic number: var k = ((l1end.Y - l1start.Y) * (l2start.X - l1start.X) - (l1end.X - l1start.X) * (l2start.Y - l1start.Y)) / (Math.Pow(l1end.Y - l1start.Y' 2) + Math.Pow(l1end.X - l1start.X' 2));
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,GetPerpendicular,The following statement contains a magic number: var k = ((l1end.Y - l1start.Y) * (l2start.X - l1start.X) - (l1end.X - l1start.X) * (l2start.Y - l1start.Y)) / (Math.Pow(l1end.Y - l1start.Y' 2) + Math.Pow(l1end.X - l1start.X' 2));
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,FindEllipseIntersection,The following statement contains a magic number: var b = 2 * start.X * (end.X - start.X) / rx / rx + 2 * start.Y * (end.Y - start.Y) / ry / ry;
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,FindEllipseIntersection,The following statement contains a magic number: var b = 2 * start.X * (end.X - start.X) / rx / rx + 2 * start.Y * (end.Y - start.Y) / ry / ry;
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,FindEllipseIntersection,The following statement contains a magic number: float discriminant = b * b - 4 * a * c;
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,FindEllipseIntersection,The following statement contains a magic number: if (Math.Abs(discriminant) < float.Epsilon)  			{  				t = -b / 2 / a;  			}  			else if (discriminant > 0)  			{  				// Two possible values  				var t1 = (float)((-b + Math.Sqrt(discriminant)) / 2 / a);  				var t2 = (float)((-b - Math.Sqrt(discriminant)) / 2 / a);  				if (t1 < 0f || t1 > 1f)  					t = t2;  				else if (t2 < 0f || t2 > 1f)  					t = t1;  				else  					t = Math.Max(t1' t2);  			}  			else  				return null;
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,FindEllipseIntersection,The following statement contains a magic number: if (Math.Abs(discriminant) < float.Epsilon)  			{  				t = -b / 2 / a;  			}  			else if (discriminant > 0)  			{  				// Two possible values  				var t1 = (float)((-b + Math.Sqrt(discriminant)) / 2 / a);  				var t2 = (float)((-b - Math.Sqrt(discriminant)) / 2 / a);  				if (t1 < 0f || t1 > 1f)  					t = t2;  				else if (t2 < 0f || t2 > 1f)  					t = t1;  				else  					t = Math.Max(t1' t2);  			}  			else  				return null;
Magic Number,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,FindEllipseIntersection,The following statement contains a magic number: if (Math.Abs(discriminant) < float.Epsilon)  			{  				t = -b / 2 / a;  			}  			else if (discriminant > 0)  			{  				// Two possible values  				var t1 = (float)((-b + Math.Sqrt(discriminant)) / 2 / a);  				var t2 = (float)((-b - Math.Sqrt(discriminant)) / 2 / a);  				if (t1 < 0f || t1 > 1f)  					t = t2;  				else if (t2 < 0f || t2 > 1f)  					t = t1;  				else  					t = Math.Max(t1' t2);  			}  			else  				return null;
Magic Number,Eto.CustomControls,HttpServer,C:\repos\picoe_Eto\Source\Eto.Wpf\CustomControls\HttpServer.cs,HttpServer,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				int currentPort = rnd.Next (49152' 65536);    				try {  					listener = new HttpListener ();  					listener.Prefixes.Add ("http://localhost:" + currentPort + "/");  					listener.Start ();    					this.port = currentPort;  					listener.BeginGetContext (ListenerCallback' null);  					return;  				}  				catch (Exception x) {  					listener.Close ();  					Debug.WriteLine ("HttpListener.Start:\n" + x);  				}  			}
Magic Number,Eto.CustomControls,HttpServer,C:\repos\picoe_Eto\Source\Eto.Wpf\CustomControls\HttpServer.cs,HttpServer,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				int currentPort = rnd.Next (49152' 65536);    				try {  					listener = new HttpListener ();  					listener.Prefixes.Add ("http://localhost:" + currentPort + "/");  					listener.Start ();    					this.port = currentPort;  					listener.BeginGetContext (ListenerCallback' null);  					return;  				}  				catch (Exception x) {  					listener.Close ();  					Debug.WriteLine ("HttpListener.Start:\n" + x);  				}  			}
Magic Number,Eto.CustomControls,HttpServer,C:\repos\picoe_Eto\Source\Eto.Wpf\CustomControls\HttpServer.cs,HttpServer,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				int currentPort = rnd.Next (49152' 65536);    				try {  					listener = new HttpListener ();  					listener.Prefixes.Add ("http://localhost:" + currentPort + "/");  					listener.Start ();    					this.port = currentPort;  					listener.BeginGetContext (ListenerCallback' null);  					return;  				}  				catch (Exception x) {  					listener.Close ();  					Debug.WriteLine ("HttpListener.Start:\n" + x);  				}  			}
Magic Number,Eto.WinForms.Forms,NotificationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\NotificationHandler.cs,Show,The following statement contains a magic number: if (indicator != null)  			{  				var tray = indicator.ControlObject as Swf.NotifyIcon;  				tray.ShowBalloonTip(3000' Title' Message' Swf.ToolTipIcon.None);  				tray.BalloonTipClicked += Tray_BalloonTipClicked;  			}
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: var font = new sd.Font(sd.FontFamily.GenericSansSerif' 9' sd.FontStyle.Bold' sd.GraphicsUnit.Pixel);
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: graphics.FillEllipse(sd.Brushes.Red' new sd.Rectangle(0' 0' 16' 16));
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: graphics.FillEllipse(sd.Brushes.Red' new sd.Rectangle(0' 0' 16' 16));
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: graphics.DrawEllipse(new sd.Pen(sd.Brushes.White' 2)' new sd.Rectangle(0' 0' 15' 15));
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: graphics.DrawEllipse(new sd.Pen(sd.Brushes.White' 2)' new sd.Rectangle(0' 0' 15' 15));
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: graphics.DrawEllipse(new sd.Pen(sd.Brushes.White' 2)' new sd.Rectangle(0' 0' 15' 15));
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: var pt = new sd.PointF((bmp.Width - size.Width - 0.5F) / 2' (bmp.Height - size.Height - 1) / 2);
Magic Number,Eto.WinForms.Forms,ApplicationHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ApplicationHandler.cs,DrawBadgeLabel,The following statement contains a magic number: var pt = new sd.PointF((bmp.Width - size.Width - 0.5F) / 2' (bmp.Height - size.Height - 1) / 2);
Magic Number,Eto.WinForms.Forms,DialogHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\DialogHandler.cs,DialogHandler,The following statement contains a magic number: panelButtons.ColumnStyles.Add(new swf.ColumnStyle(swf.SizeType.Percent' 100));
Magic Number,Eto.WinForms.Forms,DialogHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\DialogHandler.cs,ReloadButtons,The following statement contains a magic number: if (negativeButtons.Count + positiveButtons.Count > 0 && height <= 0)                  height = Controls.ButtonHandler.DefaultMinimumSize.Height + 12;
Magic Number,Eto.WinForms.Forms,DialogHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\DialogHandler.cs,AddButton,The following statement contains a magic number: native.Margin = new swf.Padding(0' 6' 6' 3);
Magic Number,Eto.WinForms.Forms,DialogHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\DialogHandler.cs,AddButton,The following statement contains a magic number: native.Margin = new swf.Padding(0' 6' 6' 3);
Magic Number,Eto.WinForms.Forms,DialogHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\DialogHandler.cs,AddButton,The following statement contains a magic number: native.Margin = new swf.Padding(0' 6' 6' 3);
Magic Number,Eto.WinForms.Forms,TableLayoutHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,GetMargin,The following statement contains a magic number: if (x > 0) margin.Left = (int)Math.Floor(spacing.Width / 2.0);
Magic Number,Eto.WinForms.Forms,TableLayoutHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,GetMargin,The following statement contains a magic number: if (x < columnScale.Length - 1) margin.Right = (int)Math.Ceiling(spacing.Width / 2.0);
Magic Number,Eto.WinForms.Forms,TableLayoutHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,GetMargin,The following statement contains a magic number: if (y > 0) margin.Top = (int)Math.Floor(spacing.Height / 2.0);
Magic Number,Eto.WinForms.Forms,TableLayoutHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,GetMargin,The following statement contains a magic number: if (y < rowScale.Length - 1) margin.Bottom = (int)Math.Ceiling(spacing.Height / 2.0);
Magic Number,Eto.WinForms.Forms,EtoTableLayoutPanel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,OnBackColorChanged,The following statement contains a magic number: SetStyle  					( swf.ControlStyles.AllPaintingInWmPaint  					| swf.ControlStyles.DoubleBuffer  					' BackColor.A != 255 );
Magic Number,Eto.WinForms.Forms,EtoTableLayoutPanel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\TableLayoutHandler.cs,OnParentBackColorChanged,The following statement contains a magic number: SetStyle  					( swf.ControlStyles.AllPaintingInWmPaint  					| swf.ControlStyles.DoubleBuffer  					' BackColor.A != 255 );
Magic Number,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The following statement contains a magic number: if (swf.Clipboard.GetDataObject().GetDataPresent(swf.DataFormats.Dib))  			{  				var dib = ((System.IO.MemoryStream)swf.Clipboard.GetData(swf.DataFormats.Dib)).ToArray();    				var width = BitConverter.ToInt32(dib' 4);  				var height = BitConverter.ToInt32(dib' 8);  				var bpp = BitConverter.ToInt16(dib' 14);    				if (bpp == 32)  				{  					var gch = GCHandle.Alloc(dib' GCHandleType.Pinned);    					sd.Bitmap bmp = null;    					try  					{  						var ptr = new IntPtr((long)gch.AddrOfPinnedObject() + 40);    						bmp = new sd.Bitmap(width' height' width * 4' sdi.PixelFormat.Format32bppArgb' ptr);    						var result = new sd.Bitmap(bmp);    						// Images are rotated and flipped for some reason.  						// This rotates them back.  						result.RotateFlip(sd.RotateFlipType.Rotate180FlipX);    						return result;  					}  					finally  					{  						gch.Free();    						if (bmp != null)  							bmp.Dispose();  					}  				}  			}
Magic Number,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The following statement contains a magic number: if (swf.Clipboard.GetDataObject().GetDataPresent(swf.DataFormats.Dib))  			{  				var dib = ((System.IO.MemoryStream)swf.Clipboard.GetData(swf.DataFormats.Dib)).ToArray();    				var width = BitConverter.ToInt32(dib' 4);  				var height = BitConverter.ToInt32(dib' 8);  				var bpp = BitConverter.ToInt16(dib' 14);    				if (bpp == 32)  				{  					var gch = GCHandle.Alloc(dib' GCHandleType.Pinned);    					sd.Bitmap bmp = null;    					try  					{  						var ptr = new IntPtr((long)gch.AddrOfPinnedObject() + 40);    						bmp = new sd.Bitmap(width' height' width * 4' sdi.PixelFormat.Format32bppArgb' ptr);    						var result = new sd.Bitmap(bmp);    						// Images are rotated and flipped for some reason.  						// This rotates them back.  						result.RotateFlip(sd.RotateFlipType.Rotate180FlipX);    						return result;  					}  					finally  					{  						gch.Free();    						if (bmp != null)  							bmp.Dispose();  					}  				}  			}
Magic Number,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The following statement contains a magic number: if (swf.Clipboard.GetDataObject().GetDataPresent(swf.DataFormats.Dib))  			{  				var dib = ((System.IO.MemoryStream)swf.Clipboard.GetData(swf.DataFormats.Dib)).ToArray();    				var width = BitConverter.ToInt32(dib' 4);  				var height = BitConverter.ToInt32(dib' 8);  				var bpp = BitConverter.ToInt16(dib' 14);    				if (bpp == 32)  				{  					var gch = GCHandle.Alloc(dib' GCHandleType.Pinned);    					sd.Bitmap bmp = null;    					try  					{  						var ptr = new IntPtr((long)gch.AddrOfPinnedObject() + 40);    						bmp = new sd.Bitmap(width' height' width * 4' sdi.PixelFormat.Format32bppArgb' ptr);    						var result = new sd.Bitmap(bmp);    						// Images are rotated and flipped for some reason.  						// This rotates them back.  						result.RotateFlip(sd.RotateFlipType.Rotate180FlipX);    						return result;  					}  					finally  					{  						gch.Free();    						if (bmp != null)  							bmp.Dispose();  					}  				}  			}
Magic Number,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The following statement contains a magic number: if (swf.Clipboard.GetDataObject().GetDataPresent(swf.DataFormats.Dib))  			{  				var dib = ((System.IO.MemoryStream)swf.Clipboard.GetData(swf.DataFormats.Dib)).ToArray();    				var width = BitConverter.ToInt32(dib' 4);  				var height = BitConverter.ToInt32(dib' 8);  				var bpp = BitConverter.ToInt16(dib' 14);    				if (bpp == 32)  				{  					var gch = GCHandle.Alloc(dib' GCHandleType.Pinned);    					sd.Bitmap bmp = null;    					try  					{  						var ptr = new IntPtr((long)gch.AddrOfPinnedObject() + 40);    						bmp = new sd.Bitmap(width' height' width * 4' sdi.PixelFormat.Format32bppArgb' ptr);    						var result = new sd.Bitmap(bmp);    						// Images are rotated and flipped for some reason.  						// This rotates them back.  						result.RotateFlip(sd.RotateFlipType.Rotate180FlipX);    						return result;  					}  					finally  					{  						gch.Free();    						if (bmp != null)  							bmp.Dispose();  					}  				}  			}
Magic Number,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The following statement contains a magic number: if (swf.Clipboard.GetDataObject().GetDataPresent(swf.DataFormats.Dib))  			{  				var dib = ((System.IO.MemoryStream)swf.Clipboard.GetData(swf.DataFormats.Dib)).ToArray();    				var width = BitConverter.ToInt32(dib' 4);  				var height = BitConverter.ToInt32(dib' 8);  				var bpp = BitConverter.ToInt16(dib' 14);    				if (bpp == 32)  				{  					var gch = GCHandle.Alloc(dib' GCHandleType.Pinned);    					sd.Bitmap bmp = null;    					try  					{  						var ptr = new IntPtr((long)gch.AddrOfPinnedObject() + 40);    						bmp = new sd.Bitmap(width' height' width * 4' sdi.PixelFormat.Format32bppArgb' ptr);    						var result = new sd.Bitmap(bmp);    						// Images are rotated and flipped for some reason.  						// This rotates them back.  						result.RotateFlip(sd.RotateFlipType.Rotate180FlipX);    						return result;  					}  					finally  					{  						gch.Free();    						if (bmp != null)  							bmp.Dispose();  					}  				}  			}
Magic Number,Eto.WinForms.Forms,ClipboardHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\ClipboardHandler.cs,GetImageFromClipboard,The following statement contains a magic number: if (swf.Clipboard.GetDataObject().GetDataPresent(swf.DataFormats.Dib))  			{  				var dib = ((System.IO.MemoryStream)swf.Clipboard.GetData(swf.DataFormats.Dib)).ToArray();    				var width = BitConverter.ToInt32(dib' 4);  				var height = BitConverter.ToInt32(dib' 8);  				var bpp = BitConverter.ToInt16(dib' 14);    				if (bpp == 32)  				{  					var gch = GCHandle.Alloc(dib' GCHandleType.Pinned);    					sd.Bitmap bmp = null;    					try  					{  						var ptr = new IntPtr((long)gch.AddrOfPinnedObject() + 40);    						bmp = new sd.Bitmap(width' height' width * 4' sdi.PixelFormat.Format32bppArgb' ptr);    						var result = new sd.Bitmap(bmp);    						// Images are rotated and flipped for some reason.  						// This rotates them back.  						result.RotateFlip(sd.RotateFlipType.Rotate180FlipX);    						return result;  					}  					finally  					{  						gch.Free();    						if (bmp != null)  							bmp.Dispose();  					}  				}  			}
Magic Number,Eto.WinForms.Forms,EtoPanel<THandler>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsControl.cs,OnBackColorChanged,The following statement contains a magic number: SetStyle  					( swf.ControlStyles.AllPaintingInWmPaint  					| swf.ControlStyles.DoubleBuffer  					' BackColor.A != 255 );
Magic Number,Eto.WinForms.Forms,EtoPanel<THandler>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\WindowsControl.cs,OnParentBackColorChanged,The following statement contains a magic number: SetStyle  					( swf.ControlStyles.AllPaintingInWmPaint  					| swf.ControlStyles.DoubleBuffer  					' BackColor.A != 255 );
Magic Number,Eto.WinForms,BubbleEventFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\BubbleEventFilter.cs,IsInputChar,The following statement contains a magic number: int num = charCode == '\t' ? 134 : 132;
Magic Number,Eto.WinForms,BubbleEventFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\BubbleEventFilter.cs,IsInputChar,The following statement contains a magic number: int num = charCode == '\t' ? 134 : 132;
Magic Number,Eto.WinForms,BubbleEventFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\BubbleEventFilter.cs,IsInputKey,The following statement contains a magic number: int num = 4;
Magic Number,Eto.WinForms,BubbleEventFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\BubbleEventFilter.cs,IsInputKey,The following statement contains a magic number: switch (keyData & Keys.KeyMask)  			{  				case Keys.Tab:  					num = 6;  					break;  				case Keys.Left:  				case Keys.Up:  				case Keys.Right:  				case Keys.Down:  					num = 5;  					break;  			}
Magic Number,Eto.WinForms,BubbleEventFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\BubbleEventFilter.cs,IsInputKey,The following statement contains a magic number: switch (keyData & Keys.KeyMask)  			{  				case Keys.Tab:  					num = 6;  					break;  				case Keys.Left:  				case Keys.Up:  				case Keys.Right:  				case Keys.Down:  					num = 5;  					break;  			}
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,ToSD,The following statement contains a magic number: return sd.Color.FromArgb((byte)(color.A * 255)' (byte)(color.R * 255)' (byte)(color.G * 255)' (byte)(color.B * 255));
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,ToSD,The following statement contains a magic number: return sd.Color.FromArgb((byte)(color.A * 255)' (byte)(color.R * 255)' (byte)(color.G * 255)' (byte)(color.B * 255));
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,ToSD,The following statement contains a magic number: return sd.Color.FromArgb((byte)(color.A * 255)' (byte)(color.R * 255)' (byte)(color.G * 255)' (byte)(color.B * 255));
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,ToSD,The following statement contains a magic number: return sd.Color.FromArgb((byte)(color.A * 255)' (byte)(color.R * 255)' (byte)(color.G * 255)' (byte)(color.B * 255));
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,BitsPerPixel,The following statement contains a magic number: switch (format)  			{  				case sdi.PixelFormat.Format1bppIndexed:  					return 1;  				case sdi.PixelFormat.Format4bppIndexed:  					return 4;  				case sdi.PixelFormat.Format8bppIndexed:  					return 8;  				case sdi.PixelFormat.Format24bppRgb:  					return 24;  				case sdi.PixelFormat.Format32bppArgb:  				case sdi.PixelFormat.Format32bppPArgb:  				case sdi.PixelFormat.Format32bppRgb:  					return 32;  				default:  					throw new NotSupportedException();  			}
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,BitsPerPixel,The following statement contains a magic number: switch (format)  			{  				case sdi.PixelFormat.Format1bppIndexed:  					return 1;  				case sdi.PixelFormat.Format4bppIndexed:  					return 4;  				case sdi.PixelFormat.Format8bppIndexed:  					return 8;  				case sdi.PixelFormat.Format24bppRgb:  					return 24;  				case sdi.PixelFormat.Format32bppArgb:  				case sdi.PixelFormat.Format32bppPArgb:  				case sdi.PixelFormat.Format32bppRgb:  					return 32;  				default:  					throw new NotSupportedException();  			}
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,BitsPerPixel,The following statement contains a magic number: switch (format)  			{  				case sdi.PixelFormat.Format1bppIndexed:  					return 1;  				case sdi.PixelFormat.Format4bppIndexed:  					return 4;  				case sdi.PixelFormat.Format8bppIndexed:  					return 8;  				case sdi.PixelFormat.Format24bppRgb:  					return 24;  				case sdi.PixelFormat.Format32bppArgb:  				case sdi.PixelFormat.Format32bppPArgb:  				case sdi.PixelFormat.Format32bppRgb:  					return 32;  				default:  					throw new NotSupportedException();  			}
Magic Number,Eto.WinForms,WinConversions,C:\repos\picoe_Eto\Source\Eto.WinForms\WinConversions.cs,BitsPerPixel,The following statement contains a magic number: switch (format)  			{  				case sdi.PixelFormat.Format1bppIndexed:  					return 1;  				case sdi.PixelFormat.Format4bppIndexed:  					return 4;  				case sdi.PixelFormat.Format8bppIndexed:  					return 8;  				case sdi.PixelFormat.Format24bppRgb:  					return 24;  				case sdi.PixelFormat.Format32bppArgb:  				case sdi.PixelFormat.Format32bppPArgb:  				case sdi.PixelFormat.Format32bppRgb:  					return 32;  				default:  					throw new NotSupportedException();  			}
Magic Number,Eto.WinForms,Win32TextBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Win32TextBox.cs,FastScrollToCaret,The following statement contains a magic number: if (control.IsHandleCreated)  			{  				var textLength = control.TextLength;  				if (textLength == 0)  				{  					return;  				}  				bool flag = false;  				object iunknown = null;  				var iunkHandle = IntPtr.Zero;  				try  				{  					if (SendMessage(new HandleRef(control' control.Handle)' 1084' 0' out iunknown) != 0)  					{  						iunkHandle = Marshal.GetIUnknownForObject(iunknown);  						if (iunkHandle != IntPtr.Zero)  						{  							var itextDocumentHandle = IntPtr.Zero;  							var gUID = typeof(ITextDocument).GUID;  							try  							{  								Marshal.QueryInterface(iunkHandle' ref gUID' out itextDocumentHandle);  								var textDocument = Marshal.GetObjectForIUnknown(itextDocumentHandle) as ITextDocument;  								if (textDocument != null)  								{  									int start = control.SelectionStart;  									int lineFromCharIndex = control.GetLineFromCharIndex(start);  									var textRange = textDocument.Range(start' start + control.SelectionLength);  									textRange.ScrollIntoView(0); // scroll to start of selection  									int num3 = (int)Win32.SendMessage(control.Handle' (Win32.WM)206' IntPtr.Zero' IntPtr.Zero);  									if (num3 > lineFromCharIndex)  									{  										textRange.ScrollIntoView(32);  									}  									flag = true;  								}  							}  							finally  							{  								if (itextDocumentHandle != IntPtr.Zero)  								{  									Marshal.Release(itextDocumentHandle);  								}  							}  						}  					}  				}  				finally  				{  					if (iunkHandle != IntPtr.Zero)  					{  						Marshal.Release(iunkHandle);  					}  				}  				if (!flag)  				{  					Win32.SendMessage(control.Handle' (Win32.WM)183' IntPtr.Zero' IntPtr.Zero);  					return;  				}  			}  			else  				control.ScrollToCaret();
Magic Number,Eto.WinForms,Win32TextBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Win32TextBox.cs,FastScrollToCaret,The following statement contains a magic number: if (control.IsHandleCreated)  			{  				var textLength = control.TextLength;  				if (textLength == 0)  				{  					return;  				}  				bool flag = false;  				object iunknown = null;  				var iunkHandle = IntPtr.Zero;  				try  				{  					if (SendMessage(new HandleRef(control' control.Handle)' 1084' 0' out iunknown) != 0)  					{  						iunkHandle = Marshal.GetIUnknownForObject(iunknown);  						if (iunkHandle != IntPtr.Zero)  						{  							var itextDocumentHandle = IntPtr.Zero;  							var gUID = typeof(ITextDocument).GUID;  							try  							{  								Marshal.QueryInterface(iunkHandle' ref gUID' out itextDocumentHandle);  								var textDocument = Marshal.GetObjectForIUnknown(itextDocumentHandle) as ITextDocument;  								if (textDocument != null)  								{  									int start = control.SelectionStart;  									int lineFromCharIndex = control.GetLineFromCharIndex(start);  									var textRange = textDocument.Range(start' start + control.SelectionLength);  									textRange.ScrollIntoView(0); // scroll to start of selection  									int num3 = (int)Win32.SendMessage(control.Handle' (Win32.WM)206' IntPtr.Zero' IntPtr.Zero);  									if (num3 > lineFromCharIndex)  									{  										textRange.ScrollIntoView(32);  									}  									flag = true;  								}  							}  							finally  							{  								if (itextDocumentHandle != IntPtr.Zero)  								{  									Marshal.Release(itextDocumentHandle);  								}  							}  						}  					}  				}  				finally  				{  					if (iunkHandle != IntPtr.Zero)  					{  						Marshal.Release(iunkHandle);  					}  				}  				if (!flag)  				{  					Win32.SendMessage(control.Handle' (Win32.WM)183' IntPtr.Zero' IntPtr.Zero);  					return;  				}  			}  			else  				control.ScrollToCaret();
Magic Number,Eto.WinForms,Win32TextBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Win32TextBox.cs,FastScrollToCaret,The following statement contains a magic number: if (control.IsHandleCreated)  			{  				var textLength = control.TextLength;  				if (textLength == 0)  				{  					return;  				}  				bool flag = false;  				object iunknown = null;  				var iunkHandle = IntPtr.Zero;  				try  				{  					if (SendMessage(new HandleRef(control' control.Handle)' 1084' 0' out iunknown) != 0)  					{  						iunkHandle = Marshal.GetIUnknownForObject(iunknown);  						if (iunkHandle != IntPtr.Zero)  						{  							var itextDocumentHandle = IntPtr.Zero;  							var gUID = typeof(ITextDocument).GUID;  							try  							{  								Marshal.QueryInterface(iunkHandle' ref gUID' out itextDocumentHandle);  								var textDocument = Marshal.GetObjectForIUnknown(itextDocumentHandle) as ITextDocument;  								if (textDocument != null)  								{  									int start = control.SelectionStart;  									int lineFromCharIndex = control.GetLineFromCharIndex(start);  									var textRange = textDocument.Range(start' start + control.SelectionLength);  									textRange.ScrollIntoView(0); // scroll to start of selection  									int num3 = (int)Win32.SendMessage(control.Handle' (Win32.WM)206' IntPtr.Zero' IntPtr.Zero);  									if (num3 > lineFromCharIndex)  									{  										textRange.ScrollIntoView(32);  									}  									flag = true;  								}  							}  							finally  							{  								if (itextDocumentHandle != IntPtr.Zero)  								{  									Marshal.Release(itextDocumentHandle);  								}  							}  						}  					}  				}  				finally  				{  					if (iunkHandle != IntPtr.Zero)  					{  						Marshal.Release(iunkHandle);  					}  				}  				if (!flag)  				{  					Win32.SendMessage(control.Handle' (Win32.WM)183' IntPtr.Zero' IntPtr.Zero);  					return;  				}  			}  			else  				control.ScrollToCaret();
Magic Number,Eto.WinForms,Win32TextBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Win32TextBox.cs,FastScrollToCaret,The following statement contains a magic number: if (control.IsHandleCreated)  			{  				var textLength = control.TextLength;  				if (textLength == 0)  				{  					return;  				}  				bool flag = false;  				object iunknown = null;  				var iunkHandle = IntPtr.Zero;  				try  				{  					if (SendMessage(new HandleRef(control' control.Handle)' 1084' 0' out iunknown) != 0)  					{  						iunkHandle = Marshal.GetIUnknownForObject(iunknown);  						if (iunkHandle != IntPtr.Zero)  						{  							var itextDocumentHandle = IntPtr.Zero;  							var gUID = typeof(ITextDocument).GUID;  							try  							{  								Marshal.QueryInterface(iunkHandle' ref gUID' out itextDocumentHandle);  								var textDocument = Marshal.GetObjectForIUnknown(itextDocumentHandle) as ITextDocument;  								if (textDocument != null)  								{  									int start = control.SelectionStart;  									int lineFromCharIndex = control.GetLineFromCharIndex(start);  									var textRange = textDocument.Range(start' start + control.SelectionLength);  									textRange.ScrollIntoView(0); // scroll to start of selection  									int num3 = (int)Win32.SendMessage(control.Handle' (Win32.WM)206' IntPtr.Zero' IntPtr.Zero);  									if (num3 > lineFromCharIndex)  									{  										textRange.ScrollIntoView(32);  									}  									flag = true;  								}  							}  							finally  							{  								if (itextDocumentHandle != IntPtr.Zero)  								{  									Marshal.Release(itextDocumentHandle);  								}  							}  						}  					}  				}  				finally  				{  					if (iunkHandle != IntPtr.Zero)  					{  						Marshal.Release(iunkHandle);  					}  				}  				if (!flag)  				{  					Win32.SendMessage(control.Handle' (Win32.WM)183' IntPtr.Zero' IntPtr.Zero);  					return;  				}  			}  			else  				control.ScrollToCaret();
Magic Number,Eto.WinForms.Drawing,BrushObject,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\RadialGradientBrushHandler.cs,GetBrush,The following statement contains a magic number: if (wrapMode == GradientWrapMode.Pad)  				{  					// winforms does not support pad' so extend to fill entire drawing region  					if (transform != null)  					{  						start = transform.TransformPoint(start);  						end = transform.TransformPoint(end);  					}  					PointF min' max;  					GradientHelper.GetLinearMinMax(start' end' rect' out min' out max' true);  					var len = max.LengthTo(min);  					// find start/end pos based on entire position  					var startpos = min.LengthTo(start) / len;  					var endpos = min.LengthTo(end) / len;  					if (brush == null || lastStartPos != startpos || lastEndPos > endpos)  					{  						lastStartPos = startpos;  						lastEndPos = endpos;  						start = min;  						end = max;  						var diff = end - start;  						// account for innacuracies in system.drawing when nearing horizontal or vertical  						if (Math.Abs(diff.X) < 0.0001)  							end.X = start.X;  						if (Math.Abs(diff.Y) < 0.0001)  							end.Y = start.Y;    						brush = new sd2.LinearGradientBrush(start.ToSD()' end.ToSD()' StartColor' EndColor);  						brush.WrapMode = sd2.WrapMode.Tile;  						brush.InterpolationColors = new sd2.ColorBlend  						{  							Colors = new[]  						{  							StartColor'  							StartColor'  							EndColor'  							EndColor  						}'  							Positions = new[]  						{  							0f'  							startpos'  							endpos'  							1f'  						}  						};  					}  				}  				else if (brush == null)  				{  					brush = new sd2.LinearGradientBrush(StartPoint.ToSD()' EndPoint.ToSD()' StartColor' EndColor);  					brush.WrapMode = wrapMode.ToSD();  					if (transform != null)  						brush.MultiplyTransform(transform.ToSD());  				}
Magic Number,Eto.WinForms.Drawing,BrushObject,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\RadialGradientBrushHandler.cs,GetBrush,The following statement contains a magic number: if (wrapMode == GradientWrapMode.Pad)  				{  					// winforms does not support pad' so extend to fill entire drawing region  					if (transform != null)  					{  						start = transform.TransformPoint(start);  						end = transform.TransformPoint(end);  					}  					PointF min' max;  					GradientHelper.GetLinearMinMax(start' end' rect' out min' out max' true);  					var len = max.LengthTo(min);  					// find start/end pos based on entire position  					var startpos = min.LengthTo(start) / len;  					var endpos = min.LengthTo(end) / len;  					if (brush == null || lastStartPos != startpos || lastEndPos > endpos)  					{  						lastStartPos = startpos;  						lastEndPos = endpos;  						start = min;  						end = max;  						var diff = end - start;  						// account for innacuracies in system.drawing when nearing horizontal or vertical  						if (Math.Abs(diff.X) < 0.0001)  							end.X = start.X;  						if (Math.Abs(diff.Y) < 0.0001)  							end.Y = start.Y;    						brush = new sd2.LinearGradientBrush(start.ToSD()' end.ToSD()' StartColor' EndColor);  						brush.WrapMode = sd2.WrapMode.Tile;  						brush.InterpolationColors = new sd2.ColorBlend  						{  							Colors = new[]  						{  							StartColor'  							StartColor'  							EndColor'  							EndColor  						}'  							Positions = new[]  						{  							0f'  							startpos'  							endpos'  							1f'  						}  						};  					}  				}  				else if (brush == null)  				{  					brush = new sd2.LinearGradientBrush(StartPoint.ToSD()' EndPoint.ToSD()' StartColor' EndColor);  					brush.WrapMode = wrapMode.ToSD();  					if (transform != null)  						brush.MultiplyTransform(transform.ToSD());  				}
Magic Number,Eto.WinForms.Drawing,BitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,Save,The following statement contains a magic number: if (format == ImageFormat.Gif)  			{  				var quantizer = new OctreeQuantizer(255' 8);  				var gif = quantizer.Quantize(Control);  				gif.Save(stream' format.ToSD());  			}  			else  				Control.Save(stream' format.ToSD());
Magic Number,Eto.WinForms.Drawing,BitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\BitmapHandler.cs,Save,The following statement contains a magic number: if (format == ImageFormat.Gif)  			{  				var quantizer = new OctreeQuantizer(255' 8);  				var gif = quantizer.Quantize(Control);  				gif.Save(stream' format.ToSD());  			}  			else  				Control.Save(stream' format.ToSD());
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: var quadrant2 = (modAngle > 90 && modAngle <= 180);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: var quadrant2 = (modAngle > 90 && modAngle <= 180);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: var quadrant3 = (modAngle > 180 && modAngle <= 270);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: var quadrant3 = (modAngle > 180 && modAngle <= 270);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: var quadrant4 = (modAngle > 270 && modAngle <= 360);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: var quadrant4 = (modAngle > 270 && modAngle <= 360);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: if (Math.Abs(dTan) < 1E-10 | Math.Abs(dTan) > 10000000000.0)  			{  				functionReturnValue = angle;    			}  			else if (circularToElliptical)  			{  				functionReturnValue = Math.Atan(dTan * majorRadius / minorRadius);  			}  			else  			{  				functionReturnValue = Math.Atan(dTan * minorRadius / majorRadius);  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: if (Math.Abs(dTan) < 1E-10 | Math.Abs(dTan) > 10000000000.0)  			{  				functionReturnValue = angle;    			}  			else if (circularToElliptical)  			{  				functionReturnValue = Math.Atan(dTan * majorRadius / minorRadius);  			}  			else  			{  				functionReturnValue = Math.Atan(dTan * minorRadius / majorRadius);  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: if (functionReturnValue < 0)  			{  				functionReturnValue = functionReturnValue + 2 * Math.PI;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,GetConvertedAngle,The following statement contains a magic number: while (initialAngle > 360)  			{  				initialAngle -= 360.0f;  				ret += 360.0f;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The following statement contains a magic number: var bounds = new RectangleF(x - width' y - height' width * 2' height * 2);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,DrawArc,The following statement contains a magic number: var bounds = new RectangleF(x - width' y - height' width * 2' height * 2);
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillPie,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillPie,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillPie,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,GraphicsHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\GraphicsHandler.cs,FillPie,The following statement contains a magic number: if (width != height)  			{  				var endAngle = startAngle + sweepAngle;  				startAngle = GetConvertedAngle(startAngle' width / 2' height / 2' false);  				endAngle = GetConvertedAngle(endAngle' width / 2' height / 2' false);  				sweepAngle = endAngle - startAngle;  			}
Magic Number,Eto.WinForms.Drawing,IconHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IconHandler.cs,SplitIcon,The following statement contains a magic number: int count = BitConverter.ToInt16(srcBuf' 4);
Magic Number,Eto.WinForms.Drawing,IconHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IconHandler.cs,SplitIcon,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				using (var destStream = new MemoryStream())  				using (var writer = new BinaryWriter(destStream))  				{  					// Copy ICONDIR and ICONDIRENTRY.  					int pos = 0;  					writer.Write(srcBuf' pos' sICONDIR - 2);  					writer.Write((short)1);    // ICONDIR.idCount == 1;    					pos += sICONDIR;  					pos += sICONDIRENTRY * i;    					writer.Write(srcBuf' pos' sICONDIRENTRY - 4); // write out icon info (minus old offset)  					writer.Write(sICONDIR + sICONDIRENTRY);    // write offset of icon data  					pos += 8;    					// Copy picture and mask data.  					int imgSize = BitConverter.ToInt32(srcBuf' pos);       // ICONDIRENTRY.dwBytesInRes  					pos += 4;  					int imgOffset = BitConverter.ToInt32(srcBuf' pos);    // ICONDIRENTRY.dwImageOffset  					if (imgOffset + imgSize > srcBuf.Length)  						throw new ArgumentException("ugh");  					writer.Write(srcBuf' imgOffset' imgSize);  					writer.Flush();    					// Create new icon.  					destStream.Seek(0' SeekOrigin.Begin);  					splitIcons.Add(new sd.Icon(destStream));  				}  			}
Magic Number,Eto.WinForms.Drawing,IconHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IconHandler.cs,SplitIcon,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				using (var destStream = new MemoryStream())  				using (var writer = new BinaryWriter(destStream))  				{  					// Copy ICONDIR and ICONDIRENTRY.  					int pos = 0;  					writer.Write(srcBuf' pos' sICONDIR - 2);  					writer.Write((short)1);    // ICONDIR.idCount == 1;    					pos += sICONDIR;  					pos += sICONDIRENTRY * i;    					writer.Write(srcBuf' pos' sICONDIRENTRY - 4); // write out icon info (minus old offset)  					writer.Write(sICONDIR + sICONDIRENTRY);    // write offset of icon data  					pos += 8;    					// Copy picture and mask data.  					int imgSize = BitConverter.ToInt32(srcBuf' pos);       // ICONDIRENTRY.dwBytesInRes  					pos += 4;  					int imgOffset = BitConverter.ToInt32(srcBuf' pos);    // ICONDIRENTRY.dwImageOffset  					if (imgOffset + imgSize > srcBuf.Length)  						throw new ArgumentException("ugh");  					writer.Write(srcBuf' imgOffset' imgSize);  					writer.Flush();    					// Create new icon.  					destStream.Seek(0' SeekOrigin.Begin);  					splitIcons.Add(new sd.Icon(destStream));  				}  			}
Magic Number,Eto.WinForms.Drawing,IconHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IconHandler.cs,SplitIcon,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				using (var destStream = new MemoryStream())  				using (var writer = new BinaryWriter(destStream))  				{  					// Copy ICONDIR and ICONDIRENTRY.  					int pos = 0;  					writer.Write(srcBuf' pos' sICONDIR - 2);  					writer.Write((short)1);    // ICONDIR.idCount == 1;    					pos += sICONDIR;  					pos += sICONDIRENTRY * i;    					writer.Write(srcBuf' pos' sICONDIRENTRY - 4); // write out icon info (minus old offset)  					writer.Write(sICONDIR + sICONDIRENTRY);    // write offset of icon data  					pos += 8;    					// Copy picture and mask data.  					int imgSize = BitConverter.ToInt32(srcBuf' pos);       // ICONDIRENTRY.dwBytesInRes  					pos += 4;  					int imgOffset = BitConverter.ToInt32(srcBuf' pos);    // ICONDIRENTRY.dwImageOffset  					if (imgOffset + imgSize > srcBuf.Length)  						throw new ArgumentException("ugh");  					writer.Write(srcBuf' imgOffset' imgSize);  					writer.Flush();    					// Create new icon.  					destStream.Seek(0' SeekOrigin.Begin);  					splitIcons.Add(new sd.Icon(destStream));  				}  			}
Magic Number,Eto.WinForms.Drawing,IconHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IconHandler.cs,SplitIcon,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				using (var destStream = new MemoryStream())  				using (var writer = new BinaryWriter(destStream))  				{  					// Copy ICONDIR and ICONDIRENTRY.  					int pos = 0;  					writer.Write(srcBuf' pos' sICONDIR - 2);  					writer.Write((short)1);    // ICONDIR.idCount == 1;    					pos += sICONDIR;  					pos += sICONDIRENTRY * i;    					writer.Write(srcBuf' pos' sICONDIRENTRY - 4); // write out icon info (minus old offset)  					writer.Write(sICONDIR + sICONDIRENTRY);    // write offset of icon data  					pos += 8;    					// Copy picture and mask data.  					int imgSize = BitConverter.ToInt32(srcBuf' pos);       // ICONDIRENTRY.dwBytesInRes  					pos += 4;  					int imgOffset = BitConverter.ToInt32(srcBuf' pos);    // ICONDIRENTRY.dwImageOffset  					if (imgOffset + imgSize > srcBuf.Length)  						throw new ArgumentException("ugh");  					writer.Write(srcBuf' imgOffset' imgSize);  					writer.Flush();    					// Create new icon.  					destStream.Seek(0' SeekOrigin.Begin);  					splitIcons.Add(new sd.Icon(destStream));  				}  			}
Magic Number,Eto.WinForms.Drawing,IndexedBitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IndexedBitmapHandler.cs,Create,The following statement contains a magic number: switch (bitsPerPixel)  			{  				case 8:  					sdPixelFormat = SD.Imaging.PixelFormat.Format8bppIndexed;  					break;  				case 4:  					sdPixelFormat = SD.Imaging.PixelFormat.Format4bppIndexed;  					break;  				case 1:  					sdPixelFormat = SD.Imaging.PixelFormat.Format1bppIndexed;  					break;  				default:  					throw new ArgumentOutOfRangeException("bitsPerPixel"' bitsPerPixel' string.Format(CultureInfo.CurrentCulture' "Not supported"));  			}
Magic Number,Eto.WinForms.Drawing,IndexedBitmapHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Drawing\IndexedBitmapHandler.cs,Create,The following statement contains a magic number: switch (bitsPerPixel)  			{  				case 8:  					sdPixelFormat = SD.Imaging.PixelFormat.Format8bppIndexed;  					break;  				case 4:  					sdPixelFormat = SD.Imaging.PixelFormat.Format4bppIndexed;  					break;  				case 1:  					sdPixelFormat = SD.Imaging.PixelFormat.Format1bppIndexed;  					break;  				default:  					throw new ArgumentOutOfRangeException("bitsPerPixel"' bitsPerPixel' string.Format(CultureInfo.CurrentCulture' "Not supported"));  			}
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,PositionEditingControl,The following statement contains a magic number: Handler.PositionEditingControl(RowIndex' ref cellClip' ref cellBounds' IconSize + IconPadding * 2);
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,GetPreferredSize,The following statement contains a magic number: if (img != null) size.Width += IconSize + IconPadding * 2;
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (img != null)  				{  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var b = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  						{  							graphics.FillRectangle(b' new sd.Rectangle(cellBounds.X' cellBounds.Y' IconSize + IconPadding * 2' cellBounds.Height));  						}  					  					var container = graphics.BeginContainer();  					graphics.SetClip(cellBounds);  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var background = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  							graphics.FillRectangle(background' cellBounds);  					graphics.InterpolationMode = InterpolationMode;  					graphics.DrawImage(img' new sd.Rectangle(cellBounds.X + IconPadding' cellBounds.Y + (cellBounds.Height - Math.Min(img.Height' cellBounds.Height)) / 2' IconSize' IconSize));  					graphics.EndContainer(container);  					cellBounds.X += IconSize + IconPadding * 2;  					cellBounds.Width -= IconSize + IconPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (img != null)  				{  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var b = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  						{  							graphics.FillRectangle(b' new sd.Rectangle(cellBounds.X' cellBounds.Y' IconSize + IconPadding * 2' cellBounds.Height));  						}  					  					var container = graphics.BeginContainer();  					graphics.SetClip(cellBounds);  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var background = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  							graphics.FillRectangle(background' cellBounds);  					graphics.InterpolationMode = InterpolationMode;  					graphics.DrawImage(img' new sd.Rectangle(cellBounds.X + IconPadding' cellBounds.Y + (cellBounds.Height - Math.Min(img.Height' cellBounds.Height)) / 2' IconSize' IconSize));  					graphics.EndContainer(container);  					cellBounds.X += IconSize + IconPadding * 2;  					cellBounds.Width -= IconSize + IconPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (img != null)  				{  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var b = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  						{  							graphics.FillRectangle(b' new sd.Rectangle(cellBounds.X' cellBounds.Y' IconSize + IconPadding * 2' cellBounds.Height));  						}  					  					var container = graphics.BeginContainer();  					graphics.SetClip(cellBounds);  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var background = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  							graphics.FillRectangle(background' cellBounds);  					graphics.InterpolationMode = InterpolationMode;  					graphics.DrawImage(img' new sd.Rectangle(cellBounds.X + IconPadding' cellBounds.Y + (cellBounds.Height - Math.Min(img.Height' cellBounds.Height)) / 2' IconSize' IconSize));  					graphics.EndContainer(container);  					cellBounds.X += IconSize + IconPadding * 2;  					cellBounds.Width -= IconSize + IconPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (img != null)  				{  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var b = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  						{  							graphics.FillRectangle(b' new sd.Rectangle(cellBounds.X' cellBounds.Y' IconSize + IconPadding * 2' cellBounds.Height));  						}  					  					var container = graphics.BeginContainer();  					graphics.SetClip(cellBounds);  					if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  						using (var background = new sd.SolidBrush(cellState.HasFlag(swf.DataGridViewElementStates.Selected) ? cellStyle.SelectionBackColor : cellStyle.BackColor))  							graphics.FillRectangle(background' cellBounds);  					graphics.InterpolationMode = InterpolationMode;  					graphics.DrawImage(img' new sd.Rectangle(cellBounds.X + IconPadding' cellBounds.Y + (cellBounds.Height - Math.Min(img.Height' cellBounds.Height)) / 2' IconSize' IconSize));  					graphics.EndContainer(container);  					cellBounds.X += IconSize + IconPadding * 2;  					cellBounds.Width -= IconSize + IconPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: sd.Rectangle paintRect = new sd.Rectangle(cellBounds.X + 1' cellBounds.Y + 2' cellBounds.Width - 2' cellBounds.Height - 4);
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: sd.Rectangle paintRect = new sd.Rectangle(cellBounds.X + 1' cellBounds.Y + 2' cellBounds.Width - 2' cellBounds.Height - 4);
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: sd.Rectangle paintRect = new sd.Rectangle(cellBounds.X + 1' cellBounds.Y + 2' cellBounds.Width - 2' cellBounds.Height - 4);
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,EtoCell,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\CustomCellHandler.cs,Paint,The following statement contains a magic number: if (swf.ProgressBarRenderer.IsSupported)                  {                      swf.ProgressBarRenderer.DrawHorizontalBar(graphics' paintRect);                        sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 4);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                      swf.ProgressBarRenderer.DrawHorizontalChunks(graphics' barBounds);                  }                  else                  {                      sd.Rectangle barBounds = new sd.Rectangle(paintRect.X + 2' paintRect.Y + 2' paintRect.Width - 4' paintRect.Height - 3);                      barBounds.Width = (int)Math.Round(barBounds.Width * percentage);                        graphics.FillRectangle(sd.Brushes.LightGray' paintRect);                      graphics.DrawRectangle(sd.Pens.Black' paintRect);                      graphics.FillRectangle(new sd.SolidBrush(sd.Color.FromArgb(0' 216' 35))' barBounds);                  }
Magic Number,Eto.WinForms.Forms.Cells,ImageTextCellHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\ImageTextCellHandler.cs,GetCellValue,The following statement contains a magic number: var obj = new object[2];
Magic Number,Eto.WinForms.Forms.Cells,ImageTextCellHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\ImageTextCellHandler.cs,GetCellValue,The following statement contains a magic number: if (Widget.ImageBinding != null)  			{  				var image = Widget.ImageBinding.GetValue(dataItem) as Image;  				if (image != null)  				{  					var imageHandler = image.Handler as IWindowsImageSource;  					if (imageHandler != null)  					{  						obj[0] = imageHandler.GetImageWithSize(Math.Max(32' Control.PreferredSize.Height));  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Cells,ImageViewCellHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Cells\ImageViewCellHandler.cs,GetCellValue,The following statement contains a magic number: if (Widget.Binding != null)  			{  				var image = Widget.Binding.GetValue(dataItem);  				if (image != null)  				{  					var imageHandler = image.Handler as IWindowsImageSource;  					if (imageHandler != null)  					{  						return imageHandler.GetImageWithSize(Math.Max(32' Control.PreferredSize.Height));  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,ComboBoxHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ComboBoxHandler.cs,ComboBoxHandler,The following statement contains a magic number: Control.MinSize = new sd.Size(100' 0);
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,GetPreferredSize,The following statement contains a magic number: if (cachedSize == null)  			{  				var size = new sd.Size(16' 20);  				var font = Font;  				foreach (object item in Items)  				{  					var text = GetItemText(item);  					var itemSize = swf.TextRenderer.MeasureText(text' font);  					var image = (item as EtoComboBoxItem)?.Image;  					if (image != null)  						itemSize.Width += 18;  					size.Width = Math.Max(size.Width' (int) itemSize.Width);  					size.Height = Math.Max(size.Height' (int) itemSize.Height);  				}  				// for drop down glyph and border  				if (DrawMode == swf.DrawMode.OwnerDrawFixed)  					size.Width += 4;  				size.Width += 18;  				size.Height += 4;  				size.Width = Math.Max(size.Width' MinSize.Width);  				size.Height = Math.Max(size.Height' MinSize.Height);  				cachedSize = size;  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,GetPreferredSize,The following statement contains a magic number: if (cachedSize == null)  			{  				var size = new sd.Size(16' 20);  				var font = Font;  				foreach (object item in Items)  				{  					var text = GetItemText(item);  					var itemSize = swf.TextRenderer.MeasureText(text' font);  					var image = (item as EtoComboBoxItem)?.Image;  					if (image != null)  						itemSize.Width += 18;  					size.Width = Math.Max(size.Width' (int) itemSize.Width);  					size.Height = Math.Max(size.Height' (int) itemSize.Height);  				}  				// for drop down glyph and border  				if (DrawMode == swf.DrawMode.OwnerDrawFixed)  					size.Width += 4;  				size.Width += 18;  				size.Height += 4;  				size.Width = Math.Max(size.Width' MinSize.Width);  				size.Height = Math.Max(size.Height' MinSize.Height);  				cachedSize = size;  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,GetPreferredSize,The following statement contains a magic number: if (cachedSize == null)  			{  				var size = new sd.Size(16' 20);  				var font = Font;  				foreach (object item in Items)  				{  					var text = GetItemText(item);  					var itemSize = swf.TextRenderer.MeasureText(text' font);  					var image = (item as EtoComboBoxItem)?.Image;  					if (image != null)  						itemSize.Width += 18;  					size.Width = Math.Max(size.Width' (int) itemSize.Width);  					size.Height = Math.Max(size.Height' (int) itemSize.Height);  				}  				// for drop down glyph and border  				if (DrawMode == swf.DrawMode.OwnerDrawFixed)  					size.Width += 4;  				size.Width += 18;  				size.Height += 4;  				size.Width = Math.Max(size.Width' MinSize.Width);  				size.Height = Math.Max(size.Height' MinSize.Height);  				cachedSize = size;  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,GetPreferredSize,The following statement contains a magic number: if (cachedSize == null)  			{  				var size = new sd.Size(16' 20);  				var font = Font;  				foreach (object item in Items)  				{  					var text = GetItemText(item);  					var itemSize = swf.TextRenderer.MeasureText(text' font);  					var image = (item as EtoComboBoxItem)?.Image;  					if (image != null)  						itemSize.Width += 18;  					size.Width = Math.Max(size.Width' (int) itemSize.Width);  					size.Height = Math.Max(size.Height' (int) itemSize.Height);  				}  				// for drop down glyph and border  				if (DrawMode == swf.DrawMode.OwnerDrawFixed)  					size.Width += 4;  				size.Width += 18;  				size.Height += 4;  				size.Width = Math.Max(size.Width' MinSize.Width);  				size.Height = Math.Max(size.Height' MinSize.Height);  				cachedSize = size;  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,GetPreferredSize,The following statement contains a magic number: if (cachedSize == null)  			{  				var size = new sd.Size(16' 20);  				var font = Font;  				foreach (object item in Items)  				{  					var text = GetItemText(item);  					var itemSize = swf.TextRenderer.MeasureText(text' font);  					var image = (item as EtoComboBoxItem)?.Image;  					if (image != null)  						itemSize.Width += 18;  					size.Width = Math.Max(size.Width' (int) itemSize.Width);  					size.Height = Math.Max(size.Height' (int) itemSize.Height);  				}  				// for drop down glyph and border  				if (DrawMode == swf.DrawMode.OwnerDrawFixed)  					size.Width += 4;  				size.Width += 18;  				size.Height += 4;  				size.Width = Math.Max(size.Width' MinSize.Width);  				size.Height = Math.Max(size.Height' MinSize.Height);  				cachedSize = size;  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,GetPreferredSize,The following statement contains a magic number: if (cachedSize == null)  			{  				var size = new sd.Size(16' 20);  				var font = Font;  				foreach (object item in Items)  				{  					var text = GetItemText(item);  					var itemSize = swf.TextRenderer.MeasureText(text' font);  					var image = (item as EtoComboBoxItem)?.Image;  					if (image != null)  						itemSize.Width += 18;  					size.Width = Math.Max(size.Width' (int) itemSize.Width);  					size.Height = Math.Max(size.Height' (int) itemSize.Height);  				}  				// for drop down glyph and border  				if (DrawMode == swf.DrawMode.OwnerDrawFixed)  					size.Width += 4;  				size.Width += 18;  				size.Height += 4;  				size.Width = Math.Max(size.Width' MinSize.Width);  				size.Height = Math.Max(size.Height' MinSize.Height);  				cachedSize = size;  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.State.HasFlag(swf.DrawItemState.ComboBoxEdit))  			{  				var bounds = e.Bounds;  				bounds.Inflate(2' 2);  				// only show the background color for the drop down' not for each item  				e.Graphics.FillRectangle(new sd.SolidBrush(BackColor)' bounds);  			}  			else  			{  				e.DrawBackground();  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.State.HasFlag(swf.DrawItemState.ComboBoxEdit))  			{  				var bounds = e.Bounds;  				bounds.Inflate(2' 2);  				// only show the background color for the drop down' not for each item  				e.Graphics.FillRectangle(new sd.SolidBrush(BackColor)' bounds);  			}  			else  			{  				e.DrawBackground();  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.Index >= 0)  			{  				var item = Items[e.Index];  				var bounds = e.Bounds;  				var image = (item as EtoComboBoxItem)?.Image;    				if (image != null)  				{  					e.Graphics.DrawImage(image.ToSD(new Size(16' 16))' bounds.X' bounds.Y' 16' 16);  					bounds.X += 18;  					bounds.Width -= 18;  				}    				string text = item?.ToString();    				// Determine the forecolor based on whether or not the item is selected      				swf.TextRenderer.DrawText(e.Graphics' text' Font' bounds' ForeColor' swf.TextFormatFlags.Left);  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.Index >= 0)  			{  				var item = Items[e.Index];  				var bounds = e.Bounds;  				var image = (item as EtoComboBoxItem)?.Image;    				if (image != null)  				{  					e.Graphics.DrawImage(image.ToSD(new Size(16' 16))' bounds.X' bounds.Y' 16' 16);  					bounds.X += 18;  					bounds.Width -= 18;  				}    				string text = item?.ToString();    				// Determine the forecolor based on whether or not the item is selected      				swf.TextRenderer.DrawText(e.Graphics' text' Font' bounds' ForeColor' swf.TextFormatFlags.Left);  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.Index >= 0)  			{  				var item = Items[e.Index];  				var bounds = e.Bounds;  				var image = (item as EtoComboBoxItem)?.Image;    				if (image != null)  				{  					e.Graphics.DrawImage(image.ToSD(new Size(16' 16))' bounds.X' bounds.Y' 16' 16);  					bounds.X += 18;  					bounds.Width -= 18;  				}    				string text = item?.ToString();    				// Determine the forecolor based on whether or not the item is selected      				swf.TextRenderer.DrawText(e.Graphics' text' Font' bounds' ForeColor' swf.TextFormatFlags.Left);  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.Index >= 0)  			{  				var item = Items[e.Index];  				var bounds = e.Bounds;  				var image = (item as EtoComboBoxItem)?.Image;    				if (image != null)  				{  					e.Graphics.DrawImage(image.ToSD(new Size(16' 16))' bounds.X' bounds.Y' 16' 16);  					bounds.X += 18;  					bounds.Width -= 18;  				}    				string text = item?.ToString();    				// Determine the forecolor based on whether or not the item is selected      				swf.TextRenderer.DrawText(e.Graphics' text' Font' bounds' ForeColor' swf.TextFormatFlags.Left);  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.Index >= 0)  			{  				var item = Items[e.Index];  				var bounds = e.Bounds;  				var image = (item as EtoComboBoxItem)?.Image;    				if (image != null)  				{  					e.Graphics.DrawImage(image.ToSD(new Size(16' 16))' bounds.X' bounds.Y' 16' 16);  					bounds.X += 18;  					bounds.Width -= 18;  				}    				string text = item?.ToString();    				// Determine the forecolor based on whether or not the item is selected      				swf.TextRenderer.DrawText(e.Graphics' text' Font' bounds' ForeColor' swf.TextFormatFlags.Left);  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoComboBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,OnDrawItem,The following statement contains a magic number: if (e.Index >= 0)  			{  				var item = Items[e.Index];  				var bounds = e.Bounds;  				var image = (item as EtoComboBoxItem)?.Image;    				if (image != null)  				{  					e.Graphics.DrawImage(image.ToSD(new Size(16' 16))' bounds.X' bounds.Y' 16' 16);  					bounds.X += 18;  					bounds.Width -= 18;  				}    				string text = item?.ToString();    				// Determine the forecolor based on whether or not the item is selected      				swf.TextRenderer.DrawText(e.Graphics' text' Font' bounds' ForeColor' swf.TextFormatFlags.Left);  			}
Magic Number,Eto.WinForms.Forms.Controls,DropDownHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\DropDownHandler.cs,DropDownHandler,The following statement contains a magic number: Control = (TControl)new EtoComboBox  			{  				DropDownStyle = swf.ComboBoxStyle.DropDownList'  				DrawMode = swf.DrawMode.OwnerDrawFixed'  				AutoSize = true'  				Size = new sd.Size(20' 0)  			};
Magic Number,Eto.WinForms.Forms.Controls,EtoDataGridView,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,GetPreferredSize,The following statement contains a magic number: if (def.Height >= 0)  					size.Height = def.Height;  				else  					size.Height = Math.Min(size.Height' 100);
Magic Number,Eto.WinForms.Forms.Controls,ColumnCollection,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridHandler.cs,InsertItem,The following statement contains a magic number: if (Handler.clearColumns && Handler.Control.Columns.Count == 2 && index == 0)  				{  					Handler.Control.Columns.RemoveAt(Handler.Control.Columns.Count - 1);  					Handler.clearColumns = false;  				}
Magic Number,Eto.WinForms.Forms.Controls,ProgressBarHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ProgressBarHandler.cs,ProgressBarHandler,The following statement contains a magic number: this.Control = new SWF.ProgressBar {  				Maximum = 100'  				Style = SWF.ProgressBarStyle.Blocks  			};
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,EnsureGlyphRenderers,The following statement contains a magic number: if (openRenderer == null || closedRenderer == null)  			{  				if (ClassicStyle)  				{  					openRenderer = new swf.VisualStyles.VisualStyleRenderer(swf.VisualStyles.VisualStyleElement.TreeView.Glyph.Opened);  					closedRenderer = new swf.VisualStyles.VisualStyleRenderer(swf.VisualStyles.VisualStyleElement.TreeView.Glyph.Closed);  				}  				else  				{  					openRenderer = new swf.VisualStyles.VisualStyleRenderer("Explorer::TreeView"' 2' 2);  					closedRenderer = new swf.VisualStyles.VisualStyleRenderer("Explorer::TreeView"' 2' 1);  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,EnsureGlyphRenderers,The following statement contains a magic number: if (openRenderer == null || closedRenderer == null)  			{  				if (ClassicStyle)  				{  					openRenderer = new swf.VisualStyles.VisualStyleRenderer(swf.VisualStyles.VisualStyleElement.TreeView.Glyph.Opened);  					closedRenderer = new swf.VisualStyles.VisualStyleRenderer(swf.VisualStyles.VisualStyleElement.TreeView.Glyph.Closed);  				}  				else  				{  					openRenderer = new swf.VisualStyles.VisualStyleRenderer("Explorer::TreeView"' 2' 2);  					closedRenderer = new swf.VisualStyles.VisualStyleRenderer("Explorer::TreeView"' 2' 1);  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,EnsureGlyphRenderers,The following statement contains a magic number: if (openRenderer == null || closedRenderer == null)  			{  				if (ClassicStyle)  				{  					openRenderer = new swf.VisualStyles.VisualStyleRenderer(swf.VisualStyles.VisualStyleElement.TreeView.Glyph.Opened);  					closedRenderer = new swf.VisualStyles.VisualStyleRenderer(swf.VisualStyles.VisualStyleElement.TreeView.Glyph.Closed);  				}  				else  				{  					openRenderer = new swf.VisualStyles.VisualStyleRenderer("Explorer::TreeView"' 2' 2);  					closedRenderer = new swf.VisualStyles.VisualStyleRenderer("Explorer::TreeView"' 2' 1);  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,TreeGridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TreeGridViewHandler.cs,Paint,The following statement contains a magic number: if (object.ReferenceEquals(column.Widget' this.Widget.Columns[0]))  			{  				// paint the background  				if (paintParts.HasFlag(swf.DataGridViewPaintParts.Background))  				{  					sd.Brush brush;  					if (cellState.HasFlag(swf.DataGridViewElementStates.Selected))  						brush = new sd.SolidBrush(cellStyle.SelectionBackColor);  					else  						brush = new sd.SolidBrush(cellStyle.BackColor);  					graphics.FillRectangle(brush' cellBounds);  					paintParts &= ~swf.DataGridViewPaintParts.Background;  				}    				var node = controller.GetNodeAtRow(rowIndex);  				var treeRect = cellBounds;  				treeRect.X += node.Level * INDENT_WIDTH;  				treeRect.Width = 16;    				if (ClassicStyle && ClassicGridLines)  				{  					// Draw grid lines - for classic style  					using (var linePen = new sd.Pen(sd.SystemBrushes.ControlDark' 1.0f))  					{  						var lineRect = treeRect;  						lineRect.X += 7;  						lineRect.Width = 10;  						linePen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  						var isFirstSibling = node.IsFirstNode;  						var isLastSibling = node.IsLastNode;  						if (node.Level == 0)  						{  							// the Root nodes display their lines differently  							if (isFirstSibling && isLastSibling)  							{  								// only node' both first and last. Just draw horizontal line  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else if (isFirstSibling)  							{  								// first sibling doesn't draw the line extended above. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.X' cellBounds.Bottom);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}  						}  						else  						{  							if (isLastSibling)  							{  								// last sibling doesn't draw the line extended below. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Top + cellBounds.Height / 2);  							}  							else  							{  								// normal drawing draws extended from top to bottom. Paint horizontal then vertical  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top + cellBounds.Height / 2' lineRect.Right' cellBounds.Top + cellBounds.Height / 2);  								graphics.DrawLine(linePen' lineRect.X' cellBounds.Top' lineRect.X' cellBounds.Bottom);  							}    							// paint lines of previous levels to the root  							int horizontalStop = lineRect.X - INDENT_WIDTH;  							var previousNode = node.Parent;    							while (previousNode != null)  							{  								if (!previousNode.IsLastNode)  								{  									// paint vertical line  									graphics.DrawLine(linePen' horizontalStop' lineRect.Top' horizontalStop' lineRect.Bottom);  								}  								previousNode = previousNode.Parent;  								horizontalStop = horizontalStop - INDENT_WIDTH;  							}  						}    					}  				}    				if (node.Item.Expandable)  				{  					// draw open/close glyphs  					if (swf.Application.RenderWithVisualStyles)  					{  						EnsureGlyphRenderers();  						if (controller.IsExpanded(rowIndex))  							openRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						else  						{  							closedRenderer.DrawBackground(graphics' new sd.Rectangle(treeRect.X' treeRect.Y + (treeRect.Height / 2) - 8' 16' 16));  						}  					}  					else  					{  						// todo: draw +/- manually  						var glyphRect = treeRect;  						glyphRect.Width = glyphRect.Height = 8;  						glyphRect.X += 3;  						glyphRect.Y += (treeRect.Height - glyphRect.Height) / 2;  						graphics.FillRectangle(sd.SystemBrushes.Window' glyphRect);  						graphics.DrawRectangle(sd.SystemPens.ControlDark' glyphRect);  						glyphRect.Inflate(-2' -2);  						if (!controller.IsExpanded(rowIndex))  						{  							var midx = glyphRect.X + glyphRect.Width / 2;  							graphics.DrawLine(sd.SystemPens.ControlDarkDark' midx' glyphRect.Top' midx' glyphRect.Bottom);  						}    						var midy = glyphRect.Y + glyphRect.Height / 2;  						graphics.DrawLine(sd.SystemPens.ControlDarkDark' glyphRect.Left' midy' glyphRect.Right' midy);  					}  				}  			}
Magic Number,Eto.WinForms.Forms.Controls,EtoButton,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ButtonHandler.cs,GetPreferredSize,The following statement contains a magic number: if (AutoSize && Image != null)  				{  					if (!string.IsNullOrEmpty(Text))  						// fix bug where text will wrap if it has both an image and text  						size.Width += 3;  					else  						// fix bug with image and no text  						size.Height += 1;  				}
Magic Number,Eto.WinForms.Forms.Controls,EtoButton,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ButtonHandler.cs,GetPreferredSize,The following statement contains a magic number: if (Image != null)  				{  					var imgSize = Image.Size.ToEto() + 8;  					size.Width = Math.Max(size.Width' imgSize.Width);  					size.Height = Math.Max(size.Height' imgSize.Height);  				}
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnMeasureItem,The following statement contains a magic number: e.ItemHeight = (int)Math.Ceiling(Font.GetHeight(e.Graphics)) + ItemPadding * 2;
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnMeasureItem,The following statement contains a magic number: if (image != null)  				{  					e.ItemHeight = Math.Max(e.ItemHeight' image.Height + ItemPadding * 2);  					e.ItemWidth += image.Width + ItemPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnMeasureItem,The following statement contains a magic number: if (image != null)  				{  					e.ItemHeight = Math.Max(e.ItemHeight' image.Height + ItemPadding * 2);  					e.ItemWidth += image.Width + ItemPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnDrawItem,The following statement contains a magic number: var image = handler.Widget.ItemImageBinding?.GetValue(item).ToSD(new Size(bounds.Width' bounds.Height - ItemPadding * 2));
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnDrawItem,The following statement contains a magic number: if (image != null)  				{  					// just in case' make image fit in our bounds  					var imageHeight = bounds.Height - ItemPadding * 2;  					var imageWidth = imageHeight * image.Width / image.Height;  					e.Graphics.DrawImage(image' bounds.X + ItemPadding' bounds.Y + ItemPadding' imageWidth' imageHeight);  					bounds.X += imageWidth + ItemPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnDrawItem,The following statement contains a magic number: if (image != null)  				{  					// just in case' make image fit in our bounds  					var imageHeight = bounds.Height - ItemPadding * 2;  					var imageWidth = imageHeight * image.Width / image.Height;  					e.Graphics.DrawImage(image' bounds.X + ItemPadding' bounds.Y + ItemPadding' imageWidth' imageHeight);  					bounds.X += imageWidth + ItemPadding * 2;  				}
Magic Number,Eto.WinForms.Forms.Controls,EtoListBox,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ListBoxHandler.cs,OnDrawItem,The following statement contains a magic number: bounds.Y += Math.Max(0' (bounds.Height - stringSize.Height) / 2);
Magic Number,Eto.WinForms.Forms.Controls,NumericStepperHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\NumericStepperHandler.cs,NumericStepperHandler,The following statement contains a magic number: Control = new EtoNumericUpDown  			{  				Handler = this'  				Maximum = decimal.MaxValue'  				Minimum = decimal.MinValue'  				Width = 80  			};
Magic Number,Eto.WinForms.Forms.Controls,ScrollableHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ScrollableHandler.cs,ScrollableHandler,The following statement contains a magic number: Control.VerticalScroll.SmallChange = 5;
Magic Number,Eto.WinForms.Forms.Controls,ScrollableHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ScrollableHandler.cs,ScrollableHandler,The following statement contains a magic number: Control.VerticalScroll.LargeChange = 10;
Magic Number,Eto.WinForms.Forms.Controls,ScrollableHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ScrollableHandler.cs,ScrollableHandler,The following statement contains a magic number: Control.HorizontalScroll.SmallChange = 5;
Magic Number,Eto.WinForms.Forms.Controls,ScrollableHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ScrollableHandler.cs,ScrollableHandler,The following statement contains a magic number: Control.HorizontalScroll.LargeChange = 10;
Magic Number,Eto.WinForms.Forms.Controls,SplitterHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\SplitterHandler.cs,UpdateRelative,The following statement contains a magic number: if (fixedPanel == SplitterFixedPanel.Panel1)  				relative = pos;  			else  			{  				var sz = GetAvailableSize();  				if (fixedPanel == SplitterFixedPanel.Panel2)  					relative = sz <= 0 ? 0 : sz - pos;  				else  					relative = sz <= 0 ? 0.5 : pos / (double)sz;  			}
Magic Number,Eto.WinForms.Forms.Controls,SplitterHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\SplitterHandler.cs,SetPosition,The following statement contains a magic number: relative = fixedPanel == SplitterFixedPanel.Panel1 ? Math.Max(0' newPosition)  				: fixedPanel == SplitterFixedPanel.Panel2 ? Math.Max(0' size - newPosition)  				: size <= 0 ? 0.5 : Math.Max(0.0' Math.Min(1.0' newPosition / (double)size));
Magic Number,Eto.WinForms.Forms.Controls,SliderHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\SliderHandler.cs,SliderHandler,The following statement contains a magic number: this.Control = new EtoTrackBar  			{  				TickStyle = System.Windows.Forms.TickStyle.BottomRight'  				Maximum = 100'  				AutoSize = true  			};
Magic Number,Eto.WinForms.Forms.Controls,SliderHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\SliderHandler.cs,HandleScaleValueChanged,The following statement contains a magic number: if (SnapToTick && offset != 0)  			{  				if (offset > tick / 2)  					Control.Value = value - offset + tick;  				else  					Control.Value -= offset;  			}  			else if (lastValue == null || lastValue.Value != value)  			{  				Callback.OnValueChanged(Widget' EventArgs.Empty);  				lastValue = value;  			}
Magic Number,Eto.WinForms.Forms.Controls,GridViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\GridViewHandler.cs,SetRowCount,The following statement contains a magic number: if (collection != null)  			{  				var count = collection.Count;  				var oldCount = Control.RowCount;  				// if we shrink by more than 50 items' we set count to 0 first to avoid performance issues with winforms  				const int MinDifference = 50;  				if (count < oldCount - MinDifference)   				{  					// When going from a large dataset to a small one' DataGridView removes the rows one by one going very slow.  					// We fix this by setting the count to zero first' then setting the count.  					// However' we need to save/restore the selection in that case.  					SupressSelectionChanged++;  					var selectedRows = SelectedRows;  					Control.RowCount = 0;  					if (count > 0)  					{  						ResetSelection();  						Control.RowCount = count;  					}  					SelectedRows = selectedRows.Where(r => r < count);  					SupressSelectionChanged--;  				}  				else  				{  					// when we go from nothing to something' the DataGridView automatically selects the first item.  					// this prevents that  					if (oldCount == 0 && count > 0)  						ResetSelection();  					Control.RowCount = count;  				}  			}  			else  				Control.RowCount = 0;
Magic Number,Eto.WinForms.Forms.Controls,ColorPickerHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\ColorPickerHandler.cs,ColorPickerHandler,The following statement contains a magic number: Control = new swf.Button { Width = 40 };
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,WndProc,The following statement contains a magic number: if (ExtendedMode && m.Msg == (int)Win32.WM.LBUTTONDOWN)  			{  				var mouse = PointToClient(MousePosition);    				if (Enabled)  				{  					using (var g = CreateGraphics())  					{  						var offset = 2;  						if (ShowCheckBox)  						{  							var checkSize = swf.CheckBoxRenderer.GetGlyphSize(g' swf.VisualStyles.CheckBoxState.UncheckedNormal);  							var checkOffset = (ClientSize.Height - checkSize.Height) / 2;  							offset += checkOffset + checkSize.Width + 1;  						}    						if (Checked)  						{  							var test = mouse;  							test.X -= offset;  							for (int i = 0; i < segments.Count; i++)  							{  								var segment = segments[i];  								if (test.X >= segment.Start && test.X <= segment.End)  								{  									Focus();  									selectedSegment = i;  									Invalidate();  									return;  								}  							}  						}    						if (mouse.X > offset && mouse.X < ClientSize.Width - img.Width - 14)  						{  							Focus();  							return;  						}  					}  				}  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,WndProc,The following statement contains a magic number: if (ExtendedMode && m.Msg == (int)Win32.WM.LBUTTONDOWN)  			{  				var mouse = PointToClient(MousePosition);    				if (Enabled)  				{  					using (var g = CreateGraphics())  					{  						var offset = 2;  						if (ShowCheckBox)  						{  							var checkSize = swf.CheckBoxRenderer.GetGlyphSize(g' swf.VisualStyles.CheckBoxState.UncheckedNormal);  							var checkOffset = (ClientSize.Height - checkSize.Height) / 2;  							offset += checkOffset + checkSize.Width + 1;  						}    						if (Checked)  						{  							var test = mouse;  							test.X -= offset;  							for (int i = 0; i < segments.Count; i++)  							{  								var segment = segments[i];  								if (test.X >= segment.Start && test.X <= segment.End)  								{  									Focus();  									selectedSegment = i;  									Invalidate();  									return;  								}  							}  						}    						if (mouse.X > offset && mouse.X < ClientSize.Width - img.Width - 14)  						{  							Focus();  							return;  						}  					}  				}  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,WndProc,The following statement contains a magic number: if (ExtendedMode && m.Msg == (int)Win32.WM.LBUTTONDOWN)  			{  				var mouse = PointToClient(MousePosition);    				if (Enabled)  				{  					using (var g = CreateGraphics())  					{  						var offset = 2;  						if (ShowCheckBox)  						{  							var checkSize = swf.CheckBoxRenderer.GetGlyphSize(g' swf.VisualStyles.CheckBoxState.UncheckedNormal);  							var checkOffset = (ClientSize.Height - checkSize.Height) / 2;  							offset += checkOffset + checkSize.Width + 1;  						}    						if (Checked)  						{  							var test = mouse;  							test.X -= offset;  							for (int i = 0; i < segments.Count; i++)  							{  								var segment = segments[i];  								if (test.X >= segment.Start && test.X <= segment.End)  								{  									Focus();  									selectedSegment = i;  									Invalidate();  									return;  								}  							}  						}    						if (mouse.X > offset && mouse.X < ClientSize.Width - img.Width - 14)  						{  							Focus();  							return;  						}  					}  				}  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: int textOffset = (ClientSize.Height - fontSize.Height) / 2;
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: textRect.X += 2;
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: textRect.Width -= img.Width + 3 + 2;
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: textRect.Width -= img.Width + 3 + 2;
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: textRect.Height -= textOffset * 2;
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: if (ShowCheckBox)  			{  				var checkState = GetCheckBoxState();  				var checkSize = swf.CheckBoxRenderer.GetGlyphSize(g' checkState);  				var checkOffset = (ClientSize.Height - checkSize.Height) / 2;  				swf.CheckBoxRenderer.DrawCheckBox(g' new sd.Point(checkOffset' (ClientRectangle.Height - checkSize.Height) / 2)' checkState);    				// adjust text location  				textRect.X += checkSize.Width + checkOffset + 1;  				textRect.Width -= checkSize.Width + checkOffset + 1;  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: if (ShowCheckBox)  			{  				var checkState = GetCheckBoxState();  				var checkSize = swf.CheckBoxRenderer.GetGlyphSize(g' checkState);  				var checkOffset = (ClientSize.Height - checkSize.Height) / 2;  				swf.CheckBoxRenderer.DrawCheckBox(g' new sd.Point(checkOffset' (ClientRectangle.Height - checkSize.Height) / 2)' checkState);    				// adjust text location  				textRect.X += checkSize.Width + checkOffset + 1;  				textRect.Width -= checkSize.Width + checkOffset + 1;  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: if (hover || calendarOpen)  			{  				var buttonRect = new sd.Rectangle(ClientRectangle.Width - img.Width - 14' 0' img.Width + 14' ClientRectangle.Height);  				if (calendarOpen || buttonRect.Contains(PointToClient(MousePosition)))  				{  					var startColor = sd.Color.FromArgb(unchecked((int)0xFFE7F1FB));  					var endColor = sd.Color.FromArgb(unchecked((int)0xFFD4E6FB));  					var gradient = new sd.Drawing2D.LinearGradientBrush(buttonRect' startColor' endColor' 90f);  					g.FillRectangle(gradient' buttonRect);  					buttonRect.Width -= 1;  					buttonRect.Height -= 1;  					var buttonBorderCol = calendarOpen ? focusBorderCol : hoverBorderCol;  					using (var p = new sd.Pen(buttonBorderCol))  					{  						g.DrawRectangle(p' buttonRect);  					}  				}  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: if (hover || calendarOpen)  			{  				var buttonRect = new sd.Rectangle(ClientRectangle.Width - img.Width - 14' 0' img.Width + 14' ClientRectangle.Height);  				if (calendarOpen || buttonRect.Contains(PointToClient(MousePosition)))  				{  					var startColor = sd.Color.FromArgb(unchecked((int)0xFFE7F1FB));  					var endColor = sd.Color.FromArgb(unchecked((int)0xFFD4E6FB));  					var gradient = new sd.Drawing2D.LinearGradientBrush(buttonRect' startColor' endColor' 90f);  					g.FillRectangle(gradient' buttonRect);  					buttonRect.Width -= 1;  					buttonRect.Height -= 1;  					var buttonBorderCol = calendarOpen ? focusBorderCol : hoverBorderCol;  					using (var p = new sd.Pen(buttonBorderCol))  					{  						g.DrawRectangle(p' buttonRect);  					}  				}  			}
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: g.DrawImage(img' ClientRectangle.Width - img.Width - 7' (ClientRectangle.Height - img.Height) / 2 + 1);
Magic Number,Eto.WinForms.CustomControls,ExtendedDateTimePicker,C:\repos\picoe_Eto\Source\Eto.WinForms\CustomControls\ExtendedDateTimePicker.cs,OnPaint,The following statement contains a magic number: g.DrawImage(img' ClientRectangle.Width - img.Width - 7' (ClientRectangle.Height - img.Height) / 2 + 1);
Magic Number,ImageManipulation,OctreeQuantizer,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,OctreeQuantizer,The following statement contains a magic number: if (maxColors > 255)  				throw new ArgumentOutOfRangeException("maxColors"' maxColors' "The number of colors should be less than 256");
Magic Number,ImageManipulation,OctreeQuantizer,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,OctreeQuantizer,The following statement contains a magic number: if ((maxColorBits < 1) | (maxColorBits > 8))  				throw new ArgumentOutOfRangeException("maxColorBits"' maxColorBits' "This should be between 1 and 8");
Magic Number,ImageManipulation,Octree,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,Octree,The following statement contains a magic number: _reducibleNodes = new OctreeNode[9];
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,OctreeNode,The following statement contains a magic number: if (_leaf)  					{  						octree.Leaves++;  						_nextReducible = null;  						_children = null;   					}  					else  					{  						// Otherwise add this to the reducible nodes  						_nextReducible = octree.ReducibleNodes[level];  						octree.ReducibleNodes[level] = this;  						_children = new OctreeNode[8];  					}
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,AddColor,The following statement contains a magic number: if (_leaf)  					{  						Increment(pixel);  						// Setup the previous node  						octree.TrackPrevious(this);  					}  					else  					{  						// Go to the next level down in the tree  						int	shift = 7 - level;  						int index = ((pixel->Red & mask[level]) >> (shift - 2)) |  						            ((pixel->Green & mask[level]) >> (shift - 1)) |  						            ((pixel->Blue & mask[level]) >> (shift));    						OctreeNode	child = _children[index];    						if (null == child)  						{  							// Create a new child node & store in the array  							child = new OctreeNode(level + 1' colorBits' octree);   							_children[index] = child;  						}    						// Add the color to the child node  						child.AddColor(pixel' colorBits' level + 1' octree);  					}
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,AddColor,The following statement contains a magic number: if (_leaf)  					{  						Increment(pixel);  						// Setup the previous node  						octree.TrackPrevious(this);  					}  					else  					{  						// Go to the next level down in the tree  						int	shift = 7 - level;  						int index = ((pixel->Red & mask[level]) >> (shift - 2)) |  						            ((pixel->Green & mask[level]) >> (shift - 1)) |  						            ((pixel->Blue & mask[level]) >> (shift));    						OctreeNode	child = _children[index];    						if (null == child)  						{  							// Create a new child node & store in the array  							child = new OctreeNode(level + 1' colorBits' octree);   							_children[index] = child;  						}    						// Add the color to the child node  						child.AddColor(pixel' colorBits' level + 1' octree);  					}
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,Reduce,The following statement contains a magic number: for (int index = 0; index < 8; index++)  					{  						if (null != _children[index])  						{  							_red += _children[index]._red;  							_green += _children[index]._green;  							_blue += _children[index]._blue;  							_pixelCount += _children[index]._pixelCount;  							++children;  							_children[index] = null;  						}  					}
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,ConstructPalette,The following statement contains a magic number: if (_leaf)  					{  						// Consume the next palette index  						_paletteIndex = paletteIndex++;    						// And set the color of the palette entry  						palette.Add(Color.FromArgb(_red / _pixelCount' _green / _pixelCount' _blue / _pixelCount));  					}  					else  					{  						// Loop through children looking for leaves  						for (int index = 0; index < 8; index++)  						{  							if (null != _children[index])  								_children[index].ConstructPalette(palette' ref paletteIndex);  						}  					}
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,GetPaletteIndex,The following statement contains a magic number: if (!_leaf)  					{  						int	shift = 7 - level;  						int index = ((pixel->Red & mask[level]) >> (shift - 2)) |  						            ((pixel->Green & mask[level]) >> (shift - 1)) |  						            ((pixel->Blue & mask[level]) >> (shift));    						if (null != _children[index])  							paletteIndex = _children[index].GetPaletteIndex(pixel' level + 1);  						else  							throw new ArgumentNullException(string.Format(CultureInfo.CurrentCulture' "Didn't expect this!"));  					}
Magic Number,ImageManipulation,OctreeNode,C:\repos\picoe_Eto\Source\Eto.WinForms\OctreeQuantizer.cs,GetPaletteIndex,The following statement contains a magic number: if (!_leaf)  					{  						int	shift = 7 - level;  						int index = ((pixel->Red & mask[level]) >> (shift - 2)) |  						            ((pixel->Green & mask[level]) >> (shift - 1)) |  						            ((pixel->Blue & mask[level]) >> (shift));    						if (null != _children[index])  							paletteIndex = _children[index].GetPaletteIndex(pixel' level + 1);  						else  							throw new ArgumentNullException(string.Format(CultureInfo.CurrentCulture' "Didn't expect this!"));  					}
Magic Number,Eto.WinForms.Forms.Menu,MenuBarHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Menu\MenuBarHandler.cs,SetQuitItem,The following statement contains a magic number: item.Order = 1000;
Magic Number,Eto.WinForms.Forms.Menu,MenuBarHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Menu\MenuBarHandler.cs,SetQuitItem,The following statement contains a magic number: if (quitItem != null)  				ApplicationMenu.Items.Remove(quitItem);  			else  				ApplicationMenu.Items.AddSeparator(999);
Magic Number,Eto.WinForms.Forms.Menu,MenuBarHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Menu\MenuBarHandler.cs,SetAboutItem,The following statement contains a magic number: item.Order = 1000;
Magic Number,Eto.WinForms.Forms.Menu,MenuBarHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Menu\MenuBarHandler.cs,SetAboutItem,The following statement contains a magic number: if (aboutItem != null)  				HelpMenu.Items.Remove(aboutItem);  			else  				HelpMenu.Items.AddSeparator(999);
Magic Number,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,GetPixel,The following statement contains a magic number: if (BytesPerPixel == 4)  			{  				var col = TranslateDataToArgb(*((int*)pos));  				return Color.FromArgb(col);  			}
Magic Number,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,GetPixel,The following statement contains a magic number: if (BytesPerPixel == 3)  			{  				var col = TranslateDataToArgb(*((int*)pos));  				return Color.FromRgb(col);  			}
Magic Number,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,SetPixel,The following statement contains a magic number: if (BytesPerPixel == 4)  			{  				*((int*)pos) = col;  			}  			else if (BytesPerPixel == 3)  			{  				*(pos++) = (byte)(col & 0xFF);  				*(pos++) = (byte)((col >> 8) & 0xFF);  				*(pos++) = (byte)((col >> 16) & 0xFF);  			}  			else  				throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture' "This PixelFormat is not supported by SetPixel. Must be 3 or 4 bytes per pixel"));
Magic Number,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,SetPixel,The following statement contains a magic number: if (BytesPerPixel == 4)  			{  				*((int*)pos) = col;  			}  			else if (BytesPerPixel == 3)  			{  				*(pos++) = (byte)(col & 0xFF);  				*(pos++) = (byte)((col >> 8) & 0xFF);  				*(pos++) = (byte)((col >> 16) & 0xFF);  			}  			else  				throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture' "This PixelFormat is not supported by SetPixel. Must be 3 or 4 bytes per pixel"));
Magic Number,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,SetPixel,The following statement contains a magic number: if (BytesPerPixel == 4)  			{  				*((int*)pos) = col;  			}  			else if (BytesPerPixel == 3)  			{  				*(pos++) = (byte)(col & 0xFF);  				*(pos++) = (byte)((col >> 8) & 0xFF);  				*(pos++) = (byte)((col >> 16) & 0xFF);  			}  			else  				throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture' "This PixelFormat is not supported by SetPixel. Must be 3 or 4 bytes per pixel"));
Magic Number,Eto.Shared.Drawing,BaseBitmapData,C:\repos\picoe_Eto\Source\Shared\BaseBitmapData.cs,SetPixel,The following statement contains a magic number: if (BytesPerPixel == 4)  			{  				*((int*)pos) = col;  			}  			else if (BytesPerPixel == 3)  			{  				*(pos++) = (byte)(col & 0xFF);  				*(pos++) = (byte)((col >> 8) & 0xFF);  				*(pos++) = (byte)((col >> 16) & 0xFF);  			}  			else  				throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture' "This PixelFormat is not supported by SetPixel. Must be 3 or 4 bytes per pixel"));
Missing Default,Eto,GradientHelper,C:\repos\picoe_Eto\Source\Shared\GradientHelper.cs,GetGradientStops,The following switch statement is missing a default case: switch (wrap)  			{  				case GradientWrapMode.Repeat:  					while (inc > 0f && pos < 1f)  					{  						yield return new Tuple<float' TColor>(pos' endColor);  						yield return new Tuple<float' TColor>(pos' startColor);  						pos += inc;  					}  					yield return new Tuple<float' TColor>(1f' endColor);  					break;  				case GradientWrapMode.Reflect:  					var factor = true;  					while (inc > 0f && pos < 1f)  					{  						yield return new Tuple<float' TColor>(pos' factor ? endColor : startColor);  						factor = !factor;  						pos += inc;  					}  					yield return new Tuple<float' TColor>(1f' factor ? endColor : startColor);  					break;  				case GradientWrapMode.Pad:  					yield return new Tuple<float' TColor>(pos' endColor);  					if (pos < 1f)  					{  						yield return new Tuple<float' TColor>(1f' endColor);  					}  					break;  			}
Missing Default,Eto.WinForms,BubbleEventFilter,C:\repos\picoe_Eto\Source\Eto.WinForms\BubbleEventFilter.cs,IsInputKey,The following switch statement is missing a default case: switch (keyData & Keys.KeyMask)  			{  				case Keys.Tab:  					num = 6;  					break;  				case Keys.Left:  				case Keys.Up:  				case Keys.Right:  				case Keys.Down:  					num = 5;  					break;  			}
Missing Default,Eto.WinForms.Forms.Controls,EtoLabel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\LabelHandler.cs,SetStringFormat,The following switch statement is missing a default case: switch (Wrap)  				{  					case WrapMode.None:  						textFormat |= swf.TextFormatFlags.SingleLine;  						break;  					case WrapMode.Word:  						textFormat |= swf.TextFormatFlags.WordBreak;  						break;  					case WrapMode.Character:  						break;  				}
Missing Default,Eto.WinForms.Forms.Controls,EtoLabel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\LabelHandler.cs,SetStringFormat,The following switch statement is missing a default case: switch (TextAlignment)  				{  					case TextAlignment.Left:  						textFormat |= swf.TextFormatFlags.Left;  						break;  					case TextAlignment.Right:  						textFormat |= swf.TextFormatFlags.Right;  						break;  					case TextAlignment.Center:  						textFormat |= swf.TextFormatFlags.HorizontalCenter;  						break;  				}
Missing Default,Eto.WinForms.Forms.Controls,EtoLabel,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\LabelHandler.cs,SetStringFormat,The following switch statement is missing a default case: switch (VerticalAlignment)  				{  					case VerticalAlignment.Top:  					case VerticalAlignment.Stretch:  						textFormat |= swf.TextFormatFlags.Top;  						break;  					case VerticalAlignment.Bottom:  						textFormat |= swf.TextFormatFlags.Bottom;  						break;  					case VerticalAlignment.Center:  						textFormat |= swf.TextFormatFlags.VerticalCenter;  						break;  				}
Missing Default,Eto.WinForms.Forms.Controls,SplitterHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\SplitterHandler.cs,SetRelative,The following switch statement is missing a default case: switch (fixedPanel)  			{  				case SplitterFixedPanel.Panel1:  					Control.SplitterDistance = Math.Max(0' Math.Min(size' (int)Math.Round(relative)));  					break;  				case SplitterFixedPanel.Panel2:  					Control.SplitterDistance = Math.Max(0' Math.Min(size' size - (int)Math.Round(relative)));  					break;  				case SplitterFixedPanel.None:  					Control.SplitterDistance = Math.Max(0' Math.Min(size' (int)Math.Round(size * relative)));  					break;  			}
Missing Default,Eto.WinForms.Forms.Controls,TextBoxHandler<TControl;TWidget;TCallback>,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\TextBoxHandler.cs,AttachEvent,The following switch statement is missing a default case: switch (e.KeyData)  						{  							case Keys.Delete:  							case Keys.Backspace:  							case Keys.Shift | Keys.Delete:  							case Keys.Shift | Keys.Backspace:  								var selection = Selection;  								if (selection.Length() == 0)  									selection = new Range<int>(e.KeyData == Keys.Delete ? CaretIndex : CaretIndex - 1);  								if (selection.Start >= 0 && selection.End < SwfTextBox.TextLength)  								{  									var tia = new TextChangingEventArgs(string.Empty' selection);  									Callback.OnTextChanging(Widget' tia);  									e.Handled = tia.Cancel;  								}  								break;  							case Keys.Control | Keys.Delete:  								{  									// delete next word  									string text = Text;  									int start = CaretIndex;  									int end = start;  									int length = text.Length;    									// find end of next word  									while (end < length && !testIsNonWord(text[end]))  										end++;  									while (end < length && testIsNonWord(text[end]))  										end++;    									if (end > start)  									{  										var tia = new TextChangingEventArgs(string.Empty' new Range<int>(start' end - 1));  										Callback.OnTextChanging(Widget' tia);  										e.Handled = tia.Cancel;  									}  								}  								break;  							case Keys.Control | Keys.Backspace:  								{  									// delete previous word  									string text = Text;  									int end = CaretIndex;  									int start = end;    									// find start of previous word  									while (start > 0 && testIsNonWord(text[start - 1]))  										start--;  									while (start > 0 && !testIsNonWord(text[start - 1]))  										start--;    									if (end > start)  									{  										var tia = new TextChangingEventArgs(string.Empty' new Range<int>(start' end - 1));  										Callback.OnTextChanging(Widget' tia);  										e.Handled = tia.Cancel;  									}  								}  								break;  						}
Missing Default,Eto.WinForms.Forms.Controls,WebViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\WebViewHandler.cs,AttachEvent,The following switch statement is missing a default case: switch (handler)  			{  				case WebView.OpenNewWindowEvent:  					control.NewWindow += WebBrowserV1_NewWindow;  					break;  			}
Missing Default,Eto.WinForms.Forms.Controls,WebViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\WebViewHandler.cs,WebViewHandler,The following switch statement is missing a default case: switch (e.KeyCode)  				{  					case swf.Keys.Down:  					case swf.Keys.Up:  					case swf.Keys.Left:  					case swf.Keys.Right:  					case swf.Keys.PageDown:  					case swf.Keys.PageUp:  						// enable scrolling via keyboard  						e.IsInputKey = true;  						return;  				}
Missing Default,Eto.WinForms.Forms.Controls,WebViewHandler,C:\repos\picoe_Eto\Source\Eto.WinForms\Forms\Controls\WebViewHandler.cs,WebViewHandler,The following switch statement is missing a default case: switch (e.KeyData)  					{  						case (swf.Keys.C | swf.Keys.Control):  							doc.ExecCommand("Copy"' false' null);  							break;  						case (swf.Keys.V | swf.Keys.Control):  							if (doc.ActiveElement != null && ValidInputTags.Contains(doc.ActiveElement.TagName.ToLowerInvariant()))  								doc.ExecCommand("Paste"' false' null);  							break;  						case (swf.Keys.X | swf.Keys.Control):  							if (doc.ActiveElement != null && ValidInputTags.Contains(doc.ActiveElement.TagName.ToLowerInvariant()))  								doc.ExecCommand("Cut"' false' null);  							break;  						case (swf.Keys.A | swf.Keys.Control):  							doc.ExecCommand("SelectAll"' false' null);  							break;  					}
