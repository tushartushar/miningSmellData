Implementation smell,Namespace,Class,File,Method,Description
Magic Number,AdvancedDataStructures,PriorityQueue<T>,C:\repos\flextry_Telerik-Academy\Programming with C#\5. C# Data Structures and Algorithms\05. Advanced Data Structures\01. PriorityQueue\PriorityQueue.cs,Add,The following statement contains a magic number: int parentIndex = childIndex / 2;
Magic Number,AdvancedDataStructures,PriorityQueue<T>,C:\repos\flextry_Telerik-Academy\Programming with C#\5. C# Data Structures and Algorithms\05. Advanced Data Structures\01. PriorityQueue\PriorityQueue.cs,Add,The following statement contains a magic number: while (parentIndex >= 1 && this.heap[childIndex].CompareTo(this.heap[parentIndex]) < 0)              {                  T swapValue = this.heap[parentIndex];                  this.heap[parentIndex] = this.heap[childIndex];                  this.heap[childIndex] = swapValue;                    childIndex = parentIndex;                  parentIndex = childIndex / 2;              }
Magic Number,AdvancedDataStructures,PriorityQueue<T>,C:\repos\flextry_Telerik-Academy\Programming with C#\5. C# Data Structures and Algorithms\05. Advanced Data Structures\01. PriorityQueue\PriorityQueue.cs,RemoveFirst,The following statement contains a magic number: while (true)              {                  int leftChildIndex = rootIndex * 2;                  int rightChildIndex = rootIndex * 2 + 1;                    if (leftChildIndex > this.index)                      break;                    if (rightChildIndex > this.index)                  {                      minChild = leftChildIndex;                  }                  else if (this.heap[leftChildIndex].CompareTo(this.heap[rightChildIndex]) < 0)                  {                      minChild = leftChildIndex;                  }                  else                  {                      minChild = rightChildIndex;                  }                    if (this.heap[minChild].CompareTo(this.heap[rootIndex]) < 0)                  {                      T swapValue = this.heap[rootIndex];                      this.heap[rootIndex] = this.heap[minChild];                      this.heap[minChild] = swapValue;                        rootIndex = minChild;                  }                  else                  {                      break;                  }              }
Magic Number,AdvancedDataStructures,PriorityQueue<T>,C:\repos\flextry_Telerik-Academy\Programming with C#\5. C# Data Structures and Algorithms\05. Advanced Data Structures\01. PriorityQueue\PriorityQueue.cs,RemoveFirst,The following statement contains a magic number: while (true)              {                  int leftChildIndex = rootIndex * 2;                  int rightChildIndex = rootIndex * 2 + 1;                    if (leftChildIndex > this.index)                      break;                    if (rightChildIndex > this.index)                  {                      minChild = leftChildIndex;                  }                  else if (this.heap[leftChildIndex].CompareTo(this.heap[rightChildIndex]) < 0)                  {                      minChild = leftChildIndex;                  }                  else                  {                      minChild = rightChildIndex;                  }                    if (this.heap[minChild].CompareTo(this.heap[rootIndex]) < 0)                  {                      T swapValue = this.heap[rootIndex];                      this.heap[rootIndex] = this.heap[minChild];                      this.heap[minChild] = swapValue;                        rootIndex = minChild;                  }                  else                  {                      break;                  }              }
Magic Number,AdvancedDataStructures,PriorityQueue<T>,C:\repos\flextry_Telerik-Academy\Programming with C#\5. C# Data Structures and Algorithms\05. Advanced Data Structures\01. PriorityQueue\PriorityQueue.cs,IncreaseArrayIfNecessary,The following statement contains a magic number: if (this.index >= this.heap.Length - 1)              {                  T[] copiedHeap = new T[this.heap.Length * 2];                    Array.Copy(this.heap' 0' copiedHeap' 0' this.heap.Length);                    this.heap = copiedHeap;              }
