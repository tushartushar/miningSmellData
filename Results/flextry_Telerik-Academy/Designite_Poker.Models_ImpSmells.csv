Implementation smell,Namespace,Class,File,Method,Description
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType)              {                  comparisonResult = 1;              }              else if (firstHandType < secondHandType)              {                  comparisonResult = -1;              }              else if (firstHandType == HandType.OnePair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);                    if (comparisonResult == 0)                  {                      var firstOtherCards = firstGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                      var secondOtherCards = secondGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                        for (int i = 0; i < firstOtherCards.Length; i++)                      {                          var comparison = firstOtherCards[i].Face.CompareTo(secondOtherCards[i].Face);                          if (comparison != 0)                          {                              comparisonResult = comparison;                              break;                          }                      }                  }              }              else if (firstHandType == HandType.TwoPair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    var firstHandCards = new List<ICard>();                  firstHandCards.Add(firstGroupedByFace[0].First());                  firstHandCards.Add(firstGroupedByFace[1].First());                  firstHandCards = firstHandCards.OrderByDescending(c => c.Face).ToList();                  firstHandCards.Add(firstGroupedByFace[2].First());                    var secondHandCards = new List<ICard>();                  secondHandCards.Add(secondGroupedByFace[0].First());                  secondHandCards.Add(secondGroupedByFace[1].First());                  secondHandCards = secondHandCards.OrderByDescending(c => c.Face).ToList();                  secondHandCards.Add(secondGroupedByFace[2].First());                    comparisonResult = firstHandCards[0].Face.CompareTo(secondHandCards[0].Face);                    if (comparisonResult == 0)                  {                      comparisonResult = firstHandCards[1].Face.CompareTo(secondHandCards[1].Face);                        if (comparisonResult == 0)                      {                          comparisonResult = firstHandCards[2].Face.CompareTo(secondHandCards[2].Face);                      }                  }              }              else if (firstHandType == HandType.FullHouse)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    for (int i = 0; i < firstSortedByFace.Length; i++)                  {                      var comparison = firstSortedByFace[i].Face.CompareTo(secondSortedByFace[i].Face);                      if (comparison != 0)                      {                          comparisonResult = comparison;                          break;                      }                  }              }              else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    comparisonResult = firstSortedByFace[0].Face.CompareTo(secondSortedByFace[0].Face);              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType)              {                  comparisonResult = 1;              }              else if (firstHandType < secondHandType)              {                  comparisonResult = -1;              }              else if (firstHandType == HandType.OnePair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);                    if (comparisonResult == 0)                  {                      var firstOtherCards = firstGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                      var secondOtherCards = secondGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                        for (int i = 0; i < firstOtherCards.Length; i++)                      {                          var comparison = firstOtherCards[i].Face.CompareTo(secondOtherCards[i].Face);                          if (comparison != 0)                          {                              comparisonResult = comparison;                              break;                          }                      }                  }              }              else if (firstHandType == HandType.TwoPair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    var firstHandCards = new List<ICard>();                  firstHandCards.Add(firstGroupedByFace[0].First());                  firstHandCards.Add(firstGroupedByFace[1].First());                  firstHandCards = firstHandCards.OrderByDescending(c => c.Face).ToList();                  firstHandCards.Add(firstGroupedByFace[2].First());                    var secondHandCards = new List<ICard>();                  secondHandCards.Add(secondGroupedByFace[0].First());                  secondHandCards.Add(secondGroupedByFace[1].First());                  secondHandCards = secondHandCards.OrderByDescending(c => c.Face).ToList();                  secondHandCards.Add(secondGroupedByFace[2].First());                    comparisonResult = firstHandCards[0].Face.CompareTo(secondHandCards[0].Face);                    if (comparisonResult == 0)                  {                      comparisonResult = firstHandCards[1].Face.CompareTo(secondHandCards[1].Face);                        if (comparisonResult == 0)                      {                          comparisonResult = firstHandCards[2].Face.CompareTo(secondHandCards[2].Face);                      }                  }              }              else if (firstHandType == HandType.FullHouse)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    for (int i = 0; i < firstSortedByFace.Length; i++)                  {                      var comparison = firstSortedByFace[i].Face.CompareTo(secondSortedByFace[i].Face);                      if (comparison != 0)                      {                          comparisonResult = comparison;                          break;                      }                  }              }              else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    comparisonResult = firstSortedByFace[0].Face.CompareTo(secondSortedByFace[0].Face);              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType)              {                  comparisonResult = 1;              }              else if (firstHandType < secondHandType)              {                  comparisonResult = -1;              }              else if (firstHandType == HandType.OnePair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);                    if (comparisonResult == 0)                  {                      var firstOtherCards = firstGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                      var secondOtherCards = secondGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                        for (int i = 0; i < firstOtherCards.Length; i++)                      {                          var comparison = firstOtherCards[i].Face.CompareTo(secondOtherCards[i].Face);                          if (comparison != 0)                          {                              comparisonResult = comparison;                              break;                          }                      }                  }              }              else if (firstHandType == HandType.TwoPair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    var firstHandCards = new List<ICard>();                  firstHandCards.Add(firstGroupedByFace[0].First());                  firstHandCards.Add(firstGroupedByFace[1].First());                  firstHandCards = firstHandCards.OrderByDescending(c => c.Face).ToList();                  firstHandCards.Add(firstGroupedByFace[2].First());                    var secondHandCards = new List<ICard>();                  secondHandCards.Add(secondGroupedByFace[0].First());                  secondHandCards.Add(secondGroupedByFace[1].First());                  secondHandCards = secondHandCards.OrderByDescending(c => c.Face).ToList();                  secondHandCards.Add(secondGroupedByFace[2].First());                    comparisonResult = firstHandCards[0].Face.CompareTo(secondHandCards[0].Face);                    if (comparisonResult == 0)                  {                      comparisonResult = firstHandCards[1].Face.CompareTo(secondHandCards[1].Face);                        if (comparisonResult == 0)                      {                          comparisonResult = firstHandCards[2].Face.CompareTo(secondHandCards[2].Face);                      }                  }              }              else if (firstHandType == HandType.FullHouse)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    for (int i = 0; i < firstSortedByFace.Length; i++)                  {                      var comparison = firstSortedByFace[i].Face.CompareTo(secondSortedByFace[i].Face);                      if (comparison != 0)                      {                          comparisonResult = comparison;                          break;                      }                  }              }              else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    comparisonResult = firstSortedByFace[0].Face.CompareTo(secondSortedByFace[0].Face);              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType)              {                  comparisonResult = 1;              }              else if (firstHandType < secondHandType)              {                  comparisonResult = -1;              }              else if (firstHandType == HandType.OnePair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);                    if (comparisonResult == 0)                  {                      var firstOtherCards = firstGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                      var secondOtherCards = secondGroupedByFace.Skip(1).Select(g => g.First()).OrderByDescending(c => c.Face).ToArray();                        for (int i = 0; i < firstOtherCards.Length; i++)                      {                          var comparison = firstOtherCards[i].Face.CompareTo(secondOtherCards[i].Face);                          if (comparison != 0)                          {                              comparisonResult = comparison;                              break;                          }                      }                  }              }              else if (firstHandType == HandType.TwoPair)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    var firstHandCards = new List<ICard>();                  firstHandCards.Add(firstGroupedByFace[0].First());                  firstHandCards.Add(firstGroupedByFace[1].First());                  firstHandCards = firstHandCards.OrderByDescending(c => c.Face).ToList();                  firstHandCards.Add(firstGroupedByFace[2].First());                    var secondHandCards = new List<ICard>();                  secondHandCards.Add(secondGroupedByFace[0].First());                  secondHandCards.Add(secondGroupedByFace[1].First());                  secondHandCards = secondHandCards.OrderByDescending(c => c.Face).ToList();                  secondHandCards.Add(secondGroupedByFace[2].First());                    comparisonResult = firstHandCards[0].Face.CompareTo(secondHandCards[0].Face);                    if (comparisonResult == 0)                  {                      comparisonResult = firstHandCards[1].Face.CompareTo(secondHandCards[1].Face);                        if (comparisonResult == 0)                      {                          comparisonResult = firstHandCards[2].Face.CompareTo(secondHandCards[2].Face);                      }                  }              }              else if (firstHandType == HandType.FullHouse)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    for (int i = 0; i < firstSortedByFace.Length; i++)                  {                      var comparison = firstSortedByFace[i].Face.CompareTo(secondSortedByFace[i].Face);                      if (comparison != 0)                      {                          comparisonResult = comparison;                          break;                      }                  }              }              else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind)              {                  var firstGroupedByFace = firstHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                  var secondGroupedByFace = secondHand.Cards.GroupBy(c => c.Face).OrderByDescending(g => g.Count()).ToArray();                    comparisonResult = firstGroupedByFace[0].First().Face.CompareTo(secondGroupedByFace[0].First().Face);              }              else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush)              {                  var firstSortedByFace = firstHand.Cards.OrderByDescending(c => c.Face).ToArray();                  var secondSortedByFace = secondHand.Cards.OrderByDescending(c => c.Face).ToArray();                    comparisonResult = firstSortedByFace[0].Face.CompareTo(secondSortedByFace[0].Face);              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2)              {                  if (groupedByCardFace[0].Count() == 4)                  {                      return HandType.FourOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 3 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.FullHouse;                  }              }              else if (groupedByCardFace.Length == 3)              {                  if (groupedByCardFace[0].Count() == 3)                  {                      return HandType.ThreeOfAKind;                  }                  else if (groupedByCardFace[0].Count() == 2 && groupedByCardFace[1].Count() == 2)                  {                      return HandType.TwoPair;                  }              }              else if (groupedByCardFace.Length == 4)              {                  return HandType.OnePair;              }
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,IsStraight,The following statement contains a magic number: bool isStraight = cardsSortedByFace[cardsSortedByFace.Length - 1].Face - cardsSortedByFace[0].Face == 4 ||                                (cardsSortedByFace[cardsSortedByFace.Length - 1].Face == CardFace.Ace &&                                 cardsSortedByFace[cardsSortedByFace.Length - 2].Face == CardFace.Five);
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,IsStraight,The following statement contains a magic number: bool isStraight = cardsSortedByFace[cardsSortedByFace.Length - 1].Face - cardsSortedByFace[0].Face == 4 ||                                (cardsSortedByFace[cardsSortedByFace.Length - 1].Face == CardFace.Ace &&                                 cardsSortedByFace[cardsSortedByFace.Length - 2].Face == CardFace.Five);
Magic Number,Poker.Models,PokerHandsChecker,C:\repos\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,IsValidHand,The following statement contains a magic number: var isValidHand = handWithUniqueCards.Count() == 5 && handWithUniqueCards.Count() == hand.Cards.Count;
